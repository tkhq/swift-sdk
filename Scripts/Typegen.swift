#!/usr/bin/env swift

import Foundation

// MARK: - Configuration

let SOURCE_DIRECTORY = URL(fileURLWithPath: #file)
    .deletingLastPathComponent()
    .deletingLastPathComponent()
    .appendingPathComponent("Sources/TurnkeyTypes")

let PUBLIC_API_SWAGGER_PATH = SOURCE_DIRECTORY
    .appendingPathComponent("Resources/Resources/public_api.swagger.json")

let AUTH_PROXY_SWAGGER_PATH = SOURCE_DIRECTORY
    .appendingPathComponent("Resources/Resources/auth_proxy.swagger.json")

let OUTPUT_PATH = SOURCE_DIRECTORY
    .appendingPathComponent("Generated/Types.swift")

let COMMENT_HEADER = "// @generated by Typegen. DO NOT EDIT BY HAND"

// Activity types that have versioned variants
let VERSIONED_ACTIVITY_TYPES: [String: String] = [
    "ACTIVITY_TYPE_CREATE_AUTHENTICATORS": "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2",
    "ACTIVITY_TYPE_CREATE_API_KEYS": "ACTIVITY_TYPE_CREATE_API_KEYS_V2",
    "ACTIVITY_TYPE_CREATE_POLICY": "ACTIVITY_TYPE_CREATE_POLICY_V3",
    "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS": "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2",
    "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION": "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7",
    "ACTIVITY_TYPE_CREATE_USERS": "ACTIVITY_TYPE_CREATE_USERS_V3",
    "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD": "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
    "ACTIVITY_TYPE_SIGN_TRANSACTION": "ACTIVITY_TYPE_SIGN_TRANSACTION_V2",
    "ACTIVITY_TYPE_EMAIL_AUTH": "ACTIVITY_TYPE_EMAIL_AUTH_V2",
    "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION": "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2",
    "ACTIVITY_TYPE_UPDATE_POLICY": "ACTIVITY_TYPE_UPDATE_POLICY_V2",
    "ACTIVITY_TYPE_INIT_OTP_AUTH": "ACTIVITY_TYPE_INIT_OTP_AUTH_V2",
]

// Methods that have only optional parameters
let METHODS_WITH_ONLY_OPTIONAL_PARAMETERS = [
    "tGetActivities",
    "tGetApiKeys",
    "tGetOrganization",
    "tGetPolicies",
    "tGetPrivateKeys",
    "tGetSubOrgIds",
    "tGetUsers",
    "tGetWallets",
    "tGetWhoami",
    "tListPrivateKeys",
    "tListUserTags",
]

// MARK: - Models

struct SwaggerSpec: Codable {
    let swagger: String
    let info: Info
    let paths: [String: PathItem]
    let definitions: [String: Definition]
    let tags: [Tag]?
    
    struct Info: Codable {
        let title: String
        let version: String
    }
    
    struct Tag: Codable {
        let name: String
        let description: String?
    }
    
    struct PathItem: Codable {
        let post: Operation?
        let get: Operation?
    }
    
    struct Operation: Codable {
        let operationId: String
        let summary: String?
        let description: String?
        let tags: [String]?
        let parameters: [Parameter]?
        let responses: [String: Response]?
    }
    
    struct Parameter: Codable {
        let name: String
        let `in`: String
        let required: Bool?
        let schema: Schema?
    }
    
    struct Schema: Codable {
        let ref: String?
        let type: String?
        let items: Box<Schema>?
        let properties: [String: Box<Schema>]?
        let additionalProperties: Box<AdditionalProperties>?
        let description: String?
        let `enum`: [String]?
        
        enum CodingKeys: String, CodingKey {
            case ref = "$ref"
            case type, items, properties, additionalProperties, description
            case `enum`
        }
        
        indirect enum AdditionalProperties: Codable {
            case bool(Bool)
            case schema(Schema)
            
            init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let bool = try? container.decode(Bool.self) {
                    self = .bool(bool)
                } else if let schema = try? container.decode(Schema.self) {
                    self = .schema(schema)
                } else {
                    self = .bool(false)
                }
            }
            
            func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .bool(let value):
                    try container.encode(value)
                case .schema(let schema):
                    try container.encode(schema)
                }
            }
        }
    }
    
    struct Response: Codable {
        let description: String?
        let schema: Schema?
    }
    
    struct Definition: Codable {
        let type: String?
        let properties: [String: Box<Schema>]?
        let required: [String]?
        let additionalProperties: Box<Schema.AdditionalProperties>?
        let `enum`: [String]?
        let description: String?
    }
}

// Box type to handle recursive Schema structure
class Box<T: Codable>: Codable {
    let value: T
    
    init(_ value: T) {
        self.value = value
    }
    
    required init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        value = try container.decode(T.self)
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(value)
    }
}

struct VersionInfo {
    let fullName: String
    let formattedKeyName: String
    let versionSuffix: String
}

// MARK: - Helper Functions

func lowerFirstLetter(_ input: String) -> String {
    guard !input.isEmpty else { return input }
    return input.prefix(1).lowercased() + input.dropFirst()
}

func upperFirstLetter(_ input: String) -> String {
    guard !input.isEmpty else { return input }
    return input.prefix(1).uppercased() + input.dropFirst()
}

func stripVersionPrefix(_ name: String) -> String {
    return name.replacingOccurrences(of: "^v\\d+", with: "", options: .regularExpression)
}

func refToSwift(_ ref: String) -> String {
    return ref.replacingOccurrences(of: "#/definitions/", with: "")
}

func isValidIdentifier(_ name: String) -> Bool {
    // Swift reserved keywords
    let reservedKeywords = [
        "operator", "protocol", "Type", "Self", "self",
        "associatedtype", "class", "deinit", "enum", "extension",
        "func", "import", "init", "inout", "internal", "let",
        "operator", "private", "protocol", "public", "static",
        "struct", "subscript", "typealias", "var", "break",
        "case", "continue", "default", "defer", "do", "else",
        "fallthrough", "for", "guard", "if", "in", "repeat",
        "return", "switch", "where", "while", "as", "Any",
        "catch", "false", "is", "nil", "rethrows", "super",
        "throw", "throws", "true", "try"
    ]
    
    // Check if it's a reserved keyword
    if reservedKeywords.contains(name) {
        return false
    }
    
    // Check if it starts with @ or contains special characters
    if name.hasPrefix("@") || name.contains("@") || name.contains("-") || name.contains(".") {
        return false
    }
    
    // Check if it matches standard identifier pattern
    let pattern = "^[a-zA-Z_][a-zA-Z0-9_]*$"
    return name.range(of: pattern, options: .regularExpression) != nil
}

func swaggerTypeToSwift(_ type: String?, schema: SwaggerSpec.Schema) -> String {
    guard let type = type else { return "Any" }
    
    switch type {
    case "integer", "number":
        return "Int"
    case "boolean":
        return "Bool"
    case "string":
        return "String"
    case "array":
        if let items = schema.items?.value {
            if let ref = items.ref {
                return "[\(refToSwift(ref))]"
            } else if let itemType = items.type {
                return "[\(swaggerTypeToSwift(itemType, schema: items))]"
            }
        }
        return "[Any]"
    case "object":
        // Check if it has additionalProperties
        if let additionalProps = schema.additionalProperties?.value {
            switch additionalProps {
            case .schema(let propSchema):
                if let ref = propSchema.ref {
                    return "[String: \(refToSwift(ref))]"
                } else if let propType = propSchema.type {
                    return "[String: \(swaggerTypeToSwift(propType, schema: propSchema))]"
                }
            case .bool:
                // additionalProperties: true means any type
                return "[String: Any]"
            }
        }
        // If it has properties, it's a defined structure (shouldn't reach here usually)
        if schema.properties != nil {
            return "[String: Any]"
        }
        return "[String: Any]"
    default:
        return "Any"
    }
}

// Extract latest versions from definitions (similar to JS version)
func extractLatestVersions(definitions: [String: SwaggerSpec.Definition]) -> [String: VersionInfo] {
    var latestVersions: [String: VersionInfo] = [:]
    
    // Regex to separate the version prefix, base name, and optional version suffix
    let pattern = #"^(v\d+)([A-Z][A-Za-z0-9]*?)(V\d+)?$"#
    let regex = try! NSRegularExpression(pattern: pattern)
    
    for key in definitions.keys {
        let nsString = key as NSString
        let range = NSRange(location: 0, length: nsString.length)
        
        if let match = regex.firstMatch(in: key, range: range) {
            let baseName = nsString.substring(with: match.range(at: 2))
            let versionSuffix = match.range(at: 3).location != NSNotFound 
                ? nsString.substring(with: match.range(at: 3))
                : ""
            
            let formattedKeyName = lowerFirstLetter(baseName) + versionSuffix
            
            // Determine if this version is newer
            if latestVersions[baseName] == nil ||
               versionSuffix > (latestVersions[baseName]?.versionSuffix ?? "") {
                latestVersions[baseName] = VersionInfo(
                    fullName: key,
                    formattedKeyName: formattedKeyName,
                    versionSuffix: versionSuffix
                )
            }
        }
    }
    
    return latestVersions
}

enum MethodType {
    case query
    case command
    case activityDecision
    case noop
    case proxy
    
    static func from(methodName: String) -> MethodType {
        let lower = methodName.lowercased()
        
        if lower == "approveactivity" || lower == "rejectactivity" {
            return .activityDecision
        }
        if lower.hasPrefix("noop") {
            return .noop
        }
        if lower.hasPrefix("proxy") {
            return .proxy
        }
        if lower.hasPrefix("tget") || lower.hasPrefix("tlist") || lower.hasPrefix("ttest") {
            return .query
        }
        return .command
    }
}

// MARK: - Type Generation

func generateSwiftType(name: String, def: SwaggerSpec.Definition) -> String {
    var output = ""
    
    // Generate enum for string enums
    if def.type == "string", let enumValues = def.enum {
        output += "public enum \(name): String, Codable, Sendable {\n"
        for value in enumValues {
            // Convert enum value to valid Swift case name
            let caseName = value
                .replacingOccurrences(of: "-", with: "_")
                .replacingOccurrences(of: ".", with: "_")
                .lowercased()
            output += "    case \(caseName) = \"\(value)\"\n"
        }
        output += "}\n"
        return output
    }
    
    // Generate struct for object types
    if def.type == "object", let properties = def.properties {
        output += "public struct \(name): Codable, Sendable {\n"
        
        let requiredProps = def.required ?? []
        var needsCodingKeys = false
        var codingKeys: [(swiftName: String, jsonName: String)] = []
        
        for (propName, schemaBox) in properties.sorted(by: { $0.key < $1.key }) {
            let schema = schemaBox.value
            let isRequired = requiredProps.contains(propName)
            var swiftType = "Any"
            
            if let ref = schema.ref {
                swiftType = refToSwift(ref)
            } else if let type = schema.type {
                swiftType = swaggerTypeToSwift(type, schema: schema)
            }
            
            // Add optionality if not required
            if !isRequired {
                swiftType += "?"
            }
            
            // Add description if available
            if let desc = schema.description {
                output += "    /// \(desc)\n"
            }
            
            // Handle property naming
            let (swiftPropName, needsKey) = sanitizePropertyName(propName)
            if needsKey {
                needsCodingKeys = true
            }
            // Always add to codingKeys array for completeness
            codingKeys.append((swiftName: swiftPropName, jsonName: propName))
            
            output += "    public let \(swiftPropName): \(swiftType)\n"
        }
        
        // Add memberwise initializer for all structs
        if !properties.isEmpty {
            output += "\n    public init(\n"
            let sortedProps = codingKeys.sorted(by: { $0.swiftName < $1.swiftName })
            for (index, key) in sortedProps.enumerated() {
                let schema = properties[key.jsonName]?.value
                var swiftType = "Any"
                
                if let ref = schema?.ref {
                    swiftType = refToSwift(ref)
                } else if let type = schema?.type {
                    swiftType = swaggerTypeToSwift(type, schema: schema!)
                }
                
                // Check if this property is required
                let isRequired = requiredProps.contains(key.jsonName)
                if !isRequired {
                    swiftType += "?"
                }
                
                let comma = index < sortedProps.count - 1 ? "," : ""
                // Add default nil only for optional parameters
                if !isRequired {
                    output += "        \(key.swiftName): \(swiftType) = nil\(comma)\n"
                } else {
                    output += "        \(key.swiftName): \(swiftType)\(comma)\n"
                }
            }
            output += "    ) {\n"
            for key in sortedProps {
                output += "        self.\(key.swiftName) = \(key.swiftName)\n"
            }
            output += "    }\n"
        }
        
        // Add CodingKeys if needed (must include ALL properties)
        if needsCodingKeys {
            output += "\n    private enum CodingKeys: String, CodingKey {\n"
            for key in codingKeys {
                output += "        case \(key.swiftName) = \"\(key.jsonName)\"\n"
            }
            output += "    }\n"
        }
        
        // Add additional properties support if specified
        if def.additionalProperties != nil {
            output += "\n    // Note: Additional properties supported\n"
        }
        
        output += "}\n"
        return output
    }
    
    // Default empty struct
    output += "public struct \(name): Codable, Sendable {\n"
    output += "    public init() {}\n"
    output += "}\n"
    return output
}

func sanitizePropertyName(_ name: String) -> (swiftName: String, needsCodingKey: Bool) {
    // Swift reserved keywords that need renaming
    let reservedKeywords: Set<String> = [
        "associatedtype", "class", "deinit", "enum", "extension",
        "func", "import", "init", "inout", "internal", "let",
        "operator", "private", "protocol", "public", "static",
        "struct", "subscript", "typealias", "var", "break",
        "case", "continue", "default", "defer", "do", "else",
        "fallthrough", "for", "guard", "if", "in", "repeat",
        "return", "switch", "where", "while", "as", "Any",
        "catch", "false", "is", "nil", "rethrows", "super",
        "throw", "throws", "true", "try", "Type"
    ]
    
    // If it's a reserved keyword, add underscore prefix
    if reservedKeywords.contains(name) {
        return ("_\(name)", true)
    }
    
    // Check if name has special characters that need sanitization
    if name.hasPrefix("@") || name.contains("@") || name.contains("-") || name.contains(".") {
        let sanitized = name
            .replacingOccurrences(of: "@", with: "at")
            .replacingOccurrences(of: "-", with: "_")
            .replacingOccurrences(of: ".", with: "_")
        return (sanitized, true)
    }
    
    // If already valid, no need for CodingKey
    if isValidIdentifier(name) {
        return (name, false)
    }
    
    // Fallback: sanitize any remaining special chars
    let sanitized = name.replacingOccurrences(of: "[^a-zA-Z0-9_]", with: "_", options: .regularExpression)
    return (sanitized, true)
}

func generateInlineProperties(
    def: SwaggerSpec.Definition?,
    definitions: [String: SwaggerSpec.Definition],
    isAllOptional: Bool = false,
    indent: String = "    "
) -> String {
    var output = ""
    
    guard let def = def, let properties = def.properties else {
        return output
    }
    
    let requiredProps = isAllOptional ? [] : (def.required ?? [])
    
    for (propName, schemaBox) in properties.sorted(by: { $0.key < $1.key }) {
        let schema = schemaBox.value
        let isRequired = requiredProps.contains(propName)
        var swiftType = "Any"
        
        if let ref = schema.ref {
            swiftType = refToSwift(ref)
        } else if let type = schema.type {
            swiftType = swaggerTypeToSwift(type, schema: schema)
        }
        
        // Add optionality if not required
        if !isRequired {
            swiftType += "?"
        }
        
        // Add description if available
        if let desc = schema.description {
            output += "\(indent)/// \(desc)\n"
        }
        
        let swiftPropName = sanitizePropertyName(propName).swiftName
        output += "\(indent)public let \(swiftPropName): \(swiftType)\n"
    }
    
    return output
}

func generateApiTypes(
    swagger: SwaggerSpec,
    prefix: String = ""
) -> String {
    var output = ""
    
    let namespace = swagger.tags?.first(where: { $0.name.contains("Service") })?.name ?? "PublicApiService"
    let latestVersions = extractLatestVersions(definitions: swagger.definitions)
    let definitions = swagger.definitions
    
    for (_, pathItem) in swagger.paths.sorted(by: { $0.key < $1.key }) {
        guard let operation = pathItem.post else { continue }
        let operationId = operation.operationId
        
        let operationNameWithoutNamespace = operationId.replacingOccurrences(
            of: "\(namespace)_",
            with: "\(prefix)T"
        )
        
        let methodName = lowerFirstLetter(operationNameWithoutNamespace)
        let methodType = MethodType.from(methodName: methodName)
        
        // Get response schema
        let responseSchema = operation.responses?["200"]?.schema
        let responseTypeName = responseSchema?.ref.map { refToSwift($0) }
        
        // Compose API type names
        let apiTypeName = upperFirstLetter(operationNameWithoutNamespace) + "Response"
        let apiBodyTypeName = upperFirstLetter(operationNameWithoutNamespace) + "Body"
        let apiInputTypeName = upperFirstLetter(operationNameWithoutNamespace) + "Input"
        
        // --- RESPONSE TYPE GENERATION ---
        output += "// MARK: - \(apiTypeName)\n\n"
        
        switch methodType {
        case .command:
            // Find the result type from the request
            var resultTypeName: String?
            var versionSuffix = ""
            
            if let parameters = operation.parameters {
                for param in parameters {
                    guard param.in == "body", let schemaRef = param.schema?.ref else { continue }
                    
                    let reqTypeName = refToSwift(schemaRef)
                    
                    if let reqDef = definitions[reqTypeName],
                       let typeProperty = reqDef.properties?["type"]?.value,
                       let typeEnum = typeProperty.enum,
                       let activityType = typeEnum.first {
                        
                        // Check for versioned activity type
                        if let mapped = VERSIONED_ACTIVITY_TYPES[activityType] {
                            if let versionMatch = mapped.range(of: "V\\d+$", options: .regularExpression) {
                                versionSuffix = String(mapped[versionMatch])
                            }
                        }
                        
                        // Find the result type
                        let baseActivity = reqTypeName
                            .replacingOccurrences(of: "^v\\d+", with: "", options: .regularExpression)
                            .replacingOccurrences(of: "Request(V\\d+)?$", with: "", options: .regularExpression)
                        
                        let resultBase = baseActivity + "Result"
                        
                        if let versionInfo = latestVersions[resultBase] {
                            if !versionSuffix.isEmpty {
                                // Try to find specific version
                                let candidate = definitions.keys.first {
                                    $0.hasPrefix("v1" + baseActivity + "Result") && $0.hasSuffix(versionSuffix)
                                }
                                resultTypeName = candidate ?? versionInfo.fullName
                            } else {
                                resultTypeName = versionInfo.fullName
                            }
                        }
                    }
                }
            }
            
            output += "public struct \(apiTypeName): Codable, Sendable {\n"
            output += "    public let activity: v1Activity\n"
            
            if let resultTypeName = resultTypeName,
               let resultDef = definitions[resultTypeName] {
                output += generateInlineProperties(
                    def: resultDef,
                    definitions: definitions,
                    indent: "    "
                )
            }
            
            output += "}\n\n"
            
        case .query, .noop, .proxy:
            if let responseTypeName = responseTypeName,
               let respDef = definitions[responseTypeName] {
                output += "public struct \(apiTypeName): Codable, Sendable {\n"
                output += generateInlineProperties(
                    def: respDef,
                    definitions: definitions,
                    indent: "    "
                )
                output += "}\n\n"
            } else {
                output += "public struct \(apiTypeName): Codable, Sendable {\n"
                output += "    public init() {}\n"
                output += "}\n\n"
            }
            
        case .activityDecision:
            if let responseTypeName = responseTypeName,
               let activityDef = definitions[responseTypeName] {
                output += "public struct \(apiTypeName): Codable, Sendable {\n"
                output += generateInlineProperties(
                    def: activityDef,
                    definitions: definitions,
                    indent: "    "
                )
                output += "}\n\n"
            }
        }
        
        // --- REQUEST TYPE GENERATION ---
        output += "// MARK: - \(apiBodyTypeName)\n\n"
        
        var requestTypeDef: SwaggerSpec.Definition?
        var requestTypeName: String?
        
        if let parameters = operation.parameters {
            for param in parameters {
                guard param.in == "body", let schemaRef = param.schema?.ref else { continue }
                
                requestTypeName = refToSwift(schemaRef)
                requestTypeDef = definitions[requestTypeName!]
            }
        }
        
        guard let requestDef = requestTypeDef else {
            output += "public struct \(apiBodyTypeName): Codable, Sendable {\n"
            output += "    public init() {}\n"
            output += "}\n\n"
            continue
        }
        
        output += "public struct \(apiBodyTypeName): Codable, Sendable {\n"
        
        switch methodType {
        case .command, .activityDecision:
            output += "    public let timestampMs: String?\n"
            output += "    public let organizationId: String?\n"
            
            if let paramsRef = requestDef.properties?["parameters"]?.value.ref {
                let isAllOptional = METHODS_WITH_ONLY_OPTIONAL_PARAMETERS.contains(methodName)
                let intentTypeName = refToSwift(paramsRef)
                if let intentDef = definitions[intentTypeName] {
                    output += generateInlineProperties(
                        def: intentDef,
                        definitions: definitions,
                        isAllOptional: isAllOptional,
                        indent: "    "
                    )
                }
            }
            
        case .query, .noop:
            output += "    public let organizationId: String?\n"
            
            if let properties = requestDef.properties {
                let isAllOptional = METHODS_WITH_ONLY_OPTIONAL_PARAMETERS.contains(methodName)
                let requiredProps = isAllOptional ? [] : (requestDef.required ?? [])
                
                for (propName, schemaBox) in properties.sorted(by: { $0.key < $1.key }) where propName != "organizationId" {
                    let schema = schemaBox.value
                    let isRequired = requiredProps.contains(propName)
                    var swiftType = "Any"
                    
                    if let ref = schema.ref {
                        swiftType = refToSwift(ref)
                    } else if let type = schema.type {
                        swiftType = swaggerTypeToSwift(type, schema: schema)
                    }
                    
                    if !isRequired {
                        swiftType += "?"
                    }
                    
                    if let desc = schema.description {
                        output += "    /// \(desc)\n"
                    }
                    
                    let swiftPropName = sanitizePropertyName(propName).swiftName
                    output += "    public let \(swiftPropName): \(swiftType)\n"
                }
            }
            
        case .proxy:
            if let properties = requestDef.properties {
                let isAllOptional = METHODS_WITH_ONLY_OPTIONAL_PARAMETERS.contains(methodName)
                let requiredProps = isAllOptional ? [] : (requestDef.required ?? [])
                
                for (propName, schemaBox) in properties.sorted(by: { $0.key < $1.key }) {
                    let schema = schemaBox.value
                    let isRequired = requiredProps.contains(propName)
                    var swiftType = "Any"
                    
                    if let ref = schema.ref {
                        swiftType = refToSwift(ref)
                    } else if let type = schema.type {
                        swiftType = swaggerTypeToSwift(type, schema: schema)
                    }
                    
                    if !isRequired {
                        swiftType += "?"
                    }
                    
                    if let desc = schema.description {
                        output += "    /// \(desc)\n"
                    }
                    
                    let swiftPropName = sanitizePropertyName(propName).swiftName
                    output += "    public let \(swiftPropName): \(swiftType)\n"
                }
            }
        }
        
        // Always generate memberwise initializer for API Body types
        // Collect all properties that were just added
        var propertyNames: [String] = []
        var propertyTypes: [String: (type: String, isOptional: Bool)] = [:]
        
        switch methodType {
        case .command, .activityDecision:
            propertyNames.append("timestampMs")
            propertyTypes["timestampMs"] = ("String", true)
            propertyNames.append("organizationId")
            propertyTypes["organizationId"] = ("String", true)
            
            if let paramsRef = requestDef.properties?["parameters"]?.value.ref {
                let isAllOptional = METHODS_WITH_ONLY_OPTIONAL_PARAMETERS.contains(methodName)
                let intentTypeName = refToSwift(paramsRef)
                if let intentDef = definitions[intentTypeName],
                   let properties = intentDef.properties {
                    let requiredProps = isAllOptional ? [] : (intentDef.required ?? [])
                    for (propName, schemaBox) in properties.sorted(by: { $0.key < $1.key }) {
                        let schema = schemaBox.value
                        let isRequired = requiredProps.contains(propName)
                        var swiftType = "Any"
                        if let ref = schema.ref {
                            swiftType = refToSwift(ref)
                        } else if let type = schema.type {
                            swiftType = swaggerTypeToSwift(type, schema: schema)
                        }
                        let swiftPropName = sanitizePropertyName(propName).swiftName
                        if !propertyNames.contains(swiftPropName) {
                            propertyNames.append(swiftPropName)
                            propertyTypes[swiftPropName] = (swiftType, !isRequired)
                        }
                    }
                }
            }
            
        case .query, .noop:
            propertyNames.append("organizationId")
            propertyTypes["organizationId"] = ("String", true)
            
            if let properties = requestDef.properties {
                let isAllOptional = METHODS_WITH_ONLY_OPTIONAL_PARAMETERS.contains(methodName)
                let requiredProps = isAllOptional ? [] : (requestDef.required ?? [])
                for (propName, schemaBox) in properties.sorted(by: { $0.key < $1.key }) where propName != "organizationId" {
                    let schema = schemaBox.value
                    let isRequired = requiredProps.contains(propName)
                    var swiftType = "Any"
                    if let ref = schema.ref {
                        swiftType = refToSwift(ref)
                    } else if let type = schema.type {
                        swiftType = swaggerTypeToSwift(type, schema: schema)
                    }
                    let swiftPropName = sanitizePropertyName(propName).swiftName
                    if !propertyNames.contains(swiftPropName) {
                        propertyNames.append(swiftPropName)
                        propertyTypes[swiftPropName] = (swiftType, !isRequired)
                    }
                }
            }
            
        case .proxy:
            if let properties = requestDef.properties {
                let isAllOptional = METHODS_WITH_ONLY_OPTIONAL_PARAMETERS.contains(methodName)
                let requiredProps = isAllOptional ? [] : (requestDef.required ?? [])
                for (propName, schemaBox) in properties.sorted(by: { $0.key < $1.key }) {
                    let schema = schemaBox.value
                    let isRequired = requiredProps.contains(propName)
                    var swiftType = "Any"
                    if let ref = schema.ref {
                        swiftType = refToSwift(ref)
                    } else if let type = schema.type {
                        swiftType = swaggerTypeToSwift(type, schema: schema)
                    }
                    let swiftPropName = sanitizePropertyName(propName).swiftName
                    if !propertyNames.contains(swiftPropName) {
                        propertyNames.append(swiftPropName)
                        propertyTypes[swiftPropName] = (swiftType, !isRequired)
                    }
                }
            }
        }
        
        // Generate memberwise init
        if !propertyNames.isEmpty {
            output += "\n    public init(\n"
            for (index, propName) in propertyNames.enumerated() {
                let (propType, isOptional) = propertyTypes[propName] ?? ("Any", true)
                let comma = index < propertyNames.count - 1 ? "," : ""
                if isOptional {
                    output += "        \(propName): \(propType)? = nil\(comma)\n"
                } else {
                    output += "        \(propName): \(propType)\(comma)\n"
                }
            }
            output += "    ) {\n"
            for propName in propertyNames {
                output += "        self.\(propName) = \(propName)\n"
            }
            output += "    }\n"
        } else {
            // Empty struct - add default init
            output += "\n    public init() {}\n"
        }
        
        output += "}\n\n"
        
        // --- INPUT TYPE GENERATION ---
        output += "// MARK: - \(apiInputTypeName)\n\n"
        output += "public struct \(apiInputTypeName): Codable, Sendable {\n"
        output += "    public let body: \(apiBodyTypeName)\n"
        output += "\n    public init(\n"
        output += "        body: \(apiBodyTypeName)\n"
        output += "    ) {\n"
        output += "        self.body = body\n"
        output += "    }\n"
        output += "}\n\n"
    }
    
    return output
}

// MARK: - Main

func main() throws {
    print("ðŸš€ Starting Type Generation for Swift...")
    
    // Parse Swagger specs
    print("ðŸ“– Reading Swagger specifications...")
    
    let publicData = try Data(contentsOf: PUBLIC_API_SWAGGER_PATH)
    let authProxyData = try Data(contentsOf: AUTH_PROXY_SWAGGER_PATH)
    
    let decoder = JSONDecoder()
    let publicSpec = try decoder.decode(SwaggerSpec.self, from: publicData)
    let authProxySpec = try decoder.decode(SwaggerSpec.self, from: authProxyData)
    
    print("âœ… Parsed Swagger specifications")
    print("   - Public API: \(publicSpec.paths.count) endpoints, \(publicSpec.definitions.count) definitions")
    print("   - Auth Proxy: \(authProxySpec.paths.count) endpoints, \(authProxySpec.definitions.count) definitions")
    
    // Generate types
    print("\nðŸ”¨ Generating Swift types...")
    
    var output = COMMENT_HEADER + "\n\n"
    output += "import Foundation\n\n"
    
    // --- Base Types ---
    output += "// MARK: - Base Types from Swagger Definitions\n\n"
    
    for (defName, def) in publicSpec.definitions.sorted(by: { $0.key < $1.key }) {
        output += generateSwiftType(name: defName, def: def) + "\n"
    }
    
    // --- API Types ---
    output += "\n// MARK: - API Types from Swagger Paths\n\n"
    
    output += generateApiTypes(swagger: publicSpec)
    output += generateApiTypes(swagger: authProxySpec, prefix: "Proxy")
    
    // Write to file
    try output.write(to: OUTPUT_PATH, atomically: true, encoding: .utf8)
    
    print("âœ… Generated types at: \(OUTPUT_PATH.path)")
    print("\nâœ¨ Type generation complete!")
}

// Run
do {
    try main()
} catch {
    print("âŒ Error: \(error)")
    exit(1)
}