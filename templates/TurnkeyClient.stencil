import Middleware
import AuthenticationServices
import CryptoKit
import Foundation
import OpenAPIRuntime
import OpenAPIURLSession
import Shared

public struct TurnkeyClient {
  public static let baseURLString = "https://api.turnkey.com"

  private let underlyingClient: any APIProtocol

  internal init(underlyingClient: any APIProtocol) {
    self.underlyingClient = underlyingClient
  }
  
  /// Initializes a `TurnkeyClient` with a proxy server URL.
  ///
  /// This initializer configures the `TurnkeyClient` to route all requests through a specified proxy server.
  /// The proxy server is responsible for forwarding these requests to a backend capable of authenticating them using an API private key.
  /// This setup is particularly useful during onboarding flows, such as email authentication and creating new sub-organizations,
  /// where direct authenticated requests are not feasible.
  ///
  /// - Parameter proxyURL: The URL of the proxy server that will forward requests to the authenticating backend.
  ///
  /// - Note: The `TurnkeyClient` initialized with this method does not directly send authenticated requests. Instead, it relies on the proxy server to handle the authentication.
  public init(proxyURL: String) {
    self.init(
      underlyingClient: Client(
        serverURL: URL(string: "https://api.turnkey.com")!,
        transport: URLSessionTransport(),
        middlewares: [ProxyMiddleware(proxyURL: URL(string: proxyURL)!)]
      )
    )
  }

  {# TODO: Add this function in the future to initialize a TurnkeyClient instance 
    that uses the stored private key and public key to authenticate the user.

  public init(useDeviceCredentials: bool = false) {
    let stamper = Stamper(useDeviceCredentials: useDeviceCredentials)
    self.init(underlyingClient: Client(serverURL: URL(string: "https://api.turnkey.com")!, transport: URLSessionTransport(), middlewares: []), passkeyManager: nil)
  }
  #}
  /// Initializes a `TurnkeyClient` with API keys for authentication.
  ///
  /// This initializer creates an instance of `TurnkeyClient` using the provided `apiPrivateKey` and `apiPublicKey`.
  /// These keys are typically obtained through the Turnkey CLI or your account dashboard. The client uses these keys
  /// to authenticate requests via a `Stamper` which stamps each request with the key pair.
  ///
  /// - Parameters:
  ///   - apiPrivateKey: The private key obtained from Turnkey, used for signing requests.
  ///   - apiPublicKey: The public key obtained from Turnkey, used to identify the client.
  ///   - baseUrl: The base URL of the Turnkey API. Defaults to "https://api.turnkey.com".
  ///
  /// - Example:
  ///   ```
  ///   let client = TurnkeyClient(apiPrivateKey: "your_api_private_key", apiPublicKey: "your_api_public_key")
  ///   ```
  public init(apiPrivateKey: String, apiPublicKey: String, baseUrl: String = "https://api.turnkey.com") {
    let stamper = Stamper(apiPublicKey: apiPublicKey, apiPrivateKey: apiPrivateKey)
    self.init(
      underlyingClient: Client(
        serverURL: URL(string: baseUrl)!,
        transport: URLSessionTransport(),
        middlewares: [AuthStampMiddleware(stamper: stamper)]
      )
    )
  }

  /// Initializes a `TurnkeyClient` using on-device session credentials.
  ///
  /// This initializer creates a default Stamper that uses SessionManager.shared for on-device signing via the Secure Enclave,
  /// and configures the client to sign requests using the generated stamp header.
  public init() {
    let stamper = Stamper()
    self.init(
      underlyingClient: Client(
        serverURL: URL(string: TurnkeyClient.baseURLString)!,
        transport: URLSessionTransport(),
        middlewares: [AuthStampMiddleware(stamper: stamper)]
      )
    )
  }

  /// Creates an instance of the TurnkeyClient that uses passkeys for authentication.
  ///
  /// This initializer sets up the TurnkeyClient with a specific `rpId` (Relying Party Identifier) and `presentationAnchor`.
  ///
  /// - Important:
  ///   You need to have an associated domain with the `webcredentials` service type when making a registration or assertion request;
  ///   otherwise, the request returns an error. For more information, see [Supporting Associated Domains](https://developer.apple.com/documentation/xcode/supporting-associated-domains).
  ///
  /// - Parameters:
  ///   - rpId: The relying party identifier used for passkey authentication.
  ///   - presentationAnchor: The presentation anchor used for displaying authentication interfaces.
  ///   - baseUrl: The base URL of the Turnkey API. Defaults to "https://api.turnkey.com".
  ///
  /// - Example:
  ///   ```
  ///   let presentationAnchor = ASPresentationAnchor()
  ///   let client = TurnkeyClient(rpId: "com.example.domain", presentationAnchor: presentationAnchor)
  ///   ```
  public init(rpId: String, presentationAnchor: ASPresentationAnchor, baseUrl: String = "https://api.turnkey.com") {
    let stamper = Stamper(rpId: rpId, presentationAnchor: presentationAnchor)
    self.init(
      underlyingClient: Client(
        serverURL: URL(string: baseUrl)!,
        transport: URLSessionTransport(),
        middlewares: [AuthStampMiddleware(stamper: stamper)]
      )
    )
  }

  public struct AuthResult {
    var whoamiResponse: Operations.GetWhoami.Output
    var apiPublicKey: String
    var apiPrivateKey: String
  }

  /// Performs email-based authentication for an organization.
  ///
  /// This method initiates an email authentication process by generating an ephemeral private key and using its public counterpart
  /// to authenticate the email. It returns a tuple containing the authentication response and a closure to verify the encrypted bundle.
  ///
  /// - Parameters:
  ///   - organizationId: The identifier of the organization initiating the authentication.
  ///   - email: The email address to authenticate.
  ///   - apiKeyName: Optional. The name of the API key used in the authentication process.
  ///   - expirationSeconds: Optional. The duration in seconds before the authentication request expires.
  ///   - emailCustomization: Optional. Customization parameters for the authentication email.
  ///   - invalidateExisting: Optional. Invalidates all existing email auth API keys.
  ///
  /// - Returns: A tuple containing the `Operations.EmailAuth.Output` and a closure `(String) async throws -> Void` that accepts an encrypted bundle for verification.
  ///
  /// - Throws: An error if the authentication process fails.
  ///
  /// - Note: The method internally handles the generation of ephemeral keys and requires proper error handling when calling the returned closure for bundle verification.
  public func emailAuth(
    organizationId: String,
    email: String, apiKeyName: String?, expirationSeconds: String?,
    emailCustomization: Components.Schemas.EmailCustomizationParams?, invalidateExisting: Bool?
) async throws -> (Operations.EmailAuth.Output, (String) async throws -> AuthResult) {
    let (ephemeralPrivateKey, targetPublicKey) = try AuthHelpers.generateEphemeralKeyAgreement()

    let response = try await emailAuth(
        organizationId: organizationId, email: email, targetPublicKey: targetPublicKey,
        apiKeyName: apiKeyName, expirationSeconds: expirationSeconds,
        emailCustomization: emailCustomization, invalidateExisting: invalidateExisting)
    
    let authResponseOrganizationId = try response.ok.body.json.activity.organizationId

    let verify: (String) async throws -> AuthResult = { encryptedBundle in
        let (privateKey: privateKey, publicKey: publicKey) = try TurnkeyCrypto.decryptCredentialBundle(
            encryptedBundle: encryptedBundle, ephemeralPrivateKey: ephemeralPrivateKey)

        let apiPublicKey = try publicKey.toString(representation: PublicKeyRepresentation.compressed)
        let apiPrivateKey = try privateKey.toString(representation: PrivateKeyRepresentation.raw)

        let turnkeyClient = TurnkeyClient(apiPrivateKey: apiPrivateKey, apiPublicKey: apiPublicKey)

        let whoamiResponse = try await turnkeyClient.getWhoami(
            organizationId: authResponseOrganizationId)

        let result = AuthResult(whoamiResponse: whoamiResponse, apiPublicKey: apiPublicKey, apiPrivateKey: apiPrivateKey)
        return result
    }

    return (response, verify)
}

  /// Asynchronously logs in using on-device credentials and configures the client to sign requests using the generated stamp header.
  /// - Parameters:
  ///   - userId: The identifier for the user.
  ///   - organizationId: The organization (or sub-organization) ID.
  ///   - targetEmbeddedKey: Optionally, the embedded key to be used. If nil, it will be derived from the Secure Enclave public key.
  ///   - expirationSeconds: The expiration period for the session/API key in seconds.
  /// - Returns: An authenticated TurnkeyClient instance where subsequent requests will be signed using the device's Secure Enclave keys.
  /// - Example:
  /// ```swift
  /// Task {
  ///    do {
  ///       let presentationAnchor = ASPresentationAnchor()
  ///       let client = TurnkeyClient(rpId: "com.example.domain", presentationAnchor: presentationAnchor)
  ///       let loggedInClient = try await client.login(userId: "user123", organizationId: "org456")
  ///       // Now you can use loggedInClient to make API calls
  ///       let whoami = try await loggedInClient.getWhoami(organizationId: "org456")
  ///       print("Logged in as: \(whoami.username)")
  ///    } catch {
  ///       print("Login failed: \(error)")
  ///    }
  /// }
  /// ```
  public func login(userId: String? = nil, organizationId: String? = nil, expirationSeconds: Int = 3600) async throws -> TurnkeyClient {
    // Check if a valid session exists
    if let session = SessionManager.shared.loadActiveSession(), session.expiresAt > Date() {
      // Session exists; return new TurnkeyClient instance with session-based stamper
      return TurnkeyClient()
    }

    // No valid unexpired session. Attempt to fetch stored (possibly expired) session
    let storedSession = SessionManager.shared.loadSessionIgnoringExpiration()

    // Determine organizationId for session creation from parameters or stored session
    guard let orgIdForSession = organizationId ?? storedSession?.organizationId else {
      throw NSError(domain: "TurnkeyClient", code: 1, userInfo: [NSLocalizedDescriptionKey: "organizationId is required when no previous session exists"])
    }

    // Generate ephemeral keypair and call createReadWriteSession
    let (ephemeralPrivateKey, targetPublicKey) = try AuthHelpers.generateEphemeralKeyAgreement()
    let sessionResponse = try await self.createReadWriteSession(
      organizationId: orgIdForSession,
      targetPublicKey: targetPublicKey,
      userId: userId,
      apiKeyName: "session-key",
      expirationSeconds: String(expirationSeconds)
    )
    let responseBody = try sessionResponse.ok.body.json
    guard let result = responseBody.activity.result.createReadWriteSessionResultV2 else {
      throw NSError(
        domain: "TurnkeyClient",
        code: 1,
        userInfo: [NSLocalizedDescriptionKey: "Missing createReadWriteSessionResultV2"]
      )
    }
    let organizationId = result.organizationId
    let userId = result.userId

    let (decryptedPrivateKey, decryptedPublicKey) = try TurnkeyCrypto.decryptCredentialBundle(
      encryptedBundle: result.credentialBundle,
      ephemeralPrivateKey: ephemeralPrivateKey
    )
    let tempApiPublicKey = try decryptedPublicKey.toString(representation: PublicKeyRepresentation.compressed)
    let tempApiPrivateKey = try decryptedPrivateKey.toString(representation: PrivateKeyRepresentation.raw)

    // Instantiate temporary TurnkeyClient using decrypted keys
    let tempClient = TurnkeyClient(apiPrivateKey: tempApiPrivateKey, apiPublicKey: tempApiPublicKey)

    // Generate Secure Enclave key pair (new session key)
    let enclaveKeyManager = SecureEnclaveKeyManager()
    let keyTag = try enclaveKeyManager.createKeypair()
    let enclavePublicKeyData = try enclaveKeyManager.publicKey(tag: keyTag)
    let enclavePublicKeyHex = enclavePublicKeyData.toHexString()

    // Create permanent API key via temporary client
    let apiKeyParams = [Components.Schemas.ApiKeyParamsV2(
      apiKeyName: "Session Key \(Int(Date().timeIntervalSince1970))",
      publicKey: enclavePublicKeyHex,
      curveType: .API_KEY_CURVE_P256,
      expirationSeconds: String(expirationSeconds)
    )]
    
    let _ = try await tempClient.createApiKeys(
      organizationId: organizationId,
      apiKeys: apiKeyParams,
      userId: userId
    )

    // Derive session expiration and persist session
    let sessionExpiry = Date().addingTimeInterval(TimeInterval(expirationSeconds))
    let newSession = Session(keyTag: keyTag, expiresAt: sessionExpiry, userId: userId, organizationId: organizationId)
    try SessionManager.shared.save(session: newSession)

    // Return new TurnkeyClient instance with session-based stamper
    return TurnkeyClient()
  }

  {% import "macros.stencil" %}
  {% for class in types.implementing.APIProtocol %}
      {% for method in class.instanceMethods %}
          {% set bodyInput method.parameters.0.typeName %}
          {% set returnType method.returnType.name %}
          {# Generates the name of the request struct by concating the method name with "Request"
              Example:
                  method.callName = "ApproveActivity"
                  requestStructName = "ApproveActivityRequest"
           #}   
          {% set requestStructName %}{{method.callName}}Request{% endset %}
          {% set output %}Operations.{{method.callName}}.Output.Ok.Body{% endset %}
          {# Determines if this is activityRequest vs a read request by looking at the output body type 
             If the enum contains "ActivityResponse" then we know it is an ActivityRequest
          #}
          {% set isActivityRequest %}
          {% for struct in types.structs where struct.name|hasSuffix:requestStructName and struct.methods.0.parameters.0.name == "_type" -%}true{%- endfor %}
          {% endset %}
          
          {% if isActivityRequest|contains:"true" -%} 
              {% call generateActivityMethod method.callName -%}
          {% else -%}

      public func {{ method.callName|lowerFirstLetter }}({% call addMethodParams method.callName %}) async throws -> {{ returnType }} {

          // Create the {{ requestStructName }}
          let {{ method.callName|lowerFirstLetter }}Request = Components.Schemas.{{ requestStructName }}(
              {% for struct in types.structs where struct.name|hasSuffix:requestStructName -%}
                  {% for var in struct.variables -%}
                      {{ var.name }}: {{ var.name }}{% if not forloop.last %}, {% endif %}
                  {%- endfor %}
              {%- endfor %}
          )

          let input = {{ bodyInput }}(
              headers: .init(accept: [.init(contentType: .json)]),
              body: .json({{ requestStructName|lowerFirstLetter }})
          )
          return try await underlyingClient.{{method.callName}}(input)
      }
          {% endif -%}
      {% endfor %}
  {% endfor %}
      
}
