'use strict';

var bs58check = require('bs58check');
var bs58 = require('bs58');
var encoding = require('@turnkey/encoding');
var constants = require('./constants.js');
var crypto = require('./crypto.js');
var p256 = require('@noble/curves/p256');
var ed25519 = require('@noble/curves/ed25519');
var sha256 = require('@noble/hashes/sha256');

/// <reference lib="dom" />
// Turnkey-specific cryptographic utilities
/**
 * Decrypt an encrypted email auth/recovery or oauth credential bundle.
 *
 * @param {string} credentialBundle - The encrypted credential bundle.
 * @param {string} embeddedKey - The private key for decryption.
 * @returns {string} - The decrypted data or null if decryption fails.
 * @throws {Error} - If unable to decrypt the credential bundle
 */
const decryptCredentialBundle = (credentialBundle, embeddedKey) => {
    try {
        const bundleBytes = bs58check.decode(credentialBundle);
        if (bundleBytes.byteLength <= 33) {
            throw new Error(`Bundle size ${bundleBytes.byteLength} is too low. Expecting a compressed public key (33 bytes) and an encrypted credential.`);
        }
        const compressedEncappedKeyBuf = bundleBytes.slice(0, 33);
        const ciphertextBuf = bundleBytes.slice(33);
        const encappedKeyBuf = crypto.uncompressRawPublicKey(compressedEncappedKeyBuf);
        const decryptedData = crypto.hpkeDecrypt({
            ciphertextBuf,
            encappedKeyBuf,
            receiverPriv: embeddedKey,
        });
        return encoding.uint8ArrayToHexString(decryptedData);
    }
    catch (error) {
        throw new Error(`"Error decrypting bundle:", ${error}`);
    }
};
/**
 * Decrypt an encrypted export bundle (such as a private key or wallet account bundle).
 *
 * This function verifies the enclave signature to ensure the authenticity of the encrypted data.
 * It uses HPKE (Hybrid Public Key Encryption) to decrypt the contents of the bundle and returns
 * either the decrypted mnemonic or the decrypted data in hexadecimal format, based on the
 * `returnMnemonic` flag.
 *
 * @param {DecryptExportBundleParams} params - An object containing the following properties:
 *   - exportBundle {string}: The encrypted export bundle in JSON format.
 *   - organizationId {string}: The expected organization ID to verify against the signed data.
 *   - embeddedKey {string}: The private key used for decrypting the data.
 *   - dangerouslyOverrideSignerPublicKey {string} [Optional]: Optionally override the default signer public key used for verifying the signature. This should only be done for testing
 *   - returnMnemonic {boolean}: If true, returns the decrypted data as a mnemonic string; otherwise, returns it in hexadecimal format.
 * @returns {Promise<string>} - A promise that resolves to the decrypted mnemonic or decrypted hexadecimal data.
 * @throws {Error} - If decryption or signature verification fails, throws an error with details.
 */
const decryptExportBundle = async ({ exportBundle, embeddedKey, organizationId, dangerouslyOverrideSignerPublicKey, keyFormat, returnMnemonic, }) => {
    try {
        const parsedExportBundle = JSON.parse(exportBundle);
        const verified = await verifyEnclaveSignature(parsedExportBundle.enclaveQuorumPublic, parsedExportBundle.dataSignature, parsedExportBundle.data, dangerouslyOverrideSignerPublicKey);
        if (!verified) {
            throw new Error(`failed to verify enclave signature: ${parsedExportBundle}`);
        }
        const signedData = JSON.parse(new TextDecoder().decode(encoding.uint8ArrayFromHexString(parsedExportBundle.data)));
        if (!signedData.organizationId ||
            signedData.organizationId !== organizationId) {
            throw new Error(`organization id does not match expected value. Expected: ${organizationId}. Found: ${signedData.organizationId}.`);
        }
        if (!signedData.encappedPublic) {
            throw new Error('missing "encappedPublic" in bundle signed data');
        }
        const encappedKeyBuf = encoding.uint8ArrayFromHexString(signedData.encappedPublic);
        const ciphertextBuf = encoding.uint8ArrayFromHexString(signedData.ciphertext);
        const decryptedData = crypto.hpkeDecrypt({
            ciphertextBuf,
            encappedKeyBuf,
            receiverPriv: embeddedKey,
        });
        if (keyFormat === "SOLANA" && !returnMnemonic) {
            if (decryptedData.length !== 32) {
                throw new Error(`invalid private key length. Expected 32 bytes. Got ${decryptedData.length}.`);
            }
            const publicKeyBytes = ed25519.ed25519.getPublicKey(decryptedData);
            if (publicKeyBytes.length !== 32) {
                throw new Error(`invalid public key length. Expected 32 bytes. Got ${publicKeyBytes.length}.`);
            }
            const concatenatedBytes = new Uint8Array(64);
            concatenatedBytes.set(decryptedData, 0);
            concatenatedBytes.set(publicKeyBytes, 32);
            return bs58.encode(concatenatedBytes);
        }
        const decryptedDataHex = encoding.uint8ArrayToHexString(decryptedData);
        return returnMnemonic ? encoding.hexToAscii(decryptedDataHex) : decryptedDataHex;
    }
    catch (error) {
        throw new Error(`Error decrypting bundle: ${error}`);
    }
};
/**
 * Verifies a signature from a Turnkey stamp using ECDSA and SHA-256.
 *
 * @param {string} publicKey - The public key of the authenticator (e.g. WebAuthn or P256 API key).
 * @param {string} signature - The ECDSA signature in DER format.
 * @param {string} signedData - The data that was signed (e.g. JSON-stringified Turnkey request body).
 * @returns {Promise<boolean>} - Returns true if the signature is valid, otherwise throws an error.
 *
 * @example
 *
 * const stampedRequest = await turnkeyClient.stampGetWhoami(...);
 * const decodedStampContents = atob(stampedRequest.stamp.stampHeaderValue);
 * const parsedStampContents = JSON.parse(decodedStampContents);
 * const signature = parsedStampContents.signature;
 *
 * await verifyStampSignature(publicKey, signature, stampedRequest.body)
 */
const verifyStampSignature = async (publicKey, signature, signedData) => {
    const publicKeyBuffer = encoding.uint8ArrayFromHexString(publicKey);
    const loadedPublicKey = loadPublicKey(publicKeyBuffer);
    if (!loadedPublicKey) {
        throw new Error("failed to load public key");
    }
    // Convert the ASN.1 DER-encoded signature for verification
    const publicSignatureBuf = crypto.fromDerSignature(signature);
    const signedDataBuf = new TextEncoder().encode(signedData);
    const hashedData = sha256.sha256(signedDataBuf);
    return p256.p256.verify(publicSignatureBuf, hashedData, loadedPublicKey.toHex());
};
/**
 * Verifies a signature from a Turnkey enclave using ECDSA and SHA-256.
 *
 * @param {string} enclaveQuorumPublic - The public key of the enclave signer.
 * @param {string} publicSignature - The ECDSA signature in DER format.
 * @param {string} signedData - The data that was signed.
 * @param {Environment} dangerouslyOverrideSignerPublicKey - (optional) an enum (PROD or PREPROD) to verify against the correct signer enclave key.
 * @returns {Promise<boolean>} - Returns true if the signature is valid, otherwise throws an error.
 */
const verifyEnclaveSignature = async (enclaveQuorumPublic, publicSignature, signedData, dangerouslyOverrideSignerPublicKey) => {
    const expectedSignerPublicKey = dangerouslyOverrideSignerPublicKey || constants.PRODUCTION_SIGNER_PUBLIC_KEY;
    if (enclaveQuorumPublic != expectedSignerPublicKey) {
        throw new Error(`expected signer key ${dangerouslyOverrideSignerPublicKey ?? constants.PRODUCTION_SIGNER_PUBLIC_KEY} does not match signer key from bundle: ${enclaveQuorumPublic}`);
    }
    const encryptionQuorumPublicBuf = new Uint8Array(encoding.uint8ArrayFromHexString(enclaveQuorumPublic));
    const quorumKey = loadPublicKey(encryptionQuorumPublicBuf);
    if (!quorumKey) {
        throw new Error("failed to load quorum key");
    }
    // Convert the ASN.1 DER-encoded signature for verification
    const publicSignatureBuf = crypto.fromDerSignature(publicSignature);
    const signedDataBuf = encoding.uint8ArrayFromHexString(signedData);
    const hashedData = sha256.sha256(signedDataBuf);
    return p256.p256.verify(publicSignatureBuf, hashedData, quorumKey.toHex());
};
/**
 * Loads an ECDSA public key from a raw format for signature verification.
 *
 * @param {Uint8Array} publicKey - The raw P-256 public key bytes.
 * @returns {ProjPointType<bigint>} - The parsed ECDSA public key.
 * @throws {Error} - If the public key is invalid.
 */
const loadPublicKey = (publicKey) => {
    return p256.p256.ProjectivePoint.fromHex(encoding.uint8ArrayToHexString(publicKey));
};
/**
 * Decodes a private key based on the specified format.
 *
 * @param {string} privateKey - The private key to decode.
 * @param {string} keyFormat - The format of the private key (e.g., "SOLANA", "HEXADECIMAL").
 * @returns {Uint8Array} - The decoded private key.
 */
const decodeKey = (privateKey, keyFormat) => {
    switch (keyFormat) {
        case "SOLANA":
            const decodedKeyBytes = bs58.decode(privateKey);
            if (decodedKeyBytes.length !== 64) {
                throw new Error(`invalid key length. Expected 64 bytes. Got ${decodedKeyBytes.length}.`);
            }
            return decodedKeyBytes.subarray(0, 32);
        case "HEXADECIMAL":
            if (privateKey.startsWith("0x")) {
                return encoding.uint8ArrayFromHexString(privateKey.slice(2));
            }
            return encoding.uint8ArrayFromHexString(privateKey);
        default:
            console.warn(`invalid key format: ${keyFormat}. Defaulting to HEXADECIMAL.`);
            if (privateKey.startsWith("0x")) {
                return encoding.uint8ArrayFromHexString(privateKey.slice(2));
            }
            return encoding.uint8ArrayFromHexString(privateKey);
    }
};
/**
 * Encrypts a private key bundle using HPKE and verifies the enclave signature.
 *
 * @param {EncryptPrivateKeyToBundleParams} params - An object containing the private key, key format, bundle, user, and organization details. Optionally, you can override the default signer key (for testing purposes)
 * @returns {Promise<string>} - A promise that resolves to a JSON string representing the encrypted bundle.
 * @throws {Error} - If enclave signature verification or any other validation fails.
 */
const encryptPrivateKeyToBundle = async ({ privateKey, keyFormat, importBundle, userId, organizationId, dangerouslyOverrideSignerPublicKey, }) => {
    const parsedImportBundle = JSON.parse(importBundle);
    const plainTextBuf = decodeKey(privateKey, keyFormat);
    const verified = await verifyEnclaveSignature(parsedImportBundle.enclaveQuorumPublic, parsedImportBundle.dataSignature, parsedImportBundle.data, dangerouslyOverrideSignerPublicKey);
    if (!verified) {
        throw new Error(`failed to verify enclave signature: ${importBundle}`);
    }
    const signedData = JSON.parse(new TextDecoder().decode(encoding.uint8ArrayFromHexString(parsedImportBundle.data)));
    if (!signedData.organizationId ||
        signedData.organizationId !== organizationId) {
        throw new Error(`organization id does not match expected value. Expected: ${organizationId}. Found: ${signedData.organizationId}.`);
    }
    if (!signedData.userId || signedData.userId !== userId) {
        throw new Error(`user id does not match expected value. Expected: ${userId}. Found: ${signedData.userId}.`);
    }
    if (!signedData.targetPublic) {
        throw new Error('missing "targetPublic" in bundle signed data');
    }
    // Load target public key generated from enclave
    const targetKeyBuf = encoding.uint8ArrayFromHexString(signedData.targetPublic);
    const privateKeyBundle = crypto.hpkeEncrypt({ plainTextBuf, targetKeyBuf });
    return crypto.formatHpkeBuf(privateKeyBundle);
};
/**
  /**
   * Encrypts a mnemonic wallet bundle using HPKE and verifies the enclave signature.
   *
   * @param {EncryptWalletToBundleParams} params - An object containing the mnemonic, bundle, user, and organization details. Optionally, you can override the default signer key (for testing purposes).
   * @returns {Promise<string>} - A promise that resolves to a JSON string representing the encrypted wallet bundle.
   * @throws {Error} - If enclave signature verification or any other validation fails.
   */
const encryptWalletToBundle = async ({ mnemonic, importBundle, userId, organizationId, dangerouslyOverrideSignerPublicKey, }) => {
    const parsedImportBundle = JSON.parse(importBundle);
    const plainTextBuf = new TextEncoder().encode(mnemonic);
    const verified = await verifyEnclaveSignature(parsedImportBundle.enclaveQuorumPublic, parsedImportBundle.dataSignature, parsedImportBundle.data, dangerouslyOverrideSignerPublicKey);
    if (!verified) {
        throw new Error(`failed to verify enclave signature: ${importBundle}`);
    }
    const signedData = JSON.parse(new TextDecoder().decode(encoding.uint8ArrayFromHexString(parsedImportBundle.data)));
    if (!signedData.organizationId ||
        signedData.organizationId !== organizationId) {
        throw new Error(`organization id does not match expected value. Expected: ${organizationId}. Found: ${signedData.organizationId}.`);
    }
    if (!signedData.userId || signedData.userId !== userId) {
        throw new Error(`user id does not match expected value. Expected: ${userId}. Found: ${signedData.userId}.`);
    }
    if (!signedData.targetPublic) {
        throw new Error('missing "targetPublic" in bundle signed data');
    }
    // Load target public key generated from enclave
    const targetKeyBuf = encoding.uint8ArrayFromHexString(signedData.targetPublic);
    const privateKeyBundle = crypto.hpkeEncrypt({ plainTextBuf, targetKeyBuf });
    return crypto.formatHpkeBuf(privateKeyBundle);
};

exports.decryptCredentialBundle = decryptCredentialBundle;
exports.decryptExportBundle = decryptExportBundle;
exports.encryptPrivateKeyToBundle = encryptPrivateKeyToBundle;
exports.encryptWalletToBundle = encryptWalletToBundle;
exports.verifyStampSignature = verifyStampSignature;
//# sourceMappingURL=turnkey.js.map
