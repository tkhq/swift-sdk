// @generated by Typegen. DO NOT EDIT BY HAND

import Foundation

// MARK: - Base Types from Swagger Definitions

public struct apiApiKeyParams: Codable, Sendable {
  /// Human-readable name for an API Key.
  public let apiKeyName: String
  /// Optional window (in seconds) indicating how long the API Key should last.
  public let expirationSeconds: String?
  /// The public component of a cryptographic key pair used to sign messages and transactions.
  public let publicKey: String

  public init(
    apiKeyName: String,
    expirationSeconds: String? = nil,
    publicKey: String
  ) {
    self.apiKeyName = apiKeyName
    self.expirationSeconds = expirationSeconds
    self.publicKey = publicKey
  }
}

public struct billingActivateBillingTierIntent: Codable, Sendable {
  /// The product that the customer wants to subscribe to.
  public let productId: String

  public init(
    productId: String
  ) {
    self.productId = productId
  }
}

public struct billingActivateBillingTierResult: Codable, Sendable {
  /// The id of the product being subscribed to.
  public let productId: String

  public init(
    productId: String
  ) {
    self.productId = productId
  }
}

public struct billingDeletePaymentMethodIntent: Codable, Sendable {
  /// The payment method that the customer wants to remove.
  public let paymentMethodId: String

  public init(
    paymentMethodId: String
  ) {
    self.paymentMethodId = paymentMethodId
  }
}

public struct billingDeletePaymentMethodResult: Codable, Sendable {
  /// The payment method that was removed.
  public let paymentMethodId: String

  public init(
    paymentMethodId: String
  ) {
    self.paymentMethodId = paymentMethodId
  }
}

public struct billingSetPaymentMethodIntent: Codable, Sendable {
  /// The email that will receive invoices for the credit card.
  public let cardHolderEmail: String
  /// The name associated with the credit card.
  public let cardHolderName: String
  /// The verification digits of the customer's credit card.
  public let cvv: String
  /// The month that the credit card expires.
  public let expiryMonth: String
  /// The year that the credit card expires.
  public let expiryYear: String
  /// The account number of the customer's credit card.
  public let number: String

  public init(
    cardHolderEmail: String,
    cardHolderName: String,
    cvv: String,
    expiryMonth: String,
    expiryYear: String,
    number: String
  ) {
    self.cardHolderEmail = cardHolderEmail
    self.cardHolderName = cardHolderName
    self.cvv = cvv
    self.expiryMonth = expiryMonth
    self.expiryYear = expiryYear
    self.number = number
  }
}

public struct billingSetPaymentMethodIntentV2: Codable, Sendable {
  /// The email that will receive invoices for the credit card.
  public let cardHolderEmail: String
  /// The name associated with the credit card.
  public let cardHolderName: String
  /// The id of the payment method that was created clientside.
  public let paymentMethodId: String

  public init(
    cardHolderEmail: String,
    cardHolderName: String,
    paymentMethodId: String
  ) {
    self.cardHolderEmail = cardHolderEmail
    self.cardHolderName = cardHolderName
    self.paymentMethodId = paymentMethodId
  }
}

public struct billingSetPaymentMethodResult: Codable, Sendable {
  /// The email address associated with the payment method.
  public let cardHolderEmail: String
  /// The name associated with the payment method.
  public let cardHolderName: String
  /// The last four digits of the credit card added.
  public let lastFour: String

  public init(
    cardHolderEmail: String,
    cardHolderName: String,
    lastFour: String
  ) {
    self.cardHolderEmail = cardHolderEmail
    self.cardHolderName = cardHolderName
    self.lastFour = lastFour
  }
}

public struct datav1Tag: Codable, Sendable {
  public let createdAt: externaldatav1Timestamp
  /// Unique identifier for a given Tag.
  public let tagId: String
  /// Human-readable name for a Tag.
  public let tagName: String
  public let tagType: v1TagType
  public let updatedAt: externaldatav1Timestamp

  public init(
    createdAt: externaldatav1Timestamp,
    tagId: String,
    tagName: String,
    tagType: v1TagType,
    updatedAt: externaldatav1Timestamp
  ) {
    self.createdAt = createdAt
    self.tagId = tagId
    self.tagName = tagName
    self.tagType = tagType
    self.updatedAt = updatedAt
  }
}

public struct externalactivityv1PolicyEvaluation: Codable, Sendable {
  /// Unique identifier for a given Activity.
  public let activityId: String
  public let createdAt: externaldatav1Timestamp
  /// Unique identifier for a given policy evaluation.
  public let id: String
  /// Unique identifier for the Organization the Activity belongs to.
  public let organizationId: String
  /// Detailed evaluation result for each Policy that was run.
  public let policyEvaluations: [immutablecommonv1PolicyEvaluation]
  /// Unique identifier for the Vote associated with this policy evaluation.
  public let voteId: String

  public init(
    activityId: String,
    createdAt: externaldatav1Timestamp,
    id: String,
    organizationId: String,
    policyEvaluations: [immutablecommonv1PolicyEvaluation],
    voteId: String
  ) {
    self.activityId = activityId
    self.createdAt = createdAt
    self.id = id
    self.organizationId = organizationId
    self.policyEvaluations = policyEvaluations
    self.voteId = voteId
  }
}

public struct externaldatav1Address: Codable, Sendable {
  public let address: String?
  public let format: v1AddressFormat?

  public init(
    address: String? = nil,
    format: v1AddressFormat? = nil
  ) {
    self.address = address
    self.format = format
  }
}

public struct externaldatav1Credential: Codable, Sendable {
  /// The public component of a cryptographic key pair used to sign messages and transactions.
  public let publicKey: String
  public let type: v1CredentialType

  public init(
    publicKey: String,
    type: v1CredentialType
  ) {
    self.publicKey = publicKey
    self.type = type
  }
}

public struct externaldatav1Quorum: Codable, Sendable {
  /// Count of unique approvals required to meet quorum.
  public let threshold: Int
  /// Unique identifiers of quorum set members.
  public let userIds: [String]

  public init(
    threshold: Int,
    userIds: [String]
  ) {
    self.threshold = threshold
    self.userIds = userIds
  }
}

public enum externaldatav1SignatureScheme: String, Codable, Sendable {
  case signature_scheme_ephemeral_key_p256 = "SIGNATURE_SCHEME_EPHEMERAL_KEY_P256"
}

public struct externaldatav1SmartContractInterface: Codable, Sendable {
  public let createdAt: externaldatav1Timestamp
  /// The label corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA).
  public let label: String
  /// The notes corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA).
  public let notes: String
  /// The Organization the Smart Contract Interface belongs to.
  public let organizationId: String
  /// The address corresponding to the Smart Contract or Program.
  public let smartContractAddress: String
  /// The JSON corresponding to the Smart Contract Interface (ABI or IDL).
  public let smartContractInterface: String
  /// Unique identifier for a given Smart Contract Interface (ABI or IDL).
  public let smartContractInterfaceId: String
  /// The type corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA).
  public let type: String
  public let updatedAt: externaldatav1Timestamp

  public init(
    createdAt: externaldatav1Timestamp,
    label: String,
    notes: String,
    organizationId: String,
    smartContractAddress: String,
    smartContractInterface: String,
    smartContractInterfaceId: String,
    type: String,
    updatedAt: externaldatav1Timestamp
  ) {
    self.createdAt = createdAt
    self.label = label
    self.notes = notes
    self.organizationId = organizationId
    self.smartContractAddress = smartContractAddress
    self.smartContractInterface = smartContractInterface
    self.smartContractInterfaceId = smartContractInterfaceId
    self.type = type
    self.updatedAt = updatedAt
  }
}

public struct externaldatav1Timestamp: Codable, Sendable {
  public let nanos: String
  public let seconds: String

  public init(
    nanos: String,
    seconds: String
  ) {
    self.nanos = nanos
    self.seconds = seconds
  }
}

public struct immutableactivityv1Address: Codable, Sendable {
  public let address: String?
  public let format: v1AddressFormat?

  public init(
    address: String? = nil,
    format: v1AddressFormat? = nil
  ) {
    self.address = address
    self.format = format
  }
}

public struct immutablecommonv1PolicyEvaluation: Codable, Sendable {
  public let outcome: v1Outcome?
  public let policyId: String?

  public init(
    outcome: v1Outcome? = nil,
    policyId: String? = nil
  ) {
    self.outcome = outcome
    self.policyId = policyId
  }
}

public struct protobufAny: Codable, Sendable {
  public let attype: String?

  public init(
    attype: String? = nil
  ) {
    self.attype = attype
  }

  private enum CodingKeys: String, CodingKey {
    case attype = "@type"
  }

  // Note: Additional properties supported
}

public struct rpcStatus: Codable, Sendable {
  public let code: Int?
  public let details: [protobufAny]?
  public let message: String?

  public init(
    code: Int? = nil,
    details: [protobufAny]? = nil,
    message: String? = nil
  ) {
    self.code = code
    self.details = details
    self.message = message
  }
}

public struct v1AcceptInvitationIntent: Codable, Sendable {
  /// WebAuthN hardware devices that can be used to log in to the Turnkey web app.
  public let authenticator: v1AuthenticatorParams
  /// Unique identifier for a given Invitation object.
  public let invitationId: String
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    authenticator: v1AuthenticatorParams,
    invitationId: String,
    userId: String
  ) {
    self.authenticator = authenticator
    self.invitationId = invitationId
    self.userId = userId
  }
}

public struct v1AcceptInvitationIntentV2: Codable, Sendable {
  /// WebAuthN hardware devices that can be used to log in to the Turnkey web app.
  public let authenticator: v1AuthenticatorParamsV2
  /// Unique identifier for a given Invitation object.
  public let invitationId: String
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    authenticator: v1AuthenticatorParamsV2,
    invitationId: String,
    userId: String
  ) {
    self.authenticator = authenticator
    self.invitationId = invitationId
    self.userId = userId
  }
}

public struct v1AcceptInvitationResult: Codable, Sendable {
  /// Unique identifier for a given Invitation.
  public let invitationId: String
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    invitationId: String,
    userId: String
  ) {
    self.invitationId = invitationId
    self.userId = userId
  }
}

public enum v1AccessType: String, Codable, Sendable {
  case access_type_web = "ACCESS_TYPE_WEB"
  case access_type_api = "ACCESS_TYPE_API"
  case access_type_all = "ACCESS_TYPE_ALL"
}

public struct v1Activity: Codable, Sendable {
  /// A list of App Proofs generated by enclaves during activity execution, providing verifiable attestations of performed operations.
  public let appProofs: [v1AppProof]?
  public let canApprove: Bool
  public let canReject: Bool
  public let createdAt: externaldatav1Timestamp
  /// Failure reason of the intended action.
  public let failure: rpcStatus?
  /// An artifact verifying a User's action.
  public let fingerprint: String
  /// Unique identifier for a given Activity object.
  public let id: String
  /// Intent object crafted by Turnkey based on the user request, used to assess the permissibility of an action.
  public let intent: v1Intent
  /// Unique identifier for a given Organization.
  public let organizationId: String
  /// Result of the intended action.
  public let result: v1Result
  /// The current processing status of a specified Activity.
  public let status: v1ActivityStatus
  /// Type of Activity, such as Add User, or Sign Transaction.
  public let type: v1ActivityType
  public let updatedAt: externaldatav1Timestamp
  /// A list of objects representing a particular User's approval or rejection of a Consensus request, including all relevant metadata.
  public let votes: [v1Vote]

  public init(
    appProofs: [v1AppProof]? = nil,
    canApprove: Bool,
    canReject: Bool,
    createdAt: externaldatav1Timestamp,
    failure: rpcStatus? = nil,
    fingerprint: String,
    id: String,
    intent: v1Intent,
    organizationId: String,
    result: v1Result,
    status: v1ActivityStatus,
    type: v1ActivityType,
    updatedAt: externaldatav1Timestamp,
    votes: [v1Vote]
  ) {
    self.appProofs = appProofs
    self.canApprove = canApprove
    self.canReject = canReject
    self.createdAt = createdAt
    self.failure = failure
    self.fingerprint = fingerprint
    self.id = id
    self.intent = intent
    self.organizationId = organizationId
    self.result = result
    self.status = status
    self.type = type
    self.updatedAt = updatedAt
    self.votes = votes
  }
}

public struct v1ActivityResponse: Codable, Sendable {
  /// An action that can be taken within the Turnkey infrastructure.
  public let activity: v1Activity

  public init(
    activity: v1Activity
  ) {
    self.activity = activity
  }
}

public enum v1ActivityStatus: String, Codable, Sendable {
  case activity_status_created = "ACTIVITY_STATUS_CREATED"
  case activity_status_pending = "ACTIVITY_STATUS_PENDING"
  case activity_status_completed = "ACTIVITY_STATUS_COMPLETED"
  case activity_status_failed = "ACTIVITY_STATUS_FAILED"
  case activity_status_consensus_needed = "ACTIVITY_STATUS_CONSENSUS_NEEDED"
  case activity_status_rejected = "ACTIVITY_STATUS_REJECTED"
}

public enum v1ActivityType: String, Codable, Sendable {
  case activity_type_create_api_keys = "ACTIVITY_TYPE_CREATE_API_KEYS"
  case activity_type_create_users = "ACTIVITY_TYPE_CREATE_USERS"
  case activity_type_create_private_keys = "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS"
  case activity_type_sign_raw_payload = "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD"
  case activity_type_create_invitations = "ACTIVITY_TYPE_CREATE_INVITATIONS"
  case activity_type_accept_invitation = "ACTIVITY_TYPE_ACCEPT_INVITATION"
  case activity_type_create_policy = "ACTIVITY_TYPE_CREATE_POLICY"
  case activity_type_disable_private_key = "ACTIVITY_TYPE_DISABLE_PRIVATE_KEY"
  case activity_type_delete_users = "ACTIVITY_TYPE_DELETE_USERS"
  case activity_type_delete_api_keys = "ACTIVITY_TYPE_DELETE_API_KEYS"
  case activity_type_delete_invitation = "ACTIVITY_TYPE_DELETE_INVITATION"
  case activity_type_delete_organization = "ACTIVITY_TYPE_DELETE_ORGANIZATION"
  case activity_type_delete_policy = "ACTIVITY_TYPE_DELETE_POLICY"
  case activity_type_create_user_tag = "ACTIVITY_TYPE_CREATE_USER_TAG"
  case activity_type_delete_user_tags = "ACTIVITY_TYPE_DELETE_USER_TAGS"
  case activity_type_create_organization = "ACTIVITY_TYPE_CREATE_ORGANIZATION"
  case activity_type_sign_transaction = "ACTIVITY_TYPE_SIGN_TRANSACTION"
  case activity_type_approve_activity = "ACTIVITY_TYPE_APPROVE_ACTIVITY"
  case activity_type_reject_activity = "ACTIVITY_TYPE_REJECT_ACTIVITY"
  case activity_type_delete_authenticators = "ACTIVITY_TYPE_DELETE_AUTHENTICATORS"
  case activity_type_create_authenticators = "ACTIVITY_TYPE_CREATE_AUTHENTICATORS"
  case activity_type_create_private_key_tag = "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG"
  case activity_type_delete_private_key_tags = "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS"
  case activity_type_set_payment_method = "ACTIVITY_TYPE_SET_PAYMENT_METHOD"
  case activity_type_activate_billing_tier = "ACTIVITY_TYPE_ACTIVATE_BILLING_TIER"
  case activity_type_delete_payment_method = "ACTIVITY_TYPE_DELETE_PAYMENT_METHOD"
  case activity_type_create_policy_v2 = "ACTIVITY_TYPE_CREATE_POLICY_V2"
  case activity_type_create_policy_v3 = "ACTIVITY_TYPE_CREATE_POLICY_V3"
  case activity_type_create_api_only_users = "ACTIVITY_TYPE_CREATE_API_ONLY_USERS"
  case activity_type_update_root_quorum = "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM"
  case activity_type_update_user_tag = "ACTIVITY_TYPE_UPDATE_USER_TAG"
  case activity_type_update_private_key_tag = "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG"
  case activity_type_create_authenticators_v2 = "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
  case activity_type_create_organization_v2 = "ACTIVITY_TYPE_CREATE_ORGANIZATION_V2"
  case activity_type_create_users_v2 = "ACTIVITY_TYPE_CREATE_USERS_V2"
  case activity_type_accept_invitation_v2 = "ACTIVITY_TYPE_ACCEPT_INVITATION_V2"
  case activity_type_create_sub_organization = "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION"
  case activity_type_create_sub_organization_v2 = "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V2"
  case activity_type_update_allowed_origins = "ACTIVITY_TYPE_UPDATE_ALLOWED_ORIGINS"
  case activity_type_create_private_keys_v2 = "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2"
  case activity_type_update_user = "ACTIVITY_TYPE_UPDATE_USER"
  case activity_type_update_policy = "ACTIVITY_TYPE_UPDATE_POLICY"
  case activity_type_set_payment_method_v2 = "ACTIVITY_TYPE_SET_PAYMENT_METHOD_V2"
  case activity_type_create_sub_organization_v3 = "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V3"
  case activity_type_create_wallet = "ACTIVITY_TYPE_CREATE_WALLET"
  case activity_type_create_wallet_accounts = "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS"
  case activity_type_init_user_email_recovery = "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY"
  case activity_type_recover_user = "ACTIVITY_TYPE_RECOVER_USER"
  case activity_type_set_organization_feature = "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE"
  case activity_type_remove_organization_feature = "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE"
  case activity_type_sign_raw_payload_v2 = "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
  case activity_type_sign_transaction_v2 = "ACTIVITY_TYPE_SIGN_TRANSACTION_V2"
  case activity_type_export_private_key = "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
  case activity_type_export_wallet = "ACTIVITY_TYPE_EXPORT_WALLET"
  case activity_type_create_sub_organization_v4 = "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V4"
  case activity_type_email_auth = "ACTIVITY_TYPE_EMAIL_AUTH"
  case activity_type_export_wallet_account = "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
  case activity_type_init_import_wallet = "ACTIVITY_TYPE_INIT_IMPORT_WALLET"
  case activity_type_import_wallet = "ACTIVITY_TYPE_IMPORT_WALLET"
  case activity_type_init_import_private_key = "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY"
  case activity_type_import_private_key = "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY"
  case activity_type_create_policies = "ACTIVITY_TYPE_CREATE_POLICIES"
  case activity_type_sign_raw_payloads = "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS"
  case activity_type_create_read_only_session = "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION"
  case activity_type_create_oauth_providers = "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS"
  case activity_type_delete_oauth_providers = "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS"
  case activity_type_create_sub_organization_v5 = "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V5"
  case activity_type_oauth = "ACTIVITY_TYPE_OAUTH"
  case activity_type_create_api_keys_v2 = "ACTIVITY_TYPE_CREATE_API_KEYS_V2"
  case activity_type_create_read_write_session = "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION"
  case activity_type_email_auth_v2 = "ACTIVITY_TYPE_EMAIL_AUTH_V2"
  case activity_type_create_sub_organization_v6 = "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V6"
  case activity_type_delete_private_keys = "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS"
  case activity_type_delete_wallets = "ACTIVITY_TYPE_DELETE_WALLETS"
  case activity_type_create_read_write_session_v2 = "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2"
  case activity_type_delete_sub_organization = "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION"
  case activity_type_init_otp_auth = "ACTIVITY_TYPE_INIT_OTP_AUTH"
  case activity_type_otp_auth = "ACTIVITY_TYPE_OTP_AUTH"
  case activity_type_create_sub_organization_v7 = "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7"
  case activity_type_update_wallet = "ACTIVITY_TYPE_UPDATE_WALLET"
  case activity_type_update_policy_v2 = "ACTIVITY_TYPE_UPDATE_POLICY_V2"
  case activity_type_create_users_v3 = "ACTIVITY_TYPE_CREATE_USERS_V3"
  case activity_type_init_otp_auth_v2 = "ACTIVITY_TYPE_INIT_OTP_AUTH_V2"
  case activity_type_init_otp = "ACTIVITY_TYPE_INIT_OTP"
  case activity_type_verify_otp = "ACTIVITY_TYPE_VERIFY_OTP"
  case activity_type_otp_login = "ACTIVITY_TYPE_OTP_LOGIN"
  case activity_type_stamp_login = "ACTIVITY_TYPE_STAMP_LOGIN"
  case activity_type_oauth_login = "ACTIVITY_TYPE_OAUTH_LOGIN"
  case activity_type_update_user_name = "ACTIVITY_TYPE_UPDATE_USER_NAME"
  case activity_type_update_user_email = "ACTIVITY_TYPE_UPDATE_USER_EMAIL"
  case activity_type_update_user_phone_number = "ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER"
  case activity_type_init_fiat_on_ramp = "ACTIVITY_TYPE_INIT_FIAT_ON_RAMP"
  case activity_type_create_smart_contract_interface =
    "ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE"
  case activity_type_delete_smart_contract_interface =
    "ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE"
  case activity_type_enable_auth_proxy = "ACTIVITY_TYPE_ENABLE_AUTH_PROXY"
  case activity_type_disable_auth_proxy = "ACTIVITY_TYPE_DISABLE_AUTH_PROXY"
  case activity_type_update_auth_proxy_config = "ACTIVITY_TYPE_UPDATE_AUTH_PROXY_CONFIG"
  case activity_type_create_oauth2_credential = "ACTIVITY_TYPE_CREATE_OAUTH2_CREDENTIAL"
  case activity_type_update_oauth2_credential = "ACTIVITY_TYPE_UPDATE_OAUTH2_CREDENTIAL"
  case activity_type_delete_oauth2_credential = "ACTIVITY_TYPE_DELETE_OAUTH2_CREDENTIAL"
  case activity_type_oauth2_authenticate = "ACTIVITY_TYPE_OAUTH2_AUTHENTICATE"
  case activity_type_delete_wallet_accounts = "ACTIVITY_TYPE_DELETE_WALLET_ACCOUNTS"
  case activity_type_delete_policies = "ACTIVITY_TYPE_DELETE_POLICIES"
  case activity_type_eth_send_raw_transaction = "ACTIVITY_TYPE_ETH_SEND_RAW_TRANSACTION"
  case activity_type_eth_send_transaction = "ACTIVITY_TYPE_ETH_SEND_TRANSACTION"
  case activity_type_create_fiat_on_ramp_credential = "ACTIVITY_TYPE_CREATE_FIAT_ON_RAMP_CREDENTIAL"
  case activity_type_update_fiat_on_ramp_credential = "ACTIVITY_TYPE_UPDATE_FIAT_ON_RAMP_CREDENTIAL"
  case activity_type_delete_fiat_on_ramp_credential = "ACTIVITY_TYPE_DELETE_FIAT_ON_RAMP_CREDENTIAL"
  case activity_type_email_auth_v3 = "ACTIVITY_TYPE_EMAIL_AUTH_V3"
  case activity_type_init_user_email_recovery_v2 = "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY_V2"
  case activity_type_init_otp_auth_v3 = "ACTIVITY_TYPE_INIT_OTP_AUTH_V3"
  case activity_type_init_otp_v2 = "ACTIVITY_TYPE_INIT_OTP_V2"
}

public enum v1AddressFormat: String, Codable, Sendable {
  case address_format_uncompressed = "ADDRESS_FORMAT_UNCOMPRESSED"
  case address_format_compressed = "ADDRESS_FORMAT_COMPRESSED"
  case address_format_ethereum = "ADDRESS_FORMAT_ETHEREUM"
  case address_format_solana = "ADDRESS_FORMAT_SOLANA"
  case address_format_cosmos = "ADDRESS_FORMAT_COSMOS"
  case address_format_tron = "ADDRESS_FORMAT_TRON"
  case address_format_sui = "ADDRESS_FORMAT_SUI"
  case address_format_aptos = "ADDRESS_FORMAT_APTOS"
  case address_format_bitcoin_mainnet_p2pkh = "ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH"
  case address_format_bitcoin_mainnet_p2sh = "ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH"
  case address_format_bitcoin_mainnet_p2wpkh = "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH"
  case address_format_bitcoin_mainnet_p2wsh = "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH"
  case address_format_bitcoin_mainnet_p2tr = "ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR"
  case address_format_bitcoin_testnet_p2pkh = "ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH"
  case address_format_bitcoin_testnet_p2sh = "ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH"
  case address_format_bitcoin_testnet_p2wpkh = "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH"
  case address_format_bitcoin_testnet_p2wsh = "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH"
  case address_format_bitcoin_testnet_p2tr = "ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR"
  case address_format_bitcoin_signet_p2pkh = "ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH"
  case address_format_bitcoin_signet_p2sh = "ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH"
  case address_format_bitcoin_signet_p2wpkh = "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH"
  case address_format_bitcoin_signet_p2wsh = "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH"
  case address_format_bitcoin_signet_p2tr = "ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR"
  case address_format_bitcoin_regtest_p2pkh = "ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH"
  case address_format_bitcoin_regtest_p2sh = "ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH"
  case address_format_bitcoin_regtest_p2wpkh = "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH"
  case address_format_bitcoin_regtest_p2wsh = "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH"
  case address_format_bitcoin_regtest_p2tr = "ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR"
  case address_format_sei = "ADDRESS_FORMAT_SEI"
  case address_format_xlm = "ADDRESS_FORMAT_XLM"
  case address_format_doge_mainnet = "ADDRESS_FORMAT_DOGE_MAINNET"
  case address_format_doge_testnet = "ADDRESS_FORMAT_DOGE_TESTNET"
  case address_format_ton_v3r2 = "ADDRESS_FORMAT_TON_V3R2"
  case address_format_ton_v4r2 = "ADDRESS_FORMAT_TON_V4R2"
  case address_format_ton_v5r1 = "ADDRESS_FORMAT_TON_V5R1"
  case address_format_xrp = "ADDRESS_FORMAT_XRP"
}

public struct v1ApiKey: Codable, Sendable {
  /// Unique identifier for a given API Key.
  public let apiKeyId: String
  /// Human-readable name for an API Key.
  public let apiKeyName: String
  public let createdAt: externaldatav1Timestamp
  /// A User credential that can be used to authenticate to Turnkey.
  public let credential: externaldatav1Credential
  /// Optional window (in seconds) indicating how long the API Key should last.
  public let expirationSeconds: String?
  public let updatedAt: externaldatav1Timestamp

  public init(
    apiKeyId: String,
    apiKeyName: String,
    createdAt: externaldatav1Timestamp,
    credential: externaldatav1Credential,
    expirationSeconds: String? = nil,
    updatedAt: externaldatav1Timestamp
  ) {
    self.apiKeyId = apiKeyId
    self.apiKeyName = apiKeyName
    self.createdAt = createdAt
    self.credential = credential
    self.expirationSeconds = expirationSeconds
    self.updatedAt = updatedAt
  }
}

public enum v1ApiKeyCurve: String, Codable, Sendable {
  case api_key_curve_p256 = "API_KEY_CURVE_P256"
  case api_key_curve_secp256k1 = "API_KEY_CURVE_SECP256K1"
  case api_key_curve_ed25519 = "API_KEY_CURVE_ED25519"
}

public struct v1ApiKeyParamsV2: Codable, Sendable {
  /// Human-readable name for an API Key.
  public let apiKeyName: String
  /// The curve type to be used for processing API key signatures.
  public let curveType: v1ApiKeyCurve
  /// Optional window (in seconds) indicating how long the API Key should last.
  public let expirationSeconds: String?
  /// The public component of a cryptographic key pair used to sign messages and transactions.
  public let publicKey: String

  public init(
    apiKeyName: String,
    curveType: v1ApiKeyCurve,
    expirationSeconds: String? = nil,
    publicKey: String
  ) {
    self.apiKeyName = apiKeyName
    self.curveType = curveType
    self.expirationSeconds = expirationSeconds
    self.publicKey = publicKey
  }
}

public struct v1ApiOnlyUserParams: Codable, Sendable {
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  public let apiKeys: [apiApiKeyParams]
  /// The email address for this API-only User (optional).
  public let userEmail: String?
  /// The name of the new API-only User.
  public let userName: String
  /// A list of tags assigned to the new API-only User. This field, if not needed, should be an empty array in your request body.
  public let userTags: [String]

  public init(
    apiKeys: [apiApiKeyParams],
    userEmail: String? = nil,
    userName: String,
    userTags: [String]
  ) {
    self.apiKeys = apiKeys
    self.userEmail = userEmail
    self.userName = userName
    self.userTags = userTags
  }
}

public struct v1AppProof: Codable, Sendable {
  /// JSON serialized AppProofPayload.
  public let proofPayload: String
  /// Ephemeral public key.
  public let publicKey: String
  /// Scheme of signing key.
  public let scheme: externaldatav1SignatureScheme
  /// Signature over hashed proof_payload.
  public let signature: String

  public init(
    proofPayload: String,
    publicKey: String,
    scheme: externaldatav1SignatureScheme,
    signature: String
  ) {
    self.proofPayload = proofPayload
    self.publicKey = publicKey
    self.scheme = scheme
    self.signature = signature
  }
}

public struct v1ApproveActivityIntent: Codable, Sendable {
  /// An artifact verifying a User's action.
  public let fingerprint: String

  public init(
    fingerprint: String
  ) {
    self.fingerprint = fingerprint
  }
}

public struct v1ApproveActivityRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1ApproveActivityIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1ApproveActivityIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1Attestation: Codable, Sendable {
  /// A base64 url encoded payload containing authenticator data and any attestation the webauthn provider chooses.
  public let attestationObject: String
  /// A base64 url encoded payload containing metadata about the signing context and the challenge.
  public let clientDataJson: String
  /// The cbor encoded then base64 url encoded id of the credential.
  public let credentialId: String
  /// The type of authenticator transports.
  public let transports: [v1AuthenticatorTransport]

  public init(
    attestationObject: String,
    clientDataJson: String,
    credentialId: String,
    transports: [v1AuthenticatorTransport]
  ) {
    self.attestationObject = attestationObject
    self.clientDataJson = clientDataJson
    self.credentialId = credentialId
    self.transports = transports
  }
}

public struct v1Authenticator: Codable, Sendable {
  /// Identifier indicating the type of the Security Key.
  public let aaguid: String
  public let attestationType: String
  /// Unique identifier for a given Authenticator.
  public let authenticatorId: String
  /// Human-readable name for an Authenticator.
  public let authenticatorName: String
  public let createdAt: externaldatav1Timestamp
  /// A User credential that can be used to authenticate to Turnkey.
  public let credential: externaldatav1Credential
  /// Unique identifier for a WebAuthn credential.
  public let credentialId: String
  /// The type of Authenticator device.
  public let model: String
  /// Types of transports that may be used by an Authenticator (e.g., USB, NFC, BLE).
  public let transports: [v1AuthenticatorTransport]
  public let updatedAt: externaldatav1Timestamp

  public init(
    aaguid: String,
    attestationType: String,
    authenticatorId: String,
    authenticatorName: String,
    createdAt: externaldatav1Timestamp,
    credential: externaldatav1Credential,
    credentialId: String,
    model: String,
    transports: [v1AuthenticatorTransport],
    updatedAt: externaldatav1Timestamp
  ) {
    self.aaguid = aaguid
    self.attestationType = attestationType
    self.authenticatorId = authenticatorId
    self.authenticatorName = authenticatorName
    self.createdAt = createdAt
    self.credential = credential
    self.credentialId = credentialId
    self.model = model
    self.transports = transports
    self.updatedAt = updatedAt
  }
}

public struct v1AuthenticatorAttestationResponse: Codable, Sendable {
  public let attestationObject: String
  public let authenticatorAttachment: String?
  public let clientDataJson: String
  public let transports: [v1AuthenticatorTransport]?

  public init(
    attestationObject: String,
    authenticatorAttachment: String? = nil,
    clientDataJson: String,
    transports: [v1AuthenticatorTransport]? = nil
  ) {
    self.attestationObject = attestationObject
    self.authenticatorAttachment = authenticatorAttachment
    self.clientDataJson = clientDataJson
    self.transports = transports
  }
}

public struct v1AuthenticatorParams: Codable, Sendable {
  public let attestation: v1PublicKeyCredentialWithAttestation
  /// Human-readable name for an Authenticator.
  public let authenticatorName: String
  /// Challenge presented for authentication purposes.
  public let challenge: String
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    attestation: v1PublicKeyCredentialWithAttestation,
    authenticatorName: String,
    challenge: String,
    userId: String
  ) {
    self.attestation = attestation
    self.authenticatorName = authenticatorName
    self.challenge = challenge
    self.userId = userId
  }
}

public struct v1AuthenticatorParamsV2: Codable, Sendable {
  /// The attestation that proves custody of the authenticator and provides metadata about it.
  public let attestation: v1Attestation
  /// Human-readable name for an Authenticator.
  public let authenticatorName: String
  /// Challenge presented for authentication purposes.
  public let challenge: String

  public init(
    attestation: v1Attestation,
    authenticatorName: String,
    challenge: String
  ) {
    self.attestation = attestation
    self.authenticatorName = authenticatorName
    self.challenge = challenge
  }
}

public enum v1AuthenticatorTransport: String, Codable, Sendable {
  case authenticator_transport_ble = "AUTHENTICATOR_TRANSPORT_BLE"
  case authenticator_transport_internal = "AUTHENTICATOR_TRANSPORT_INTERNAL"
  case authenticator_transport_nfc = "AUTHENTICATOR_TRANSPORT_NFC"
  case authenticator_transport_usb = "AUTHENTICATOR_TRANSPORT_USB"
  case authenticator_transport_hybrid = "AUTHENTICATOR_TRANSPORT_HYBRID"
}

public struct v1BootProof: Codable, Sendable {
  /// The DER encoded COSE Sign1 struct Attestation doc.
  public let awsAttestationDocB64: String
  public let createdAt: externaldatav1Timestamp
  /// The label under which the enclave app was deployed.
  public let deploymentLabel: String
  /// Name of the enclave app
  public let enclaveApp: String
  /// The hex encoded Ephemeral Public Key.
  public let ephemeralPublicKeyHex: String
  /// Owner of the app i.e. 'tkhq'
  public let owner: String
  /// The borsch serialized base64 encoded Manifest.
  public let qosManifestB64: String
  /// The borsch serialized base64 encoded Manifest Envelope.
  public let qosManifestEnvelopeB64: String

  public init(
    awsAttestationDocB64: String,
    createdAt: externaldatav1Timestamp,
    deploymentLabel: String,
    enclaveApp: String,
    ephemeralPublicKeyHex: String,
    owner: String,
    qosManifestB64: String,
    qosManifestEnvelopeB64: String
  ) {
    self.awsAttestationDocB64 = awsAttestationDocB64
    self.createdAt = createdAt
    self.deploymentLabel = deploymentLabel
    self.enclaveApp = enclaveApp
    self.ephemeralPublicKeyHex = ephemeralPublicKeyHex
    self.owner = owner
    self.qosManifestB64 = qosManifestB64
    self.qosManifestEnvelopeB64 = qosManifestEnvelopeB64
  }
}

public struct v1BootProofResponse: Codable, Sendable {
  public let bootProof: v1BootProof

  public init(
    bootProof: v1BootProof
  ) {
    self.bootProof = bootProof
  }
}

public struct v1ClientSignature: Codable, Sendable {
  /// The message that was signed.
  public let message: String
  /// The public component of a cryptographic key pair used to create the signature.
  public let publicKey: String
  /// The signature scheme used to generate the client signature.
  public let scheme: v1ClientSignatureScheme
  /// The cryptographic signature over the message.
  public let signature: String

  public init(
    message: String,
    publicKey: String,
    scheme: v1ClientSignatureScheme,
    signature: String
  ) {
    self.message = message
    self.publicKey = publicKey
    self.scheme = scheme
    self.signature = signature
  }
}

public enum v1ClientSignatureScheme: String, Codable, Sendable {
  case client_signature_scheme_api_p256 = "CLIENT_SIGNATURE_SCHEME_API_P256"
}

public struct v1Config: Codable, Sendable {
  public let features: [v1Feature]?
  public let quorum: externaldatav1Quorum?

  public init(
    features: [v1Feature]? = nil,
    quorum: externaldatav1Quorum? = nil
  ) {
    self.features = features
    self.quorum = quorum
  }
}

public struct v1CreateApiKeysIntent: Codable, Sendable {
  /// A list of API Keys.
  public let apiKeys: [apiApiKeyParams]
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    apiKeys: [apiApiKeyParams],
    userId: String
  ) {
    self.apiKeys = apiKeys
    self.userId = userId
  }
}

public struct v1CreateApiKeysIntentV2: Codable, Sendable {
  /// A list of API Keys.
  public let apiKeys: [v1ApiKeyParamsV2]
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    apiKeys: [v1ApiKeyParamsV2],
    userId: String
  ) {
    self.apiKeys = apiKeys
    self.userId = userId
  }
}

public struct v1CreateApiKeysRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateApiKeysIntentV2
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreateApiKeysIntentV2,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateApiKeysResult: Codable, Sendable {
  /// A list of API Key IDs.
  public let apiKeyIds: [String]

  public init(
    apiKeyIds: [String]
  ) {
    self.apiKeyIds = apiKeyIds
  }
}

public struct v1CreateApiOnlyUsersIntent: Codable, Sendable {
  /// A list of API-only Users to create.
  public let apiOnlyUsers: [v1ApiOnlyUserParams]

  public init(
    apiOnlyUsers: [v1ApiOnlyUserParams]
  ) {
    self.apiOnlyUsers = apiOnlyUsers
  }
}

public struct v1CreateApiOnlyUsersRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateApiOnlyUsersIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreateApiOnlyUsersIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateApiOnlyUsersResult: Codable, Sendable {
  /// A list of API-only User IDs.
  public let userIds: [String]

  public init(
    userIds: [String]
  ) {
    self.userIds = userIds
  }
}

public struct v1CreateAuthenticatorsIntent: Codable, Sendable {
  /// A list of Authenticators.
  public let authenticators: [v1AuthenticatorParams]
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    authenticators: [v1AuthenticatorParams],
    userId: String
  ) {
    self.authenticators = authenticators
    self.userId = userId
  }
}

public struct v1CreateAuthenticatorsIntentV2: Codable, Sendable {
  /// A list of Authenticators.
  public let authenticators: [v1AuthenticatorParamsV2]
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    authenticators: [v1AuthenticatorParamsV2],
    userId: String
  ) {
    self.authenticators = authenticators
    self.userId = userId
  }
}

public struct v1CreateAuthenticatorsRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateAuthenticatorsIntentV2
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreateAuthenticatorsIntentV2,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateAuthenticatorsResult: Codable, Sendable {
  /// A list of Authenticator IDs.
  public let authenticatorIds: [String]

  public init(
    authenticatorIds: [String]
  ) {
    self.authenticatorIds = authenticatorIds
  }
}

public struct v1CreateFiatOnRampCredentialIntent: Codable, Sendable {
  /// Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.
  public let encryptedPrivateApiKey: String?
  /// Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key
  public let encryptedSecretApiKey: String
  /// The fiat on-ramp provider
  public let onrampProvider: v1FiatOnRampProvider
  /// Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier
  public let projectId: String?
  /// Publishable API key for the on-ramp provider
  public let publishableApiKey: String
  /// If the on-ramp credential is a sandbox credential
  public let sandboxMode: Bool?

  public init(
    encryptedPrivateApiKey: String? = nil,
    encryptedSecretApiKey: String,
    onrampProvider: v1FiatOnRampProvider,
    projectId: String? = nil,
    publishableApiKey: String,
    sandboxMode: Bool? = nil
  ) {
    self.encryptedPrivateApiKey = encryptedPrivateApiKey
    self.encryptedSecretApiKey = encryptedSecretApiKey
    self.onrampProvider = onrampProvider
    self.projectId = projectId
    self.publishableApiKey = publishableApiKey
    self.sandboxMode = sandboxMode
  }
}

public struct v1CreateFiatOnRampCredentialRequest: Codable, Sendable {
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateFiatOnRampCredentialIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    organizationId: String,
    parameters: v1CreateFiatOnRampCredentialIntent,
    timestampMs: String,
    type: String
  ) {
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateFiatOnRampCredentialResult: Codable, Sendable {
  /// Unique identifier of the Fiat On-Ramp credential that was created
  public let fiatOnRampCredentialId: String

  public init(
    fiatOnRampCredentialId: String
  ) {
    self.fiatOnRampCredentialId = fiatOnRampCredentialId
  }
}

public struct v1CreateInvitationsIntent: Codable, Sendable {
  /// A list of Invitations.
  public let invitations: [v1InvitationParams]

  public init(
    invitations: [v1InvitationParams]
  ) {
    self.invitations = invitations
  }
}

public struct v1CreateInvitationsRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateInvitationsIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreateInvitationsIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateInvitationsResult: Codable, Sendable {
  /// A list of Invitation IDs
  public let invitationIds: [String]

  public init(
    invitationIds: [String]
  ) {
    self.invitationIds = invitationIds
  }
}

public struct v1CreateOauth2CredentialIntent: Codable, Sendable {
  /// The Client ID issued by the OAuth 2.0 provider
  public let clientId: String
  /// The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key
  public let encryptedClientSecret: String
  /// The OAuth 2.0 provider
  public let provider: v1Oauth2Provider

  public init(
    clientId: String,
    encryptedClientSecret: String,
    provider: v1Oauth2Provider
  ) {
    self.clientId = clientId
    self.encryptedClientSecret = encryptedClientSecret
    self.provider = provider
  }
}

public struct v1CreateOauth2CredentialRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateOauth2CredentialIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreateOauth2CredentialIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateOauth2CredentialResult: Codable, Sendable {
  /// Unique identifier of the OAuth 2.0 credential that was created
  public let oauth2CredentialId: String

  public init(
    oauth2CredentialId: String
  ) {
    self.oauth2CredentialId = oauth2CredentialId
  }
}

public struct v1CreateOauthProvidersIntent: Codable, Sendable {
  /// A list of Oauth providers.
  public let oauthProviders: [v1OauthProviderParams]
  /// The ID of the User to add an Oauth provider to
  public let userId: String

  public init(
    oauthProviders: [v1OauthProviderParams],
    userId: String
  ) {
    self.oauthProviders = oauthProviders
    self.userId = userId
  }
}

public struct v1CreateOauthProvidersRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateOauthProvidersIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreateOauthProvidersIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateOauthProvidersResult: Codable, Sendable {
  /// A list of unique identifiers for Oauth Providers
  public let providerIds: [String]

  public init(
    providerIds: [String]
  ) {
    self.providerIds = providerIds
  }
}

public struct v1CreateOrganizationIntent: Codable, Sendable {
  /// Human-readable name for an Organization.
  public let organizationName: String
  /// The root user's Authenticator.
  public let rootAuthenticator: v1AuthenticatorParams
  /// The root user's email address.
  public let rootEmail: String
  /// Unique identifier for the root user object.
  public let rootUserId: String?

  public init(
    organizationName: String,
    rootAuthenticator: v1AuthenticatorParams,
    rootEmail: String,
    rootUserId: String? = nil
  ) {
    self.organizationName = organizationName
    self.rootAuthenticator = rootAuthenticator
    self.rootEmail = rootEmail
    self.rootUserId = rootUserId
  }
}

public struct v1CreateOrganizationIntentV2: Codable, Sendable {
  /// Human-readable name for an Organization.
  public let organizationName: String
  /// The root user's Authenticator.
  public let rootAuthenticator: v1AuthenticatorParamsV2
  /// The root user's email address.
  public let rootEmail: String
  /// Unique identifier for the root user object.
  public let rootUserId: String?

  public init(
    organizationName: String,
    rootAuthenticator: v1AuthenticatorParamsV2,
    rootEmail: String,
    rootUserId: String? = nil
  ) {
    self.organizationName = organizationName
    self.rootAuthenticator = rootAuthenticator
    self.rootEmail = rootEmail
    self.rootUserId = rootUserId
  }
}

public struct v1CreateOrganizationResult: Codable, Sendable {
  /// Unique identifier for a given Organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1CreatePoliciesIntent: Codable, Sendable {
  /// An array of policy intents to be created.
  public let policies: [v1CreatePolicyIntentV3]

  public init(
    policies: [v1CreatePolicyIntentV3]
  ) {
    self.policies = policies
  }
}

public struct v1CreatePoliciesRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreatePoliciesIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreatePoliciesIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreatePoliciesResult: Codable, Sendable {
  /// A list of unique identifiers for the created policies.
  public let policyIds: [String]

  public init(
    policyIds: [String]
  ) {
    self.policyIds = policyIds
  }
}

public struct v1CreatePolicyIntent: Codable, Sendable {
  /// The instruction to DENY or ALLOW a particular activity following policy selector(s).
  public let effect: v1Effect
  public let notes: String?
  /// Human-readable name for a Policy.
  public let policyName: String
  /// A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details.
  public let selectors: [v1Selector]

  public init(
    effect: v1Effect,
    notes: String? = nil,
    policyName: String,
    selectors: [v1Selector]
  ) {
    self.effect = effect
    self.notes = notes
    self.policyName = policyName
    self.selectors = selectors
  }
}

public struct v1CreatePolicyIntentV2: Codable, Sendable {
  /// Whether to ALLOW or DENY requests that match the condition and consensus requirements.
  public let effect: v1Effect
  public let notes: String?
  /// Human-readable name for a Policy.
  public let policyName: String
  /// A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details.
  public let selectors: [v1SelectorV2]

  public init(
    effect: v1Effect,
    notes: String? = nil,
    policyName: String,
    selectors: [v1SelectorV2]
  ) {
    self.effect = effect
    self.notes = notes
    self.policyName = policyName
    self.selectors = selectors
  }
}

public struct v1CreatePolicyIntentV3: Codable, Sendable {
  /// The condition expression that triggers the Effect
  public let condition: String?
  /// The consensus expression that triggers the Effect
  public let consensus: String?
  /// The instruction to DENY or ALLOW an activity.
  public let effect: v1Effect
  public let notes: String?
  /// Human-readable name for a Policy.
  public let policyName: String

  public init(
    condition: String? = nil,
    consensus: String? = nil,
    effect: v1Effect,
    notes: String? = nil,
    policyName: String
  ) {
    self.condition = condition
    self.consensus = consensus
    self.effect = effect
    self.notes = notes
    self.policyName = policyName
  }
}

public struct v1CreatePolicyRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreatePolicyIntentV3
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreatePolicyIntentV3,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreatePolicyResult: Codable, Sendable {
  /// Unique identifier for a given Policy.
  public let policyId: String

  public init(
    policyId: String
  ) {
    self.policyId = policyId
  }
}

public struct v1CreatePrivateKeyTagIntent: Codable, Sendable {
  /// A list of Private Key IDs.
  public let privateKeyIds: [String]
  /// Human-readable name for a Private Key Tag.
  public let privateKeyTagName: String

  public init(
    privateKeyIds: [String],
    privateKeyTagName: String
  ) {
    self.privateKeyIds = privateKeyIds
    self.privateKeyTagName = privateKeyTagName
  }
}

public struct v1CreatePrivateKeyTagRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreatePrivateKeyTagIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreatePrivateKeyTagIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreatePrivateKeyTagResult: Codable, Sendable {
  /// A list of Private Key IDs.
  public let privateKeyIds: [String]
  /// Unique identifier for a given Private Key Tag.
  public let privateKeyTagId: String

  public init(
    privateKeyIds: [String],
    privateKeyTagId: String
  ) {
    self.privateKeyIds = privateKeyIds
    self.privateKeyTagId = privateKeyTagId
  }
}

public struct v1CreatePrivateKeysIntent: Codable, Sendable {
  /// A list of Private Keys.
  public let privateKeys: [v1PrivateKeyParams]

  public init(
    privateKeys: [v1PrivateKeyParams]
  ) {
    self.privateKeys = privateKeys
  }
}

public struct v1CreatePrivateKeysIntentV2: Codable, Sendable {
  /// A list of Private Keys.
  public let privateKeys: [v1PrivateKeyParams]

  public init(
    privateKeys: [v1PrivateKeyParams]
  ) {
    self.privateKeys = privateKeys
  }
}

public struct v1CreatePrivateKeysRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreatePrivateKeysIntentV2
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreatePrivateKeysIntentV2,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreatePrivateKeysResult: Codable, Sendable {
  /// A list of Private Key IDs.
  public let privateKeyIds: [String]

  public init(
    privateKeyIds: [String]
  ) {
    self.privateKeyIds = privateKeyIds
  }
}

public struct v1CreatePrivateKeysResultV2: Codable, Sendable {
  /// A list of Private Key IDs and addresses.
  public let privateKeys: [v1PrivateKeyResult]

  public init(
    privateKeys: [v1PrivateKeyResult]
  ) {
    self.privateKeys = privateKeys
  }
}

public struct v1CreateReadOnlySessionIntent: Codable, Sendable {
  public init() {}
}

public struct v1CreateReadOnlySessionRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateReadOnlySessionIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreateReadOnlySessionIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateReadOnlySessionResult: Codable, Sendable {
  /// Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons.
  public let organizationId: String
  /// Human-readable name for an Organization.
  public let organizationName: String
  /// String representing a read only session
  public let session: String
  /// UTC timestamp in seconds representing the expiry time for the read only session.
  public let sessionExpiry: String
  /// Unique identifier for a given User.
  public let userId: String
  /// Human-readable name for a User.
  public let username: String

  public init(
    organizationId: String,
    organizationName: String,
    session: String,
    sessionExpiry: String,
    userId: String,
    username: String
  ) {
    self.organizationId = organizationId
    self.organizationName = organizationName
    self.session = session
    self.sessionExpiry = sessionExpiry
    self.userId = userId
    self.username = username
  }
}

public struct v1CreateReadWriteSessionIntent: Codable, Sendable {
  /// Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp>
  public let apiKeyName: String?
  /// Email of the user to create a read write session for
  public let email: String
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted.
  public let targetPublicKey: String

  public init(
    apiKeyName: String? = nil,
    email: String,
    expirationSeconds: String? = nil,
    targetPublicKey: String
  ) {
    self.apiKeyName = apiKeyName
    self.email = email
    self.expirationSeconds = expirationSeconds
    self.targetPublicKey = targetPublicKey
  }
}

public struct v1CreateReadWriteSessionIntentV2: Codable, Sendable {
  /// Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp>
  public let apiKeyName: String?
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated ReadWriteSession API keys
  public let invalidateExisting: Bool?
  /// Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted.
  public let targetPublicKey: String
  /// Unique identifier for a given User.
  public let userId: String?

  public init(
    apiKeyName: String? = nil,
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    targetPublicKey: String,
    userId: String? = nil
  ) {
    self.apiKeyName = apiKeyName
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.targetPublicKey = targetPublicKey
    self.userId = userId
  }
}

public struct v1CreateReadWriteSessionRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateReadWriteSessionIntentV2
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreateReadWriteSessionIntentV2,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateReadWriteSessionResult: Codable, Sendable {
  /// Unique identifier for the created API key.
  public let apiKeyId: String
  /// HPKE encrypted credential bundle
  public let credentialBundle: String
  /// Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons.
  public let organizationId: String
  /// Human-readable name for an Organization.
  public let organizationName: String
  /// Unique identifier for a given User.
  public let userId: String
  /// Human-readable name for a User.
  public let username: String

  public init(
    apiKeyId: String,
    credentialBundle: String,
    organizationId: String,
    organizationName: String,
    userId: String,
    username: String
  ) {
    self.apiKeyId = apiKeyId
    self.credentialBundle = credentialBundle
    self.organizationId = organizationId
    self.organizationName = organizationName
    self.userId = userId
    self.username = username
  }
}

public struct v1CreateReadWriteSessionResultV2: Codable, Sendable {
  /// Unique identifier for the created API key.
  public let apiKeyId: String
  /// HPKE encrypted credential bundle
  public let credentialBundle: String
  /// Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons.
  public let organizationId: String
  /// Human-readable name for an Organization.
  public let organizationName: String
  /// Unique identifier for a given User.
  public let userId: String
  /// Human-readable name for a User.
  public let username: String

  public init(
    apiKeyId: String,
    credentialBundle: String,
    organizationId: String,
    organizationName: String,
    userId: String,
    username: String
  ) {
    self.apiKeyId = apiKeyId
    self.credentialBundle = credentialBundle
    self.organizationId = organizationId
    self.organizationName = organizationName
    self.userId = userId
    self.username = username
  }
}

public struct v1CreateSmartContractInterfaceIntent: Codable, Sendable {
  /// Human-readable name for a Smart Contract Interface.
  public let label: String
  /// Notes for a Smart Contract Interface.
  public let notes: String?
  /// Corresponding contract address or program ID
  public let smartContractAddress: String
  /// ABI/IDL as a JSON string
  public let smartContractInterface: String
  public let type: v1SmartContractInterfaceType

  public init(
    label: String,
    notes: String? = nil,
    smartContractAddress: String,
    smartContractInterface: String,
    type: v1SmartContractInterfaceType
  ) {
    self.label = label
    self.notes = notes
    self.smartContractAddress = smartContractAddress
    self.smartContractInterface = smartContractInterface
    self.type = type
  }
}

public struct v1CreateSmartContractInterfaceRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateSmartContractInterfaceIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreateSmartContractInterfaceIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateSmartContractInterfaceResult: Codable, Sendable {
  /// The ID of the created Smart Contract Interface.
  public let smartContractInterfaceId: String

  public init(
    smartContractInterfaceId: String
  ) {
    self.smartContractInterfaceId = smartContractInterfaceId
  }
}

public struct v1CreateSubOrganizationIntent: Codable, Sendable {
  /// Name for this sub-organization
  public let name: String
  /// Root User authenticator for this new sub-organization
  public let rootAuthenticator: v1AuthenticatorParamsV2

  public init(
    name: String,
    rootAuthenticator: v1AuthenticatorParamsV2
  ) {
    self.name = name
    self.rootAuthenticator = rootAuthenticator
  }
}

public struct v1CreateSubOrganizationIntentV2: Codable, Sendable {
  /// The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
  public let rootQuorumThreshold: Int
  /// Root users to create within this sub-organization
  public let rootUsers: [v1RootUserParams]
  /// Name for this sub-organization
  public let subOrganizationName: String

  public init(
    rootQuorumThreshold: Int,
    rootUsers: [v1RootUserParams],
    subOrganizationName: String
  ) {
    self.rootQuorumThreshold = rootQuorumThreshold
    self.rootUsers = rootUsers
    self.subOrganizationName = subOrganizationName
  }
}

public struct v1CreateSubOrganizationIntentV3: Codable, Sendable {
  /// A list of Private Keys.
  public let privateKeys: [v1PrivateKeyParams]
  /// The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
  public let rootQuorumThreshold: Int
  /// Root users to create within this sub-organization
  public let rootUsers: [v1RootUserParams]
  /// Name for this sub-organization
  public let subOrganizationName: String

  public init(
    privateKeys: [v1PrivateKeyParams],
    rootQuorumThreshold: Int,
    rootUsers: [v1RootUserParams],
    subOrganizationName: String
  ) {
    self.privateKeys = privateKeys
    self.rootQuorumThreshold = rootQuorumThreshold
    self.rootUsers = rootUsers
    self.subOrganizationName = subOrganizationName
  }
}

public struct v1CreateSubOrganizationIntentV4: Codable, Sendable {
  /// Disable email auth for the sub-organization
  public let disableEmailAuth: Bool?
  /// Disable email recovery for the sub-organization
  public let disableEmailRecovery: Bool?
  /// The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
  public let rootQuorumThreshold: Int
  /// Root users to create within this sub-organization
  public let rootUsers: [v1RootUserParams]
  /// Name for this sub-organization
  public let subOrganizationName: String
  /// The wallet to create for the sub-organization
  public let wallet: v1WalletParams?

  public init(
    disableEmailAuth: Bool? = nil,
    disableEmailRecovery: Bool? = nil,
    rootQuorumThreshold: Int,
    rootUsers: [v1RootUserParams],
    subOrganizationName: String,
    wallet: v1WalletParams? = nil
  ) {
    self.disableEmailAuth = disableEmailAuth
    self.disableEmailRecovery = disableEmailRecovery
    self.rootQuorumThreshold = rootQuorumThreshold
    self.rootUsers = rootUsers
    self.subOrganizationName = subOrganizationName
    self.wallet = wallet
  }
}

public struct v1CreateSubOrganizationIntentV5: Codable, Sendable {
  /// Disable email auth for the sub-organization
  public let disableEmailAuth: Bool?
  /// Disable email recovery for the sub-organization
  public let disableEmailRecovery: Bool?
  /// The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
  public let rootQuorumThreshold: Int
  /// Root users to create within this sub-organization
  public let rootUsers: [v1RootUserParamsV2]
  /// Name for this sub-organization
  public let subOrganizationName: String
  /// The wallet to create for the sub-organization
  public let wallet: v1WalletParams?

  public init(
    disableEmailAuth: Bool? = nil,
    disableEmailRecovery: Bool? = nil,
    rootQuorumThreshold: Int,
    rootUsers: [v1RootUserParamsV2],
    subOrganizationName: String,
    wallet: v1WalletParams? = nil
  ) {
    self.disableEmailAuth = disableEmailAuth
    self.disableEmailRecovery = disableEmailRecovery
    self.rootQuorumThreshold = rootQuorumThreshold
    self.rootUsers = rootUsers
    self.subOrganizationName = subOrganizationName
    self.wallet = wallet
  }
}

public struct v1CreateSubOrganizationIntentV6: Codable, Sendable {
  /// Disable email auth for the sub-organization
  public let disableEmailAuth: Bool?
  /// Disable email recovery for the sub-organization
  public let disableEmailRecovery: Bool?
  /// The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
  public let rootQuorumThreshold: Int
  /// Root users to create within this sub-organization
  public let rootUsers: [v1RootUserParamsV3]
  /// Name for this sub-organization
  public let subOrganizationName: String
  /// The wallet to create for the sub-organization
  public let wallet: v1WalletParams?

  public init(
    disableEmailAuth: Bool? = nil,
    disableEmailRecovery: Bool? = nil,
    rootQuorumThreshold: Int,
    rootUsers: [v1RootUserParamsV3],
    subOrganizationName: String,
    wallet: v1WalletParams? = nil
  ) {
    self.disableEmailAuth = disableEmailAuth
    self.disableEmailRecovery = disableEmailRecovery
    self.rootQuorumThreshold = rootQuorumThreshold
    self.rootUsers = rootUsers
    self.subOrganizationName = subOrganizationName
    self.wallet = wallet
  }
}

public struct v1CreateSubOrganizationIntentV7: Codable, Sendable {
  /// Optional signature proving authorization for this sub-organization creation. The signature is over the verification token ID and the root user parameters for the root user associated with the verification token. Only required if a public key was provided during the verification step.
  public let clientSignature: v1ClientSignature?
  /// Disable email auth for the sub-organization
  public let disableEmailAuth: Bool?
  /// Disable email recovery for the sub-organization
  public let disableEmailRecovery: Bool?
  /// Disable OTP email auth for the sub-organization
  public let disableOtpEmailAuth: Bool?
  /// Disable OTP SMS auth for the sub-organization
  public let disableSmsAuth: Bool?
  /// The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
  public let rootQuorumThreshold: Int
  /// Root users to create within this sub-organization
  public let rootUsers: [v1RootUserParamsV4]
  /// Name for this sub-organization
  public let subOrganizationName: String
  /// Signed JWT containing a unique id, expiry, verification type, contact
  public let verificationToken: String?
  /// The wallet to create for the sub-organization
  public let wallet: v1WalletParams?

  public init(
    clientSignature: v1ClientSignature? = nil,
    disableEmailAuth: Bool? = nil,
    disableEmailRecovery: Bool? = nil,
    disableOtpEmailAuth: Bool? = nil,
    disableSmsAuth: Bool? = nil,
    rootQuorumThreshold: Int,
    rootUsers: [v1RootUserParamsV4],
    subOrganizationName: String,
    verificationToken: String? = nil,
    wallet: v1WalletParams? = nil
  ) {
    self.clientSignature = clientSignature
    self.disableEmailAuth = disableEmailAuth
    self.disableEmailRecovery = disableEmailRecovery
    self.disableOtpEmailAuth = disableOtpEmailAuth
    self.disableSmsAuth = disableSmsAuth
    self.rootQuorumThreshold = rootQuorumThreshold
    self.rootUsers = rootUsers
    self.subOrganizationName = subOrganizationName
    self.verificationToken = verificationToken
    self.wallet = wallet
  }
}

public struct v1CreateSubOrganizationRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateSubOrganizationIntentV7
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreateSubOrganizationIntentV7,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateSubOrganizationResult: Codable, Sendable {
  public let rootUserIds: [String]?
  public let subOrganizationId: String

  public init(
    rootUserIds: [String]? = nil,
    subOrganizationId: String
  ) {
    self.rootUserIds = rootUserIds
    self.subOrganizationId = subOrganizationId
  }
}

public struct v1CreateSubOrganizationResultV3: Codable, Sendable {
  /// A list of Private Key IDs and addresses.
  public let privateKeys: [v1PrivateKeyResult]
  public let rootUserIds: [String]?
  public let subOrganizationId: String

  public init(
    privateKeys: [v1PrivateKeyResult],
    rootUserIds: [String]? = nil,
    subOrganizationId: String
  ) {
    self.privateKeys = privateKeys
    self.rootUserIds = rootUserIds
    self.subOrganizationId = subOrganizationId
  }
}

public struct v1CreateSubOrganizationResultV4: Codable, Sendable {
  public let rootUserIds: [String]?
  public let subOrganizationId: String
  public let wallet: v1WalletResult?

  public init(
    rootUserIds: [String]? = nil,
    subOrganizationId: String,
    wallet: v1WalletResult? = nil
  ) {
    self.rootUserIds = rootUserIds
    self.subOrganizationId = subOrganizationId
    self.wallet = wallet
  }
}

public struct v1CreateSubOrganizationResultV5: Codable, Sendable {
  public let rootUserIds: [String]?
  public let subOrganizationId: String
  public let wallet: v1WalletResult?

  public init(
    rootUserIds: [String]? = nil,
    subOrganizationId: String,
    wallet: v1WalletResult? = nil
  ) {
    self.rootUserIds = rootUserIds
    self.subOrganizationId = subOrganizationId
    self.wallet = wallet
  }
}

public struct v1CreateSubOrganizationResultV6: Codable, Sendable {
  public let rootUserIds: [String]?
  public let subOrganizationId: String
  public let wallet: v1WalletResult?

  public init(
    rootUserIds: [String]? = nil,
    subOrganizationId: String,
    wallet: v1WalletResult? = nil
  ) {
    self.rootUserIds = rootUserIds
    self.subOrganizationId = subOrganizationId
    self.wallet = wallet
  }
}

public struct v1CreateSubOrganizationResultV7: Codable, Sendable {
  public let rootUserIds: [String]?
  public let subOrganizationId: String
  public let wallet: v1WalletResult?

  public init(
    rootUserIds: [String]? = nil,
    subOrganizationId: String,
    wallet: v1WalletResult? = nil
  ) {
    self.rootUserIds = rootUserIds
    self.subOrganizationId = subOrganizationId
    self.wallet = wallet
  }
}

public struct v1CreateUserTagIntent: Codable, Sendable {
  /// A list of User IDs.
  public let userIds: [String]
  /// Human-readable name for a User Tag.
  public let userTagName: String

  public init(
    userIds: [String],
    userTagName: String
  ) {
    self.userIds = userIds
    self.userTagName = userTagName
  }
}

public struct v1CreateUserTagRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateUserTagIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreateUserTagIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateUserTagResult: Codable, Sendable {
  /// A list of User IDs.
  public let userIds: [String]
  /// Unique identifier for a given User Tag.
  public let userTagId: String

  public init(
    userIds: [String],
    userTagId: String
  ) {
    self.userIds = userIds
    self.userTagId = userTagId
  }
}

public struct v1CreateUsersIntent: Codable, Sendable {
  /// A list of Users.
  public let users: [v1UserParams]

  public init(
    users: [v1UserParams]
  ) {
    self.users = users
  }
}

public struct v1CreateUsersIntentV2: Codable, Sendable {
  /// A list of Users.
  public let users: [v1UserParamsV2]

  public init(
    users: [v1UserParamsV2]
  ) {
    self.users = users
  }
}

public struct v1CreateUsersIntentV3: Codable, Sendable {
  /// A list of Users.
  public let users: [v1UserParamsV3]

  public init(
    users: [v1UserParamsV3]
  ) {
    self.users = users
  }
}

public struct v1CreateUsersRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateUsersIntentV3
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreateUsersIntentV3,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateUsersResult: Codable, Sendable {
  /// A list of User IDs.
  public let userIds: [String]

  public init(
    userIds: [String]
  ) {
    self.userIds = userIds
  }
}

public struct v1CreateWalletAccountsIntent: Codable, Sendable {
  /// A list of wallet Accounts.
  public let accounts: [v1WalletAccountParams]
  /// Indicates if the wallet accounts should be persisted. This is helpful if you'd like to see the addresses of different derivation paths without actually creating the accounts. Defaults to true.
  public let persist: Bool?
  /// Unique identifier for a given Wallet.
  public let walletId: String

  public init(
    accounts: [v1WalletAccountParams],
    persist: Bool? = nil,
    walletId: String
  ) {
    self.accounts = accounts
    self.persist = persist
    self.walletId = walletId
  }
}

public struct v1CreateWalletAccountsRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateWalletAccountsIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreateWalletAccountsIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateWalletAccountsResult: Codable, Sendable {
  /// A list of derived addresses.
  public let addresses: [String]

  public init(
    addresses: [String]
  ) {
    self.addresses = addresses
  }
}

public struct v1CreateWalletIntent: Codable, Sendable {
  /// A list of wallet Accounts. This field, if not needed, should be an empty array in your request body.
  public let accounts: [v1WalletAccountParams]
  /// Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24.
  public let mnemonicLength: Int?
  /// Human-readable name for a Wallet.
  public let walletName: String

  public init(
    accounts: [v1WalletAccountParams],
    mnemonicLength: Int? = nil,
    walletName: String
  ) {
    self.accounts = accounts
    self.mnemonicLength = mnemonicLength
    self.walletName = walletName
  }
}

public struct v1CreateWalletRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1CreateWalletIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1CreateWalletIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1CreateWalletResult: Codable, Sendable {
  /// A list of account addresses.
  public let addresses: [String]
  /// Unique identifier for a Wallet.
  public let walletId: String

  public init(
    addresses: [String],
    walletId: String
  ) {
    self.addresses = addresses
    self.walletId = walletId
  }
}

public struct v1CredPropsAuthenticationExtensionsClientOutputs: Codable, Sendable {
  public let rk: Bool

  public init(
    rk: Bool
  ) {
    self.rk = rk
  }
}

public enum v1CredentialType: String, Codable, Sendable {
  case credential_type_webauthn_authenticator = "CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR"
  case credential_type_api_key_p256 = "CREDENTIAL_TYPE_API_KEY_P256"
  case credential_type_recover_user_key_p256 = "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256"
  case credential_type_api_key_secp256k1 = "CREDENTIAL_TYPE_API_KEY_SECP256K1"
  case credential_type_email_auth_key_p256 = "CREDENTIAL_TYPE_EMAIL_AUTH_KEY_P256"
  case credential_type_api_key_ed25519 = "CREDENTIAL_TYPE_API_KEY_ED25519"
  case credential_type_otp_auth_key_p256 = "CREDENTIAL_TYPE_OTP_AUTH_KEY_P256"
  case credential_type_read_write_session_key_p256 = "CREDENTIAL_TYPE_READ_WRITE_SESSION_KEY_P256"
  case credential_type_oauth_key_p256 = "CREDENTIAL_TYPE_OAUTH_KEY_P256"
  case credential_type_login = "CREDENTIAL_TYPE_LOGIN"
}

public enum v1Curve: String, Codable, Sendable {
  case curve_secp256k1 = "CURVE_SECP256K1"
  case curve_ed25519 = "CURVE_ED25519"
}

public struct v1DeleteApiKeysIntent: Codable, Sendable {
  /// A list of API Key IDs.
  public let apiKeyIds: [String]
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    apiKeyIds: [String],
    userId: String
  ) {
    self.apiKeyIds = apiKeyIds
    self.userId = userId
  }
}

public struct v1DeleteApiKeysRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeleteApiKeysIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeleteApiKeysIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeleteApiKeysResult: Codable, Sendable {
  /// A list of API Key IDs.
  public let apiKeyIds: [String]

  public init(
    apiKeyIds: [String]
  ) {
    self.apiKeyIds = apiKeyIds
  }
}

public struct v1DeleteAuthenticatorsIntent: Codable, Sendable {
  /// A list of Authenticator IDs.
  public let authenticatorIds: [String]
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    authenticatorIds: [String],
    userId: String
  ) {
    self.authenticatorIds = authenticatorIds
    self.userId = userId
  }
}

public struct v1DeleteAuthenticatorsRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeleteAuthenticatorsIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeleteAuthenticatorsIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeleteAuthenticatorsResult: Codable, Sendable {
  /// Unique identifier for a given Authenticator.
  public let authenticatorIds: [String]

  public init(
    authenticatorIds: [String]
  ) {
    self.authenticatorIds = authenticatorIds
  }
}

public struct v1DeleteFiatOnRampCredentialIntent: Codable, Sendable {
  /// The ID of the fiat on-ramp credential to delete
  public let fiatOnrampCredentialId: String

  public init(
    fiatOnrampCredentialId: String
  ) {
    self.fiatOnrampCredentialId = fiatOnrampCredentialId
  }
}

public struct v1DeleteFiatOnRampCredentialRequest: Codable, Sendable {
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeleteFiatOnRampCredentialIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    organizationId: String,
    parameters: v1DeleteFiatOnRampCredentialIntent,
    timestampMs: String,
    type: String
  ) {
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeleteFiatOnRampCredentialResult: Codable, Sendable {
  /// Unique identifier of the Fiat On-Ramp credential that was deleted
  public let fiatOnRampCredentialId: String

  public init(
    fiatOnRampCredentialId: String
  ) {
    self.fiatOnRampCredentialId = fiatOnRampCredentialId
  }
}

public struct v1DeleteInvitationIntent: Codable, Sendable {
  /// Unique identifier for a given Invitation object.
  public let invitationId: String

  public init(
    invitationId: String
  ) {
    self.invitationId = invitationId
  }
}

public struct v1DeleteInvitationRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeleteInvitationIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeleteInvitationIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeleteInvitationResult: Codable, Sendable {
  /// Unique identifier for a given Invitation.
  public let invitationId: String

  public init(
    invitationId: String
  ) {
    self.invitationId = invitationId
  }
}

public struct v1DeleteOauth2CredentialIntent: Codable, Sendable {
  /// The ID of the OAuth 2.0 credential to delete
  public let oauth2CredentialId: String

  public init(
    oauth2CredentialId: String
  ) {
    self.oauth2CredentialId = oauth2CredentialId
  }
}

public struct v1DeleteOauth2CredentialRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeleteOauth2CredentialIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeleteOauth2CredentialIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeleteOauth2CredentialResult: Codable, Sendable {
  /// Unique identifier of the OAuth 2.0 credential that was deleted
  public let oauth2CredentialId: String

  public init(
    oauth2CredentialId: String
  ) {
    self.oauth2CredentialId = oauth2CredentialId
  }
}

public struct v1DeleteOauthProvidersIntent: Codable, Sendable {
  /// Unique identifier for a given Provider.
  public let providerIds: [String]
  /// The ID of the User to remove an Oauth provider from
  public let userId: String

  public init(
    providerIds: [String],
    userId: String
  ) {
    self.providerIds = providerIds
    self.userId = userId
  }
}

public struct v1DeleteOauthProvidersRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeleteOauthProvidersIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeleteOauthProvidersIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeleteOauthProvidersResult: Codable, Sendable {
  /// A list of unique identifiers for Oauth Providers
  public let providerIds: [String]

  public init(
    providerIds: [String]
  ) {
    self.providerIds = providerIds
  }
}

public struct v1DeleteOrganizationIntent: Codable, Sendable {
  /// Unique identifier for a given Organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1DeleteOrganizationResult: Codable, Sendable {
  /// Unique identifier for a given Organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1DeletePoliciesIntent: Codable, Sendable {
  /// List of unique identifiers for policies within an organization
  public let policyIds: [String]

  public init(
    policyIds: [String]
  ) {
    self.policyIds = policyIds
  }
}

public struct v1DeletePoliciesRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeletePoliciesIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeletePoliciesIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeletePoliciesResult: Codable, Sendable {
  /// A list of unique identifiers for the deleted policies.
  public let policyIds: [String]

  public init(
    policyIds: [String]
  ) {
    self.policyIds = policyIds
  }
}

public struct v1DeletePolicyIntent: Codable, Sendable {
  /// Unique identifier for a given Policy.
  public let policyId: String

  public init(
    policyId: String
  ) {
    self.policyId = policyId
  }
}

public struct v1DeletePolicyRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeletePolicyIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeletePolicyIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeletePolicyResult: Codable, Sendable {
  /// Unique identifier for a given Policy.
  public let policyId: String

  public init(
    policyId: String
  ) {
    self.policyId = policyId
  }
}

public struct v1DeletePrivateKeyTagsIntent: Codable, Sendable {
  /// A list of Private Key Tag IDs.
  public let privateKeyTagIds: [String]

  public init(
    privateKeyTagIds: [String]
  ) {
    self.privateKeyTagIds = privateKeyTagIds
  }
}

public struct v1DeletePrivateKeyTagsRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeletePrivateKeyTagsIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeletePrivateKeyTagsIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeletePrivateKeyTagsResult: Codable, Sendable {
  /// A list of Private Key IDs.
  public let privateKeyIds: [String]
  /// A list of Private Key Tag IDs.
  public let privateKeyTagIds: [String]

  public init(
    privateKeyIds: [String],
    privateKeyTagIds: [String]
  ) {
    self.privateKeyIds = privateKeyIds
    self.privateKeyTagIds = privateKeyTagIds
  }
}

public struct v1DeletePrivateKeysIntent: Codable, Sendable {
  /// Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored.
  public let deleteWithoutExport: Bool?
  /// List of unique identifiers for private keys within an organization
  public let privateKeyIds: [String]

  public init(
    deleteWithoutExport: Bool? = nil,
    privateKeyIds: [String]
  ) {
    self.deleteWithoutExport = deleteWithoutExport
    self.privateKeyIds = privateKeyIds
  }
}

public struct v1DeletePrivateKeysRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeletePrivateKeysIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeletePrivateKeysIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeletePrivateKeysResult: Codable, Sendable {
  /// A list of private key unique identifiers that were removed
  public let privateKeyIds: [String]

  public init(
    privateKeyIds: [String]
  ) {
    self.privateKeyIds = privateKeyIds
  }
}

public struct v1DeleteSmartContractInterfaceIntent: Codable, Sendable {
  /// The ID of a Smart Contract Interface intended for deletion.
  public let smartContractInterfaceId: String

  public init(
    smartContractInterfaceId: String
  ) {
    self.smartContractInterfaceId = smartContractInterfaceId
  }
}

public struct v1DeleteSmartContractInterfaceRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeleteSmartContractInterfaceIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeleteSmartContractInterfaceIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeleteSmartContractInterfaceResult: Codable, Sendable {
  /// The ID of the deleted Smart Contract Interface.
  public let smartContractInterfaceId: String

  public init(
    smartContractInterfaceId: String
  ) {
    self.smartContractInterfaceId = smartContractInterfaceId
  }
}

public struct v1DeleteSubOrganizationIntent: Codable, Sendable {
  /// Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false.
  public let deleteWithoutExport: Bool?

  public init(
    deleteWithoutExport: Bool? = nil
  ) {
    self.deleteWithoutExport = deleteWithoutExport
  }
}

public struct v1DeleteSubOrganizationRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeleteSubOrganizationIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeleteSubOrganizationIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeleteSubOrganizationResult: Codable, Sendable {
  /// Unique identifier of the sub organization that was removed
  public let subOrganizationUuid: String

  public init(
    subOrganizationUuid: String
  ) {
    self.subOrganizationUuid = subOrganizationUuid
  }
}

public struct v1DeleteUserTagsIntent: Codable, Sendable {
  /// A list of User Tag IDs.
  public let userTagIds: [String]

  public init(
    userTagIds: [String]
  ) {
    self.userTagIds = userTagIds
  }
}

public struct v1DeleteUserTagsRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeleteUserTagsIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeleteUserTagsIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeleteUserTagsResult: Codable, Sendable {
  /// A list of User IDs.
  public let userIds: [String]
  /// A list of User Tag IDs.
  public let userTagIds: [String]

  public init(
    userIds: [String],
    userTagIds: [String]
  ) {
    self.userIds = userIds
    self.userTagIds = userTagIds
  }
}

public struct v1DeleteUsersIntent: Codable, Sendable {
  /// A list of User IDs.
  public let userIds: [String]

  public init(
    userIds: [String]
  ) {
    self.userIds = userIds
  }
}

public struct v1DeleteUsersRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeleteUsersIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeleteUsersIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeleteUsersResult: Codable, Sendable {
  /// A list of User IDs.
  public let userIds: [String]

  public init(
    userIds: [String]
  ) {
    self.userIds = userIds
  }
}

public struct v1DeleteWalletAccountsIntent: Codable, Sendable {
  /// Optional parameter for deleting the wallet accounts, even if any have not been previously exported. If they have been exported, this field is ignored.
  public let deleteWithoutExport: Bool?
  /// List of unique identifiers for wallet accounts within an organization
  public let walletAccountIds: [String]

  public init(
    deleteWithoutExport: Bool? = nil,
    walletAccountIds: [String]
  ) {
    self.deleteWithoutExport = deleteWithoutExport
    self.walletAccountIds = walletAccountIds
  }
}

public struct v1DeleteWalletAccountsRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeleteWalletAccountsIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeleteWalletAccountsIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeleteWalletAccountsResult: Codable, Sendable {
  /// A list of wallet account unique identifiers that were removed
  public let walletAccountIds: [String]

  public init(
    walletAccountIds: [String]
  ) {
    self.walletAccountIds = walletAccountIds
  }
}

public struct v1DeleteWalletsIntent: Codable, Sendable {
  /// Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored.
  public let deleteWithoutExport: Bool?
  /// List of unique identifiers for wallets within an organization
  public let walletIds: [String]

  public init(
    deleteWithoutExport: Bool? = nil,
    walletIds: [String]
  ) {
    self.deleteWithoutExport = deleteWithoutExport
    self.walletIds = walletIds
  }
}

public struct v1DeleteWalletsRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1DeleteWalletsIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1DeleteWalletsIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1DeleteWalletsResult: Codable, Sendable {
  /// A list of wallet unique identifiers that were removed
  public let walletIds: [String]

  public init(
    walletIds: [String]
  ) {
    self.walletIds = walletIds
  }
}

public struct v1DisableAuthProxyIntent: Codable, Sendable {
  public init() {}
}

public struct v1DisableAuthProxyResult: Codable, Sendable {
  public init() {}
}

public struct v1DisablePrivateKeyIntent: Codable, Sendable {
  /// Unique identifier for a given Private Key.
  public let privateKeyId: String

  public init(
    privateKeyId: String
  ) {
    self.privateKeyId = privateKeyId
  }
}

public struct v1DisablePrivateKeyResult: Codable, Sendable {
  /// Unique identifier for a given Private Key.
  public let privateKeyId: String

  public init(
    privateKeyId: String
  ) {
    self.privateKeyId = privateKeyId
  }
}

public enum v1Effect: String, Codable, Sendable {
  case effect_allow = "EFFECT_ALLOW"
  case effect_deny = "EFFECT_DENY"
}

public struct v1EmailAuthIntent: Codable, Sendable {
  /// Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp>
  public let apiKeyName: String?
  /// Email of the authenticating user.
  public let email: String
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomization: v1EmailCustomizationParams?
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated Email Auth API keys
  public let invalidateExisting: Bool?
  /// Optional custom email address to use as reply-to
  public let replyToEmailAddress: String?
  /// Optional custom email address from which to send the email
  public let sendFromEmailAddress: String?
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  public let sendFromEmailSenderName: String?
  /// Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted.
  public let targetPublicKey: String

  public init(
    apiKeyName: String? = nil,
    email: String,
    emailCustomization: v1EmailCustomizationParams? = nil,
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    targetPublicKey: String
  ) {
    self.apiKeyName = apiKeyName
    self.email = email
    self.emailCustomization = emailCustomization
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.targetPublicKey = targetPublicKey
  }
}

public struct v1EmailAuthIntentV2: Codable, Sendable {
  /// Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp>
  public let apiKeyName: String?
  /// Email of the authenticating user.
  public let email: String
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomization: v1EmailCustomizationParams?
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated Email Auth API keys
  public let invalidateExisting: Bool?
  /// Optional custom email address to use as reply-to
  public let replyToEmailAddress: String?
  /// Optional custom email address from which to send the email
  public let sendFromEmailAddress: String?
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  public let sendFromEmailSenderName: String?
  /// Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted.
  public let targetPublicKey: String

  public init(
    apiKeyName: String? = nil,
    email: String,
    emailCustomization: v1EmailCustomizationParams? = nil,
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    targetPublicKey: String
  ) {
    self.apiKeyName = apiKeyName
    self.email = email
    self.emailCustomization = emailCustomization
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.targetPublicKey = targetPublicKey
  }
}

public struct v1EmailAuthIntentV3: Codable, Sendable {
  /// Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp>
  public let apiKeyName: String?
  /// The name of the application.
  public let appName: String
  /// Email of the authenticating user.
  public let email: String
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomization: v1EmailCustomizationParams?
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated Email Auth API keys
  public let invalidateExisting: Bool?
  /// Optional custom email address to use as reply-to
  public let replyToEmailAddress: String?
  /// Optional custom email address from which to send the email
  public let sendFromEmailAddress: String?
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  public let sendFromEmailSenderName: String?
  /// Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted.
  public let targetPublicKey: String

  public init(
    apiKeyName: String? = nil,
    appName: String,
    email: String,
    emailCustomization: v1EmailCustomizationParams? = nil,
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    targetPublicKey: String
  ) {
    self.apiKeyName = apiKeyName
    self.appName = appName
    self.email = email
    self.emailCustomization = emailCustomization
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.targetPublicKey = targetPublicKey
  }
}

public struct v1EmailAuthRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1EmailAuthIntentV3
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1EmailAuthIntentV3,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1EmailAuthResult: Codable, Sendable {
  /// Unique identifier for the created API key.
  public let apiKeyId: String
  /// Unique identifier for the authenticating User.
  public let userId: String

  public init(
    apiKeyId: String,
    userId: String
  ) {
    self.apiKeyId = apiKeyId
    self.userId = userId
  }
}

public struct v1EmailCustomizationParams: Codable, Sendable {
  /// The name of the application.
  public let appName: String?
  /// A URL pointing to a logo in PNG format. Note this logo will be resized to fit into 340px x 124px.
  public let logoUrl: String?
  /// A template for the URL to be used in a magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`.
  public let magicLinkTemplate: String?
  /// Unique identifier for a given Email Template. If not specified, the default is the most recent Email Template.
  public let templateId: String?
  /// JSON object containing key/value pairs to be used with custom templates.
  public let templateVariables: String?

  public init(
    appName: String? = nil,
    logoUrl: String? = nil,
    magicLinkTemplate: String? = nil,
    templateId: String? = nil,
    templateVariables: String? = nil
  ) {
    self.appName = appName
    self.logoUrl = logoUrl
    self.magicLinkTemplate = magicLinkTemplate
    self.templateId = templateId
    self.templateVariables = templateVariables
  }
}

public struct v1EnableAuthProxyIntent: Codable, Sendable {
  public init() {}
}

public struct v1EnableAuthProxyResult: Codable, Sendable {
  /// A User ID with permission to initiate authentication.
  public let userId: String

  public init(
    userId: String
  ) {
    self.userId = userId
  }
}

public struct v1EthSendRawTransactionIntent: Codable, Sendable {
  /// CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet).
  public let caip2: String
  /// The raw, signed transaction to be sent.
  public let signedTransaction: String

  public init(
    caip2: String,
    signedTransaction: String
  ) {
    self.caip2 = caip2
    self.signedTransaction = signedTransaction
  }
}

public struct v1EthSendRawTransactionRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1EthSendRawTransactionIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1EthSendRawTransactionIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1EthSendRawTransactionResult: Codable, Sendable {
  /// The transaction hash of the sent transaction
  public let transactionHash: String

  public init(
    transactionHash: String
  ) {
    self.transactionHash = transactionHash
  }
}

public struct v1EthSendTransactionIntent: Codable, Sendable {
  /// CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet).
  public let caip2: String
  /// Hex-encoded call data for contract interactions.
  public let data: String?
  /// A wallet or private key address to sign with. This does not support private key IDs.
  public let from: String
  /// Maximum amount of gas to use for this transaction, for EIP-1559 transactions.
  public let gasLimit: String?
  /// Maximum total fee per gas unit (base fee + priority fee) in wei. Required for non-sponsored (EIP-1559) transactions. Not used for sponsored transactions.
  public let maxFeePerGas: String?
  /// Maximum priority fee (tip) per gas unit in wei. Required for non-sponsored (EIP-1559) transactions. Not used for sponsored transactions.
  public let maxPriorityFeePerGas: String?
  /// Transaction nonce, for EIP-1559 and Turnkey Gas Station authorizations.
  public let nonce: String?
  /// Whether to sponsor this transaction via Gas Station.
  public let sponsor: Bool?
  /// Recipient address as a hex string with 0x prefix.
  public let to: String
  /// Amount of native asset to send in wei.
  public let value: String?

  public init(
    caip2: String,
    data: String? = nil,
    from: String,
    gasLimit: String? = nil,
    maxFeePerGas: String? = nil,
    maxPriorityFeePerGas: String? = nil,
    nonce: String? = nil,
    sponsor: Bool? = nil,
    to: String,
    value: String? = nil
  ) {
    self.caip2 = caip2
    self.data = data
    self.from = from
    self.gasLimit = gasLimit
    self.maxFeePerGas = maxFeePerGas
    self.maxPriorityFeePerGas = maxPriorityFeePerGas
    self.nonce = nonce
    self.sponsor = sponsor
    self.to = to
    self.value = value
  }
}

public struct v1EthSendTransactionRequest: Codable, Sendable {
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1EthSendTransactionIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    organizationId: String,
    parameters: v1EthSendTransactionIntent,
    timestampMs: String,
    type: String
  ) {
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1EthSendTransactionResult: Codable, Sendable {
  /// The send_transaction_status ID associated with the transaction submission for sponsored transactions
  public let sendTransactionStatusId: String

  public init(
    sendTransactionStatusId: String
  ) {
    self.sendTransactionStatusId = sendTransactionStatusId
  }
}

public struct v1EthSendTransactionStatus: Codable, Sendable {
  /// The Ethereum transaction hash, if available.
  public let txHash: String?

  public init(
    txHash: String? = nil
  ) {
    self.txHash = txHash
  }
}

public struct v1ExportPrivateKeyIntent: Codable, Sendable {
  /// Unique identifier for a given Private Key.
  public let privateKeyId: String
  /// Client-side public key generated by the user, to which the export bundle will be encrypted.
  public let targetPublicKey: String

  public init(
    privateKeyId: String,
    targetPublicKey: String
  ) {
    self.privateKeyId = privateKeyId
    self.targetPublicKey = targetPublicKey
  }
}

public struct v1ExportPrivateKeyRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1ExportPrivateKeyIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1ExportPrivateKeyIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1ExportPrivateKeyResult: Codable, Sendable {
  /// Export bundle containing a private key encrypted to the client's target public key.
  public let exportBundle: String
  /// Unique identifier for a given Private Key.
  public let privateKeyId: String

  public init(
    exportBundle: String,
    privateKeyId: String
  ) {
    self.exportBundle = exportBundle
    self.privateKeyId = privateKeyId
  }
}

public struct v1ExportWalletAccountIntent: Codable, Sendable {
  /// Address to identify Wallet Account.
  public let address: String
  /// Client-side public key generated by the user, to which the export bundle will be encrypted.
  public let targetPublicKey: String

  public init(
    address: String,
    targetPublicKey: String
  ) {
    self.address = address
    self.targetPublicKey = targetPublicKey
  }
}

public struct v1ExportWalletAccountRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1ExportWalletAccountIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1ExportWalletAccountIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1ExportWalletAccountResult: Codable, Sendable {
  /// Address to identify Wallet Account.
  public let address: String
  /// Export bundle containing a private key encrypted by the client's target public key.
  public let exportBundle: String

  public init(
    address: String,
    exportBundle: String
  ) {
    self.address = address
    self.exportBundle = exportBundle
  }
}

public struct v1ExportWalletIntent: Codable, Sendable {
  /// The language of the mnemonic to export. Defaults to English.
  public let language: v1MnemonicLanguage?
  /// Client-side public key generated by the user, to which the export bundle will be encrypted.
  public let targetPublicKey: String
  /// Unique identifier for a given Wallet.
  public let walletId: String

  public init(
    language: v1MnemonicLanguage? = nil,
    targetPublicKey: String,
    walletId: String
  ) {
    self.language = language
    self.targetPublicKey = targetPublicKey
    self.walletId = walletId
  }
}

public struct v1ExportWalletRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1ExportWalletIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1ExportWalletIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1ExportWalletResult: Codable, Sendable {
  /// Export bundle containing a wallet mnemonic + optional newline passphrase encrypted by the client's target public key.
  public let exportBundle: String
  /// Unique identifier for a given Wallet.
  public let walletId: String

  public init(
    exportBundle: String,
    walletId: String
  ) {
    self.exportBundle = exportBundle
    self.walletId = walletId
  }
}

public struct v1Feature: Codable, Sendable {
  public let name: v1FeatureName?
  public let value: String?

  public init(
    name: v1FeatureName? = nil,
    value: String? = nil
  ) {
    self.name = name
    self.value = value
  }
}

public enum v1FeatureName: String, Codable, Sendable {
  case feature_name_root_user_email_recovery = "FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY"
  case feature_name_webauthn_origins = "FEATURE_NAME_WEBAUTHN_ORIGINS"
  case feature_name_email_auth = "FEATURE_NAME_EMAIL_AUTH"
  case feature_name_email_recovery = "FEATURE_NAME_EMAIL_RECOVERY"
  case feature_name_webhook = "FEATURE_NAME_WEBHOOK"
  case feature_name_sms_auth = "FEATURE_NAME_SMS_AUTH"
  case feature_name_otp_email_auth = "FEATURE_NAME_OTP_EMAIL_AUTH"
  case feature_name_auth_proxy = "FEATURE_NAME_AUTH_PROXY"
}

public enum v1FiatOnRampBlockchainNetwork: String, Codable, Sendable {
  case fiat_on_ramp_blockchain_network_bitcoin = "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BITCOIN"
  case fiat_on_ramp_blockchain_network_ethereum = "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_ETHEREUM"
  case fiat_on_ramp_blockchain_network_solana = "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_SOLANA"
  case fiat_on_ramp_blockchain_network_base = "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BASE"
}

public struct v1FiatOnRampCredential: Codable, Sendable {
  public let createdAt: externaldatav1Timestamp
  /// Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.
  public let encryptedPrivateApiKey: String?
  /// Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key.
  public let encryptedSecretApiKey: String
  /// Unique identifier for a given Fiat On-Ramp Credential.
  public let fiatOnrampCredentialId: String
  /// The fiat on-ramp provider.
  public let onrampProvider: v1FiatOnRampProvider
  /// Unique identifier for an Organization.
  public let organizationId: String
  /// Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier.
  public let projectId: String?
  /// Publishable API key for the on-ramp provider.
  public let publishableApiKey: String
  /// If the on-ramp credential is a sandbox credential.
  public let sandboxMode: Bool?
  public let updatedAt: externaldatav1Timestamp

  public init(
    createdAt: externaldatav1Timestamp,
    encryptedPrivateApiKey: String? = nil,
    encryptedSecretApiKey: String,
    fiatOnrampCredentialId: String,
    onrampProvider: v1FiatOnRampProvider,
    organizationId: String,
    projectId: String? = nil,
    publishableApiKey: String,
    sandboxMode: Bool? = nil,
    updatedAt: externaldatav1Timestamp
  ) {
    self.createdAt = createdAt
    self.encryptedPrivateApiKey = encryptedPrivateApiKey
    self.encryptedSecretApiKey = encryptedSecretApiKey
    self.fiatOnrampCredentialId = fiatOnrampCredentialId
    self.onrampProvider = onrampProvider
    self.organizationId = organizationId
    self.projectId = projectId
    self.publishableApiKey = publishableApiKey
    self.sandboxMode = sandboxMode
    self.updatedAt = updatedAt
  }
}

public enum v1FiatOnRampCryptoCurrency: String, Codable, Sendable {
  case fiat_on_ramp_crypto_currency_btc = "FIAT_ON_RAMP_CRYPTO_CURRENCY_BTC"
  case fiat_on_ramp_crypto_currency_eth = "FIAT_ON_RAMP_CRYPTO_CURRENCY_ETH"
  case fiat_on_ramp_crypto_currency_sol = "FIAT_ON_RAMP_CRYPTO_CURRENCY_SOL"
  case fiat_on_ramp_crypto_currency_usdc = "FIAT_ON_RAMP_CRYPTO_CURRENCY_USDC"
}

public enum v1FiatOnRampCurrency: String, Codable, Sendable {
  case fiat_on_ramp_currency_aud = "FIAT_ON_RAMP_CURRENCY_AUD"
  case fiat_on_ramp_currency_bgn = "FIAT_ON_RAMP_CURRENCY_BGN"
  case fiat_on_ramp_currency_brl = "FIAT_ON_RAMP_CURRENCY_BRL"
  case fiat_on_ramp_currency_cad = "FIAT_ON_RAMP_CURRENCY_CAD"
  case fiat_on_ramp_currency_chf = "FIAT_ON_RAMP_CURRENCY_CHF"
  case fiat_on_ramp_currency_cop = "FIAT_ON_RAMP_CURRENCY_COP"
  case fiat_on_ramp_currency_czk = "FIAT_ON_RAMP_CURRENCY_CZK"
  case fiat_on_ramp_currency_dkk = "FIAT_ON_RAMP_CURRENCY_DKK"
  case fiat_on_ramp_currency_dop = "FIAT_ON_RAMP_CURRENCY_DOP"
  case fiat_on_ramp_currency_egp = "FIAT_ON_RAMP_CURRENCY_EGP"
  case fiat_on_ramp_currency_eur = "FIAT_ON_RAMP_CURRENCY_EUR"
  case fiat_on_ramp_currency_gbp = "FIAT_ON_RAMP_CURRENCY_GBP"
  case fiat_on_ramp_currency_hkd = "FIAT_ON_RAMP_CURRENCY_HKD"
  case fiat_on_ramp_currency_idr = "FIAT_ON_RAMP_CURRENCY_IDR"
  case fiat_on_ramp_currency_ils = "FIAT_ON_RAMP_CURRENCY_ILS"
  case fiat_on_ramp_currency_jod = "FIAT_ON_RAMP_CURRENCY_JOD"
  case fiat_on_ramp_currency_kes = "FIAT_ON_RAMP_CURRENCY_KES"
  case fiat_on_ramp_currency_kwd = "FIAT_ON_RAMP_CURRENCY_KWD"
  case fiat_on_ramp_currency_lkr = "FIAT_ON_RAMP_CURRENCY_LKR"
  case fiat_on_ramp_currency_mxn = "FIAT_ON_RAMP_CURRENCY_MXN"
  case fiat_on_ramp_currency_ngn = "FIAT_ON_RAMP_CURRENCY_NGN"
  case fiat_on_ramp_currency_nok = "FIAT_ON_RAMP_CURRENCY_NOK"
  case fiat_on_ramp_currency_nzd = "FIAT_ON_RAMP_CURRENCY_NZD"
  case fiat_on_ramp_currency_omr = "FIAT_ON_RAMP_CURRENCY_OMR"
  case fiat_on_ramp_currency_pen = "FIAT_ON_RAMP_CURRENCY_PEN"
  case fiat_on_ramp_currency_pln = "FIAT_ON_RAMP_CURRENCY_PLN"
  case fiat_on_ramp_currency_ron = "FIAT_ON_RAMP_CURRENCY_RON"
  case fiat_on_ramp_currency_sek = "FIAT_ON_RAMP_CURRENCY_SEK"
  case fiat_on_ramp_currency_thb = "FIAT_ON_RAMP_CURRENCY_THB"
  case fiat_on_ramp_currency_try = "FIAT_ON_RAMP_CURRENCY_TRY"
  case fiat_on_ramp_currency_twd = "FIAT_ON_RAMP_CURRENCY_TWD"
  case fiat_on_ramp_currency_usd = "FIAT_ON_RAMP_CURRENCY_USD"
  case fiat_on_ramp_currency_vnd = "FIAT_ON_RAMP_CURRENCY_VND"
  case fiat_on_ramp_currency_zar = "FIAT_ON_RAMP_CURRENCY_ZAR"
}

public enum v1FiatOnRampPaymentMethod: String, Codable, Sendable {
  case fiat_on_ramp_payment_method_credit_debit_card =
    "FIAT_ON_RAMP_PAYMENT_METHOD_CREDIT_DEBIT_CARD"
  case fiat_on_ramp_payment_method_apple_pay = "FIAT_ON_RAMP_PAYMENT_METHOD_APPLE_PAY"
  case fiat_on_ramp_payment_method_gbp_bank_transfer =
    "FIAT_ON_RAMP_PAYMENT_METHOD_GBP_BANK_TRANSFER"
  case fiat_on_ramp_payment_method_gbp_open_banking_payment =
    "FIAT_ON_RAMP_PAYMENT_METHOD_GBP_OPEN_BANKING_PAYMENT"
  case fiat_on_ramp_payment_method_google_pay = "FIAT_ON_RAMP_PAYMENT_METHOD_GOOGLE_PAY"
  case fiat_on_ramp_payment_method_sepa_bank_transfer =
    "FIAT_ON_RAMP_PAYMENT_METHOD_SEPA_BANK_TRANSFER"
  case fiat_on_ramp_payment_method_pix_instant_payment =
    "FIAT_ON_RAMP_PAYMENT_METHOD_PIX_INSTANT_PAYMENT"
  case fiat_on_ramp_payment_method_paypal = "FIAT_ON_RAMP_PAYMENT_METHOD_PAYPAL"
  case fiat_on_ramp_payment_method_venmo = "FIAT_ON_RAMP_PAYMENT_METHOD_VENMO"
  case fiat_on_ramp_payment_method_moonpay_balance = "FIAT_ON_RAMP_PAYMENT_METHOD_MOONPAY_BALANCE"
  case fiat_on_ramp_payment_method_crypto_account = "FIAT_ON_RAMP_PAYMENT_METHOD_CRYPTO_ACCOUNT"
  case fiat_on_ramp_payment_method_fiat_wallet = "FIAT_ON_RAMP_PAYMENT_METHOD_FIAT_WALLET"
  case fiat_on_ramp_payment_method_ach_bank_account = "FIAT_ON_RAMP_PAYMENT_METHOD_ACH_BANK_ACCOUNT"
}

public enum v1FiatOnRampProvider: String, Codable, Sendable {
  case fiat_on_ramp_provider_coinbase = "FIAT_ON_RAMP_PROVIDER_COINBASE"
  case fiat_on_ramp_provider_moonpay = "FIAT_ON_RAMP_PROVIDER_MOONPAY"
}

public struct v1GetActivitiesRequest: Codable, Sendable {
  /// Array of activity statuses filtering which activities will be listed in the response.
  public let filterByStatus: [v1ActivityStatus]?
  /// Array of activity types filtering which activities will be listed in the response.
  public let filterByType: [v1ActivityType]?
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// Parameters used for cursor-based pagination.
  public let paginationOptions: v1Pagination?

  public init(
    filterByStatus: [v1ActivityStatus]? = nil,
    filterByType: [v1ActivityType]? = nil,
    organizationId: String,
    paginationOptions: v1Pagination? = nil
  ) {
    self.filterByStatus = filterByStatus
    self.filterByType = filterByType
    self.organizationId = organizationId
    self.paginationOptions = paginationOptions
  }
}

public struct v1GetActivitiesResponse: Codable, Sendable {
  /// A list of activities.
  public let activities: [v1Activity]

  public init(
    activities: [v1Activity]
  ) {
    self.activities = activities
  }
}

public struct v1GetActivityRequest: Codable, Sendable {
  /// Unique identifier for a given activity object.
  public let activityId: String
  /// Unique identifier for a given organization.
  public let organizationId: String

  public init(
    activityId: String,
    organizationId: String
  ) {
    self.activityId = activityId
    self.organizationId = organizationId
  }
}

public struct v1GetApiKeyRequest: Codable, Sendable {
  /// Unique identifier for a given API key.
  public let apiKeyId: String
  /// Unique identifier for a given organization.
  public let organizationId: String

  public init(
    apiKeyId: String,
    organizationId: String
  ) {
    self.apiKeyId = apiKeyId
    self.organizationId = organizationId
  }
}

public struct v1GetApiKeyResponse: Codable, Sendable {
  /// An API key.
  public let apiKey: v1ApiKey

  public init(
    apiKey: v1ApiKey
  ) {
    self.apiKey = apiKey
  }
}

public struct v1GetApiKeysRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// Unique identifier for a given user.
  public let userId: String?

  public init(
    organizationId: String,
    userId: String? = nil
  ) {
    self.organizationId = organizationId
    self.userId = userId
  }
}

public struct v1GetApiKeysResponse: Codable, Sendable {
  /// A list of API keys.
  public let apiKeys: [v1ApiKey]

  public init(
    apiKeys: [v1ApiKey]
  ) {
    self.apiKeys = apiKeys
  }
}

public struct v1GetAppProofsRequest: Codable, Sendable {
  /// Unique identifier for a given activity.
  public let activityId: String
  /// Unique identifier for a given Organization.
  public let organizationId: String

  public init(
    activityId: String,
    organizationId: String
  ) {
    self.activityId = activityId
    self.organizationId = organizationId
  }
}

public struct v1GetAppProofsResponse: Codable, Sendable {
  public let appProofs: [v1AppProof]

  public init(
    appProofs: [v1AppProof]
  ) {
    self.appProofs = appProofs
  }
}

public struct v1GetAttestationDocumentRequest: Codable, Sendable {
  /// The enclave type, one of: ump, notarizer, signer, evm-parser.
  public let enclaveType: String
  /// Unique identifier for a given organization.
  public let organizationId: String

  public init(
    enclaveType: String,
    organizationId: String
  ) {
    self.enclaveType = enclaveType
    self.organizationId = organizationId
  }
}

public struct v1GetAttestationDocumentResponse: Codable, Sendable {
  /// Raw (CBOR-encoded) attestation document.
  public let attestationDocument: String

  public init(
    attestationDocument: String
  ) {
    self.attestationDocument = attestationDocument
  }
}

public struct v1GetAuthenticatorRequest: Codable, Sendable {
  /// Unique identifier for a given authenticator.
  public let authenticatorId: String
  /// Unique identifier for a given organization.
  public let organizationId: String

  public init(
    authenticatorId: String,
    organizationId: String
  ) {
    self.authenticatorId = authenticatorId
    self.organizationId = organizationId
  }
}

public struct v1GetAuthenticatorResponse: Codable, Sendable {
  /// An authenticator.
  public let authenticator: v1Authenticator

  public init(
    authenticator: v1Authenticator
  ) {
    self.authenticator = authenticator
  }
}

public struct v1GetAuthenticatorsRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// Unique identifier for a given user.
  public let userId: String

  public init(
    organizationId: String,
    userId: String
  ) {
    self.organizationId = organizationId
    self.userId = userId
  }
}

public struct v1GetAuthenticatorsResponse: Codable, Sendable {
  /// A list of authenticators.
  public let authenticators: [v1Authenticator]

  public init(
    authenticators: [v1Authenticator]
  ) {
    self.authenticators = authenticators
  }
}

public struct v1GetBootProofRequest: Codable, Sendable {
  /// Hex encoded ephemeral public key.
  public let ephemeralKey: String
  /// Unique identifier for a given Organization.
  public let organizationId: String

  public init(
    ephemeralKey: String,
    organizationId: String
  ) {
    self.ephemeralKey = ephemeralKey
    self.organizationId = organizationId
  }
}

public struct v1GetGasUsageRequest: Codable, Sendable {
  /// Unique identifier for a given Organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1GetGasUsageResponse: Codable, Sendable {
  /// The total gas usage (in USD) of all sponsored transactions processed over the last `window_duration_minutes`
  public let usageUsd: String
  /// The window duration (in minutes) for the organization or sub-organization.
  public let windowDurationMinutes: Int
  /// The window limit (in USD) for the organization or sub-organization.
  public let windowLimitUsd: String

  public init(
    usageUsd: String,
    windowDurationMinutes: Int,
    windowLimitUsd: String
  ) {
    self.usageUsd = usageUsd
    self.windowDurationMinutes = windowDurationMinutes
    self.windowLimitUsd = windowLimitUsd
  }
}

public struct v1GetLatestBootProofRequest: Codable, Sendable {
  /// Name of enclave app.
  public let appName: String
  /// Unique identifier for a given Organization.
  public let organizationId: String

  public init(
    appName: String,
    organizationId: String
  ) {
    self.appName = appName
    self.organizationId = organizationId
  }
}

public struct v1GetOauth2CredentialRequest: Codable, Sendable {
  /// Unique identifier for a given OAuth 2.0 Credential.
  public let oauth2CredentialId: String
  /// Unique identifier for a given Organization.
  public let organizationId: String

  public init(
    oauth2CredentialId: String,
    organizationId: String
  ) {
    self.oauth2CredentialId = oauth2CredentialId
    self.organizationId = organizationId
  }
}

public struct v1GetOauth2CredentialResponse: Codable, Sendable {
  public let oauth2Credential: v1Oauth2Credential

  public init(
    oauth2Credential: v1Oauth2Credential
  ) {
    self.oauth2Credential = oauth2Credential
  }
}

public struct v1GetOauthProvidersRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// Unique identifier for a given user.
  public let userId: String?

  public init(
    organizationId: String,
    userId: String? = nil
  ) {
    self.organizationId = organizationId
    self.userId = userId
  }
}

public struct v1GetOauthProvidersResponse: Codable, Sendable {
  /// A list of Oauth providers.
  public let oauthProviders: [v1OauthProvider]

  public init(
    oauthProviders: [v1OauthProvider]
  ) {
    self.oauthProviders = oauthProviders
  }
}

public struct v1GetOnRampTransactionStatusRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// Optional flag to specify if the transaction status should be refreshed from the fiat on ramp provider. Default = false.
  public let refresh: Bool?
  /// The unique identifier for the fiat on ramp transaction.
  public let transactionId: String

  public init(
    organizationId: String,
    refresh: Bool? = nil,
    transactionId: String
  ) {
    self.organizationId = organizationId
    self.refresh = refresh
    self.transactionId = transactionId
  }
}

public struct v1GetOnRampTransactionStatusResponse: Codable, Sendable {
  /// The status of the fiat on ramp transaction.
  public let transactionStatus: String

  public init(
    transactionStatus: String
  ) {
    self.transactionStatus = transactionStatus
  }
}

public struct v1GetOrganizationConfigsRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1GetOrganizationConfigsResponse: Codable, Sendable {
  /// Organization configs including quorum settings and organization features.
  public let configs: v1Config

  public init(
    configs: v1Config
  ) {
    self.configs = configs
  }
}

public struct v1GetOrganizationRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1GetOrganizationResponse: Codable, Sendable {
  /// Object representing the full current and deleted / disabled collection of users, policies, private keys, and invitations attributable to a particular organization.
  public let organizationData: v1OrganizationData

  public init(
    organizationData: v1OrganizationData
  ) {
    self.organizationData = organizationData
  }
}

public struct v1GetPoliciesRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1GetPoliciesResponse: Codable, Sendable {
  /// A list of policies.
  public let policies: [v1Policy]

  public init(
    policies: [v1Policy]
  ) {
    self.policies = policies
  }
}

public struct v1GetPolicyEvaluationsRequest: Codable, Sendable {
  /// Unique identifier for a given activity.
  public let activityId: String
  /// Unique identifier for a given organization.
  public let organizationId: String

  public init(
    activityId: String,
    organizationId: String
  ) {
    self.activityId = activityId
    self.organizationId = organizationId
  }
}

public struct v1GetPolicyEvaluationsResponse: Codable, Sendable {
  public let policyEvaluations: [externalactivityv1PolicyEvaluation]

  public init(
    policyEvaluations: [externalactivityv1PolicyEvaluation]
  ) {
    self.policyEvaluations = policyEvaluations
  }
}

public struct v1GetPolicyRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// Unique identifier for a given policy.
  public let policyId: String

  public init(
    organizationId: String,
    policyId: String
  ) {
    self.organizationId = organizationId
    self.policyId = policyId
  }
}

public struct v1GetPolicyResponse: Codable, Sendable {
  /// Object that codifies rules defining the actions that are permissible within an organization.
  public let policy: v1Policy

  public init(
    policy: v1Policy
  ) {
    self.policy = policy
  }
}

public struct v1GetPrivateKeyRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// Unique identifier for a given private key.
  public let privateKeyId: String

  public init(
    organizationId: String,
    privateKeyId: String
  ) {
    self.organizationId = organizationId
    self.privateKeyId = privateKeyId
  }
}

public struct v1GetPrivateKeyResponse: Codable, Sendable {
  /// Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption.
  public let privateKey: v1PrivateKey

  public init(
    privateKey: v1PrivateKey
  ) {
    self.privateKey = privateKey
  }
}

public struct v1GetPrivateKeysRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1GetPrivateKeysResponse: Codable, Sendable {
  /// A list of private keys.
  public let privateKeys: [v1PrivateKey]

  public init(
    privateKeys: [v1PrivateKey]
  ) {
    self.privateKeys = privateKeys
  }
}

public struct v1GetSendTransactionStatusRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// The unique identifier of a send transaction request.
  public let sendTransactionStatusId: String

  public init(
    organizationId: String,
    sendTransactionStatusId: String
  ) {
    self.organizationId = organizationId
    self.sendTransactionStatusId = sendTransactionStatusId
  }
}

public struct v1GetSendTransactionStatusResponse: Codable, Sendable {
  /// Ethereum-specific transaction status.
  public let eth: v1EthSendTransactionStatus?
  /// The error encountered when broadcasting or confirming the transaction, if any.
  public let txError: String?
  /// The current status of the send transaction.
  public let txStatus: String

  public init(
    eth: v1EthSendTransactionStatus? = nil,
    txError: String? = nil,
    txStatus: String
  ) {
    self.eth = eth
    self.txError = txError
    self.txStatus = txStatus
  }
}

public struct v1GetSmartContractInterfaceRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// Unique identifier for a given smart contract interface.
  public let smartContractInterfaceId: String

  public init(
    organizationId: String,
    smartContractInterfaceId: String
  ) {
    self.organizationId = organizationId
    self.smartContractInterfaceId = smartContractInterfaceId
  }
}

public struct v1GetSmartContractInterfaceResponse: Codable, Sendable {
  /// Object to be used in conjunction with policies to guard transaction signing.
  public let smartContractInterface: externaldatav1SmartContractInterface

  public init(
    smartContractInterface: externaldatav1SmartContractInterface
  ) {
    self.smartContractInterface = smartContractInterface
  }
}

public struct v1GetSmartContractInterfacesRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1GetSmartContractInterfacesResponse: Codable, Sendable {
  /// A list of smart contract interfaces.
  public let smartContractInterfaces: [externaldatav1SmartContractInterface]

  public init(
    smartContractInterfaces: [externaldatav1SmartContractInterface]
  ) {
    self.smartContractInterfaces = smartContractInterfaces
  }
}

public struct v1GetSubOrgIdsRequest: Codable, Sendable {
  /// Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN', 'WALLET_ACCOUNT_ADDRESS' or 'PUBLIC_KEY'
  public let filterType: String?
  /// The value of the filter to apply for the specified type. For example, a specific email or name string.
  public let filterValue: String?
  /// Unique identifier for the parent organization. This is used to find sub-organizations within it.
  public let organizationId: String
  /// Parameters used for cursor-based pagination.
  public let paginationOptions: v1Pagination?

  public init(
    filterType: String? = nil,
    filterValue: String? = nil,
    organizationId: String,
    paginationOptions: v1Pagination? = nil
  ) {
    self.filterType = filterType
    self.filterValue = filterValue
    self.organizationId = organizationId
    self.paginationOptions = paginationOptions
  }
}

public struct v1GetSubOrgIdsResponse: Codable, Sendable {
  /// List of unique identifiers for the matching sub-organizations.
  public let organizationIds: [String]

  public init(
    organizationIds: [String]
  ) {
    self.organizationIds = organizationIds
  }
}

public struct v1GetUserRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// Unique identifier for a given user.
  public let userId: String

  public init(
    organizationId: String,
    userId: String
  ) {
    self.organizationId = organizationId
    self.userId = userId
  }
}

public struct v1GetUserResponse: Codable, Sendable {
  /// Web and/or API user within your organization.
  public let user: v1User

  public init(
    user: v1User
  ) {
    self.user = user
  }
}

public struct v1GetUsersRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1GetUsersResponse: Codable, Sendable {
  /// A list of users.
  public let users: [v1User]

  public init(
    users: [v1User]
  ) {
    self.users = users
  }
}

public struct v1GetVerifiedSubOrgIdsRequest: Codable, Sendable {
  /// Specifies the type of filter to apply, i.e 'EMAIL', 'PHONE_NUMBER'.
  public let filterType: String?
  /// The value of the filter to apply for the specified type. For example, a specific email or phone number string.
  public let filterValue: String?
  /// Unique identifier for the parent organization. This is used to find sub-organizations within it.
  public let organizationId: String
  /// Parameters used for cursor-based pagination.
  public let paginationOptions: v1Pagination?

  public init(
    filterType: String? = nil,
    filterValue: String? = nil,
    organizationId: String,
    paginationOptions: v1Pagination? = nil
  ) {
    self.filterType = filterType
    self.filterValue = filterValue
    self.organizationId = organizationId
    self.paginationOptions = paginationOptions
  }
}

public struct v1GetVerifiedSubOrgIdsResponse: Codable, Sendable {
  /// List of unique identifiers for the matching sub-organizations.
  public let organizationIds: [String]

  public init(
    organizationIds: [String]
  ) {
    self.organizationIds = organizationIds
  }
}

public struct v1GetWalletAccountRequest: Codable, Sendable {
  /// Address corresponding to a wallet account.
  public let address: String?
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// Path corresponding to a wallet account.
  public let path: String?
  /// Unique identifier for a given wallet.
  public let walletId: String

  public init(
    address: String? = nil,
    organizationId: String,
    path: String? = nil,
    walletId: String
  ) {
    self.address = address
    self.organizationId = organizationId
    self.path = path
    self.walletId = walletId
  }
}

public struct v1GetWalletAccountResponse: Codable, Sendable {
  /// The resulting wallet account.
  public let account: v1WalletAccount

  public init(
    account: v1WalletAccount
  ) {
    self.account = account
  }
}

public struct v1GetWalletAccountsRequest: Codable, Sendable {
  /// Optional flag to specify if the wallet details should be included in the response. Default = false.
  public let includeWalletDetails: Bool?
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// Parameters used for cursor-based pagination.
  public let paginationOptions: v1Pagination?
  /// Unique identifier for a given wallet. If not provided, all accounts for the organization will be returned.
  public let walletId: String?

  public init(
    includeWalletDetails: Bool? = nil,
    organizationId: String,
    paginationOptions: v1Pagination? = nil,
    walletId: String? = nil
  ) {
    self.includeWalletDetails = includeWalletDetails
    self.organizationId = organizationId
    self.paginationOptions = paginationOptions
    self.walletId = walletId
  }
}

public struct v1GetWalletAccountsResponse: Codable, Sendable {
  /// A list of accounts generated from a wallet that share a common seed.
  public let accounts: [v1WalletAccount]

  public init(
    accounts: [v1WalletAccount]
  ) {
    self.accounts = accounts
  }
}

public struct v1GetWalletRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// Unique identifier for a given wallet.
  public let walletId: String

  public init(
    organizationId: String,
    walletId: String
  ) {
    self.organizationId = organizationId
    self.walletId = walletId
  }
}

public struct v1GetWalletResponse: Codable, Sendable {
  /// A collection of deterministically generated cryptographic public / private key pairs that share a common seed.
  public let wallet: v1Wallet

  public init(
    wallet: v1Wallet
  ) {
    self.wallet = wallet
  }
}

public struct v1GetWalletsRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1GetWalletsResponse: Codable, Sendable {
  /// A list of wallets.
  public let wallets: [v1Wallet]

  public init(
    wallets: [v1Wallet]
  ) {
    self.wallets = wallets
  }
}

public struct v1GetWhoamiRequest: Codable, Sendable {
  /// Unique identifier for a given organization. If the request is being made by a WebAuthN user and their sub-organization ID is unknown, this can be the parent organization ID; using the sub-organization ID when possible is preferred due to performance reasons.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1GetWhoamiResponse: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// Human-readable name for an organization.
  public let organizationName: String
  /// Unique identifier for a given user.
  public let userId: String
  /// Human-readable name for a user.
  public let username: String

  public init(
    organizationId: String,
    organizationName: String,
    userId: String,
    username: String
  ) {
    self.organizationId = organizationId
    self.organizationName = organizationName
    self.userId = userId
    self.username = username
  }
}

public enum v1HashFunction: String, Codable, Sendable {
  case hash_function_no_op = "HASH_FUNCTION_NO_OP"
  case hash_function_sha256 = "HASH_FUNCTION_SHA256"
  case hash_function_keccak256 = "HASH_FUNCTION_KECCAK256"
  case hash_function_not_applicable = "HASH_FUNCTION_NOT_APPLICABLE"
}

public struct v1ImportPrivateKeyIntent: Codable, Sendable {
  /// Cryptocurrency-specific formats for a derived address (e.g., Ethereum).
  public let addressFormats: [v1AddressFormat]
  /// Cryptographic Curve used to generate a given Private Key.
  public let curve: v1Curve
  /// Bundle containing a raw private key encrypted to the enclave's target public key.
  public let encryptedBundle: String
  /// Human-readable name for a Private Key.
  public let privateKeyName: String
  /// The ID of the User importing a Private Key.
  public let userId: String

  public init(
    addressFormats: [v1AddressFormat],
    curve: v1Curve,
    encryptedBundle: String,
    privateKeyName: String,
    userId: String
  ) {
    self.addressFormats = addressFormats
    self.curve = curve
    self.encryptedBundle = encryptedBundle
    self.privateKeyName = privateKeyName
    self.userId = userId
  }
}

public struct v1ImportPrivateKeyRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1ImportPrivateKeyIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1ImportPrivateKeyIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1ImportPrivateKeyResult: Codable, Sendable {
  /// A list of addresses.
  public let addresses: [immutableactivityv1Address]
  /// Unique identifier for a Private Key.
  public let privateKeyId: String

  public init(
    addresses: [immutableactivityv1Address],
    privateKeyId: String
  ) {
    self.addresses = addresses
    self.privateKeyId = privateKeyId
  }
}

public struct v1ImportWalletIntent: Codable, Sendable {
  /// A list of wallet Accounts.
  public let accounts: [v1WalletAccountParams]
  /// Bundle containing a wallet mnemonic encrypted to the enclave's target public key.
  public let encryptedBundle: String
  /// The ID of the User importing a Wallet.
  public let userId: String
  /// Human-readable name for a Wallet.
  public let walletName: String

  public init(
    accounts: [v1WalletAccountParams],
    encryptedBundle: String,
    userId: String,
    walletName: String
  ) {
    self.accounts = accounts
    self.encryptedBundle = encryptedBundle
    self.userId = userId
    self.walletName = walletName
  }
}

public struct v1ImportWalletRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1ImportWalletIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1ImportWalletIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1ImportWalletResult: Codable, Sendable {
  /// A list of account addresses.
  public let addresses: [String]
  /// Unique identifier for a Wallet.
  public let walletId: String

  public init(
    addresses: [String],
    walletId: String
  ) {
    self.addresses = addresses
    self.walletId = walletId
  }
}

public struct v1InitFiatOnRampIntent: Codable, Sendable {
  /// ISO 3166-1 two-digit country code for Coinbase representing the purchasing users country of residence, e.g., US, GB.
  public let countryCode: String?
  /// ISO 3166-2 two-digit country subdivision code for Coinbase representing the purchasing users subdivision of residence within their country, e.g. NY. Required if country_code=US.
  public let countrySubdivisionCode: String?
  /// Code for the cryptocurrency to be purchased, e.g., btc, eth. Maps to MoonPay's currencyCode or Coinbase's defaultAsset.
  public let cryptoCurrencyCode: v1FiatOnRampCryptoCurrency
  /// Specifies a preset fiat amount for the transaction, e.g., '100'. Must be greater than '20'. If not provided, the user will be prompted to enter an amount.
  public let fiatCurrencyAmount: String?
  /// Code for the fiat currency to be used in the transaction, e.g., USD, EUR.
  public let fiatCurrencyCode: v1FiatOnRampCurrency?
  /// Blockchain network to be used for the transaction, e.g., bitcoin, ethereum. Maps to MoonPay's network or Coinbase's defaultNetwork.
  public let network: v1FiatOnRampBlockchainNetwork
  /// Enum to specifiy which on-ramp provider to use
  public let onrampProvider: v1FiatOnRampProvider
  /// Pre-selected payment method, e.g., CREDIT_DEBIT_CARD, APPLE_PAY. Validated against the chosen provider.
  public let paymentMethod: v1FiatOnRampPaymentMethod?
  /// Optional flag to indicate whether to use the sandbox mode to simulate transactions for the on-ramp provider. Default is false.
  public let sandboxMode: Bool?
  /// Optional MoonPay Widget URL to sign when using MoonPay client SDKs with URL Signing enabled.
  public let urlForSignature: String?
  /// Destination wallet address for the buy transaction.
  public let walletAddress: String

  public init(
    countryCode: String? = nil,
    countrySubdivisionCode: String? = nil,
    cryptoCurrencyCode: v1FiatOnRampCryptoCurrency,
    fiatCurrencyAmount: String? = nil,
    fiatCurrencyCode: v1FiatOnRampCurrency? = nil,
    network: v1FiatOnRampBlockchainNetwork,
    onrampProvider: v1FiatOnRampProvider,
    paymentMethod: v1FiatOnRampPaymentMethod? = nil,
    sandboxMode: Bool? = nil,
    urlForSignature: String? = nil,
    walletAddress: String
  ) {
    self.countryCode = countryCode
    self.countrySubdivisionCode = countrySubdivisionCode
    self.cryptoCurrencyCode = cryptoCurrencyCode
    self.fiatCurrencyAmount = fiatCurrencyAmount
    self.fiatCurrencyCode = fiatCurrencyCode
    self.network = network
    self.onrampProvider = onrampProvider
    self.paymentMethod = paymentMethod
    self.sandboxMode = sandboxMode
    self.urlForSignature = urlForSignature
    self.walletAddress = walletAddress
  }
}

public struct v1InitFiatOnRampRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1InitFiatOnRampIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1InitFiatOnRampIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1InitFiatOnRampResult: Codable, Sendable {
  /// Unique identifier used to retrieve transaction statuses for a given fiat on-ramp flow.
  public let onRampTransactionId: String
  /// Unique URL for a given fiat on-ramp flow.
  public let onRampUrl: String
  /// Optional signature of the MoonPay Widget URL. The signature is generated if the Init Fiat On Ramp intent includes the urlForSignature field. The signature can be used to initialize the MoonPay SDKs when URL signing is enabled for your project.
  public let onRampUrlSignature: String?

  public init(
    onRampTransactionId: String,
    onRampUrl: String,
    onRampUrlSignature: String? = nil
  ) {
    self.onRampTransactionId = onRampTransactionId
    self.onRampUrl = onRampUrl
    self.onRampUrlSignature = onRampUrlSignature
  }
}

public struct v1InitImportPrivateKeyIntent: Codable, Sendable {
  /// The ID of the User importing a Private Key.
  public let userId: String

  public init(
    userId: String
  ) {
    self.userId = userId
  }
}

public struct v1InitImportPrivateKeyRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1InitImportPrivateKeyIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1InitImportPrivateKeyIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1InitImportPrivateKeyResult: Codable, Sendable {
  /// Import bundle containing a public key and signature to use for importing client data.
  public let importBundle: String

  public init(
    importBundle: String
  ) {
    self.importBundle = importBundle
  }
}

public struct v1InitImportWalletIntent: Codable, Sendable {
  /// The ID of the User importing a Wallet.
  public let userId: String

  public init(
    userId: String
  ) {
    self.userId = userId
  }
}

public struct v1InitImportWalletRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1InitImportWalletIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1InitImportWalletIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1InitImportWalletResult: Codable, Sendable {
  /// Import bundle containing a public key and signature to use for importing client data.
  public let importBundle: String

  public init(
    importBundle: String
  ) {
    self.importBundle = importBundle
  }
}

public struct v1InitOtpAuthIntent: Codable, Sendable {
  /// Email or phone number to send the OTP code to
  public let contact: String
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomization: v1EmailCustomizationParams?
  /// Enum to specifiy whether to send OTP via SMS or email
  public let otpType: String
  /// Optional custom email address to use as reply-to
  public let replyToEmailAddress: String?
  /// Optional custom email address from which to send the OTP email
  public let sendFromEmailAddress: String?
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  public let sendFromEmailSenderName: String?
  /// Optional parameters for customizing SMS message. If not provided, the default sms message will be used.
  public let smsCustomization: v1SmsCustomizationParams?
  /// Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.
  public let userIdentifier: String?

  public init(
    contact: String,
    emailCustomization: v1EmailCustomizationParams? = nil,
    otpType: String,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    smsCustomization: v1SmsCustomizationParams? = nil,
    userIdentifier: String? = nil
  ) {
    self.contact = contact
    self.emailCustomization = emailCustomization
    self.otpType = otpType
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.smsCustomization = smsCustomization
    self.userIdentifier = userIdentifier
  }
}

public struct v1InitOtpAuthIntentV2: Codable, Sendable {
  /// Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true
  public let alphanumeric: Bool?
  /// Email or phone number to send the OTP code to
  public let contact: String
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomization: v1EmailCustomizationParams?
  /// Optional length of the OTP code. Default = 9
  public let otpLength: Int?
  /// Enum to specifiy whether to send OTP via SMS or email
  public let otpType: String
  /// Optional custom email address to use as reply-to
  public let replyToEmailAddress: String?
  /// Optional custom email address from which to send the OTP email
  public let sendFromEmailAddress: String?
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  public let sendFromEmailSenderName: String?
  /// Optional parameters for customizing SMS message. If not provided, the default sms message will be used.
  public let smsCustomization: v1SmsCustomizationParams?
  /// Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.
  public let userIdentifier: String?

  public init(
    alphanumeric: Bool? = nil,
    contact: String,
    emailCustomization: v1EmailCustomizationParams? = nil,
    otpLength: Int? = nil,
    otpType: String,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    smsCustomization: v1SmsCustomizationParams? = nil,
    userIdentifier: String? = nil
  ) {
    self.alphanumeric = alphanumeric
    self.contact = contact
    self.emailCustomization = emailCustomization
    self.otpLength = otpLength
    self.otpType = otpType
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.smsCustomization = smsCustomization
    self.userIdentifier = userIdentifier
  }
}

public struct v1InitOtpAuthIntentV3: Codable, Sendable {
  /// Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true
  public let alphanumeric: Bool?
  /// The name of the application.
  public let appName: String
  /// Email or phone number to send the OTP code to
  public let contact: String
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomization: v1EmailCustomizationParams?
  /// Optional length of the OTP code. Default = 9
  public let otpLength: Int?
  /// Enum to specifiy whether to send OTP via SMS or email
  public let otpType: String
  /// Optional custom email address to use as reply-to
  public let replyToEmailAddress: String?
  /// Optional custom email address from which to send the OTP email
  public let sendFromEmailAddress: String?
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  public let sendFromEmailSenderName: String?
  /// Optional parameters for customizing SMS message. If not provided, the default sms message will be used.
  public let smsCustomization: v1SmsCustomizationParams?
  /// Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.
  public let userIdentifier: String?

  public init(
    alphanumeric: Bool? = nil,
    appName: String,
    contact: String,
    emailCustomization: v1EmailCustomizationParams? = nil,
    otpLength: Int? = nil,
    otpType: String,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    smsCustomization: v1SmsCustomizationParams? = nil,
    userIdentifier: String? = nil
  ) {
    self.alphanumeric = alphanumeric
    self.appName = appName
    self.contact = contact
    self.emailCustomization = emailCustomization
    self.otpLength = otpLength
    self.otpType = otpType
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.smsCustomization = smsCustomization
    self.userIdentifier = userIdentifier
  }
}

public struct v1InitOtpAuthRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1InitOtpAuthIntentV3
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1InitOtpAuthIntentV3,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1InitOtpAuthResult: Codable, Sendable {
  /// Unique identifier for an OTP authentication
  public let otpId: String

  public init(
    otpId: String
  ) {
    self.otpId = otpId
  }
}

public struct v1InitOtpAuthResultV2: Codable, Sendable {
  /// Unique identifier for an OTP authentication
  public let otpId: String

  public init(
    otpId: String
  ) {
    self.otpId = otpId
  }
}

public struct v1InitOtpIntent: Codable, Sendable {
  /// Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true
  public let alphanumeric: Bool?
  /// Email or phone number to send the OTP code to
  public let contact: String
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomization: v1EmailCustomizationParams?
  /// Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes)
  public let expirationSeconds: String?
  /// Optional length of the OTP code. Default = 9
  public let otpLength: Int?
  /// Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL
  public let otpType: String
  /// Optional custom email address to use as reply-to
  public let replyToEmailAddress: String?
  /// Optional custom email address from which to send the OTP email
  public let sendFromEmailAddress: String?
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  public let sendFromEmailSenderName: String?
  /// Optional parameters for customizing SMS message. If not provided, the default sms message will be used.
  public let smsCustomization: v1SmsCustomizationParams?
  /// Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.
  public let userIdentifier: String?

  public init(
    alphanumeric: Bool? = nil,
    contact: String,
    emailCustomization: v1EmailCustomizationParams? = nil,
    expirationSeconds: String? = nil,
    otpLength: Int? = nil,
    otpType: String,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    smsCustomization: v1SmsCustomizationParams? = nil,
    userIdentifier: String? = nil
  ) {
    self.alphanumeric = alphanumeric
    self.contact = contact
    self.emailCustomization = emailCustomization
    self.expirationSeconds = expirationSeconds
    self.otpLength = otpLength
    self.otpType = otpType
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.smsCustomization = smsCustomization
    self.userIdentifier = userIdentifier
  }
}

public struct v1InitOtpIntentV2: Codable, Sendable {
  /// Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true
  public let alphanumeric: Bool?
  /// The name of the application.
  public let appName: String
  /// Email or phone number to send the OTP code to
  public let contact: String
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomization: v1EmailCustomizationParams?
  /// Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes)
  public let expirationSeconds: String?
  /// Optional length of the OTP code. Default = 9
  public let otpLength: Int?
  /// Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL
  public let otpType: String
  /// Optional custom email address to use as reply-to
  public let replyToEmailAddress: String?
  /// Optional custom email address from which to send the OTP email
  public let sendFromEmailAddress: String?
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  public let sendFromEmailSenderName: String?
  /// Optional parameters for customizing SMS message. If not provided, the default sms message will be used.
  public let smsCustomization: v1SmsCustomizationParams?
  /// Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.
  public let userIdentifier: String?

  public init(
    alphanumeric: Bool? = nil,
    appName: String,
    contact: String,
    emailCustomization: v1EmailCustomizationParams? = nil,
    expirationSeconds: String? = nil,
    otpLength: Int? = nil,
    otpType: String,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    smsCustomization: v1SmsCustomizationParams? = nil,
    userIdentifier: String? = nil
  ) {
    self.alphanumeric = alphanumeric
    self.appName = appName
    self.contact = contact
    self.emailCustomization = emailCustomization
    self.expirationSeconds = expirationSeconds
    self.otpLength = otpLength
    self.otpType = otpType
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.smsCustomization = smsCustomization
    self.userIdentifier = userIdentifier
  }
}

public struct v1InitOtpRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1InitOtpIntentV2
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1InitOtpIntentV2,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1InitOtpResult: Codable, Sendable {
  /// Unique identifier for an OTP authentication
  public let otpId: String

  public init(
    otpId: String
  ) {
    self.otpId = otpId
  }
}

public struct v1InitUserEmailRecoveryIntent: Codable, Sendable {
  /// Email of the user starting recovery
  public let email: String
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomization: v1EmailCustomizationParams?
  /// Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Optional custom email address to use as reply-to
  public let replyToEmailAddress: String?
  /// Optional custom email address from which to send the OTP email
  public let sendFromEmailAddress: String?
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  public let sendFromEmailSenderName: String?
  /// Client-side public key generated by the user, to which the recovery bundle will be encrypted.
  public let targetPublicKey: String

  public init(
    email: String,
    emailCustomization: v1EmailCustomizationParams? = nil,
    expirationSeconds: String? = nil,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    targetPublicKey: String
  ) {
    self.email = email
    self.emailCustomization = emailCustomization
    self.expirationSeconds = expirationSeconds
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.targetPublicKey = targetPublicKey
  }
}

public struct v1InitUserEmailRecoveryIntentV2: Codable, Sendable {
  /// The name of the application.
  public let appName: String
  /// Email of the user starting recovery
  public let email: String
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomization: v1EmailCustomizationParams?
  /// Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Optional custom email address to use as reply-to
  public let replyToEmailAddress: String?
  /// Optional custom email address from which to send the OTP email
  public let sendFromEmailAddress: String?
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  public let sendFromEmailSenderName: String?
  /// Client-side public key generated by the user, to which the recovery bundle will be encrypted.
  public let targetPublicKey: String

  public init(
    appName: String,
    email: String,
    emailCustomization: v1EmailCustomizationParams? = nil,
    expirationSeconds: String? = nil,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    targetPublicKey: String
  ) {
    self.appName = appName
    self.email = email
    self.emailCustomization = emailCustomization
    self.expirationSeconds = expirationSeconds
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.targetPublicKey = targetPublicKey
  }
}

public struct v1InitUserEmailRecoveryRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1InitUserEmailRecoveryIntentV2
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1InitUserEmailRecoveryIntentV2,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1InitUserEmailRecoveryResult: Codable, Sendable {
  /// Unique identifier for the user being recovered.
  public let userId: String

  public init(
    userId: String
  ) {
    self.userId = userId
  }
}

public struct v1Intent: Codable, Sendable {
  public let acceptInvitationIntent: v1AcceptInvitationIntent?
  public let acceptInvitationIntentV2: v1AcceptInvitationIntentV2?
  public let activateBillingTierIntent: billingActivateBillingTierIntent?
  public let approveActivityIntent: v1ApproveActivityIntent?
  public let createApiKeysIntent: v1CreateApiKeysIntent?
  public let createApiKeysIntentV2: v1CreateApiKeysIntentV2?
  public let createApiOnlyUsersIntent: v1CreateApiOnlyUsersIntent?
  public let createAuthenticatorsIntent: v1CreateAuthenticatorsIntent?
  public let createAuthenticatorsIntentV2: v1CreateAuthenticatorsIntentV2?
  public let createFiatOnRampCredentialIntent: v1CreateFiatOnRampCredentialIntent?
  public let createInvitationsIntent: v1CreateInvitationsIntent?
  public let createOauth2CredentialIntent: v1CreateOauth2CredentialIntent?
  public let createOauthProvidersIntent: v1CreateOauthProvidersIntent?
  public let createOrganizationIntent: v1CreateOrganizationIntent?
  public let createOrganizationIntentV2: v1CreateOrganizationIntentV2?
  public let createPoliciesIntent: v1CreatePoliciesIntent?
  public let createPolicyIntent: v1CreatePolicyIntent?
  public let createPolicyIntentV2: v1CreatePolicyIntentV2?
  public let createPolicyIntentV3: v1CreatePolicyIntentV3?
  public let createPrivateKeyTagIntent: v1CreatePrivateKeyTagIntent?
  public let createPrivateKeysIntent: v1CreatePrivateKeysIntent?
  public let createPrivateKeysIntentV2: v1CreatePrivateKeysIntentV2?
  public let createReadOnlySessionIntent: v1CreateReadOnlySessionIntent?
  public let createReadWriteSessionIntent: v1CreateReadWriteSessionIntent?
  public let createReadWriteSessionIntentV2: v1CreateReadWriteSessionIntentV2?
  public let createSmartContractInterfaceIntent: v1CreateSmartContractInterfaceIntent?
  public let createSubOrganizationIntent: v1CreateSubOrganizationIntent?
  public let createSubOrganizationIntentV2: v1CreateSubOrganizationIntentV2?
  public let createSubOrganizationIntentV3: v1CreateSubOrganizationIntentV3?
  public let createSubOrganizationIntentV4: v1CreateSubOrganizationIntentV4?
  public let createSubOrganizationIntentV5: v1CreateSubOrganizationIntentV5?
  public let createSubOrganizationIntentV6: v1CreateSubOrganizationIntentV6?
  public let createSubOrganizationIntentV7: v1CreateSubOrganizationIntentV7?
  public let createUserTagIntent: v1CreateUserTagIntent?
  public let createUsersIntent: v1CreateUsersIntent?
  public let createUsersIntentV2: v1CreateUsersIntentV2?
  public let createUsersIntentV3: v1CreateUsersIntentV3?
  public let createWalletAccountsIntent: v1CreateWalletAccountsIntent?
  public let createWalletIntent: v1CreateWalletIntent?
  public let deleteApiKeysIntent: v1DeleteApiKeysIntent?
  public let deleteAuthenticatorsIntent: v1DeleteAuthenticatorsIntent?
  public let deleteFiatOnRampCredentialIntent: v1DeleteFiatOnRampCredentialIntent?
  public let deleteInvitationIntent: v1DeleteInvitationIntent?
  public let deleteOauth2CredentialIntent: v1DeleteOauth2CredentialIntent?
  public let deleteOauthProvidersIntent: v1DeleteOauthProvidersIntent?
  public let deleteOrganizationIntent: v1DeleteOrganizationIntent?
  public let deletePaymentMethodIntent: billingDeletePaymentMethodIntent?
  public let deletePoliciesIntent: v1DeletePoliciesIntent?
  public let deletePolicyIntent: v1DeletePolicyIntent?
  public let deletePrivateKeyTagsIntent: v1DeletePrivateKeyTagsIntent?
  public let deletePrivateKeysIntent: v1DeletePrivateKeysIntent?
  public let deleteSmartContractInterfaceIntent: v1DeleteSmartContractInterfaceIntent?
  public let deleteSubOrganizationIntent: v1DeleteSubOrganizationIntent?
  public let deleteUserTagsIntent: v1DeleteUserTagsIntent?
  public let deleteUsersIntent: v1DeleteUsersIntent?
  public let deleteWalletAccountsIntent: v1DeleteWalletAccountsIntent?
  public let deleteWalletsIntent: v1DeleteWalletsIntent?
  public let disableAuthProxyIntent: v1DisableAuthProxyIntent?
  public let disablePrivateKeyIntent: v1DisablePrivateKeyIntent?
  public let emailAuthIntent: v1EmailAuthIntent?
  public let emailAuthIntentV2: v1EmailAuthIntentV2?
  public let emailAuthIntentV3: v1EmailAuthIntentV3?
  public let enableAuthProxyIntent: v1EnableAuthProxyIntent?
  public let ethSendRawTransactionIntent: v1EthSendRawTransactionIntent?
  public let ethSendTransactionIntent: v1EthSendTransactionIntent?
  public let exportPrivateKeyIntent: v1ExportPrivateKeyIntent?
  public let exportWalletAccountIntent: v1ExportWalletAccountIntent?
  public let exportWalletIntent: v1ExportWalletIntent?
  public let importPrivateKeyIntent: v1ImportPrivateKeyIntent?
  public let importWalletIntent: v1ImportWalletIntent?
  public let initFiatOnRampIntent: v1InitFiatOnRampIntent?
  public let initImportPrivateKeyIntent: v1InitImportPrivateKeyIntent?
  public let initImportWalletIntent: v1InitImportWalletIntent?
  public let initOtpAuthIntent: v1InitOtpAuthIntent?
  public let initOtpAuthIntentV2: v1InitOtpAuthIntentV2?
  public let initOtpAuthIntentV3: v1InitOtpAuthIntentV3?
  public let initOtpIntent: v1InitOtpIntent?
  public let initOtpIntentV2: v1InitOtpIntentV2?
  public let initUserEmailRecoveryIntent: v1InitUserEmailRecoveryIntent?
  public let initUserEmailRecoveryIntentV2: v1InitUserEmailRecoveryIntentV2?
  public let oauth2AuthenticateIntent: v1Oauth2AuthenticateIntent?
  public let oauthIntent: v1OauthIntent?
  public let oauthLoginIntent: v1OauthLoginIntent?
  public let otpAuthIntent: v1OtpAuthIntent?
  public let otpLoginIntent: v1OtpLoginIntent?
  public let recoverUserIntent: v1RecoverUserIntent?
  public let rejectActivityIntent: v1RejectActivityIntent?
  public let removeOrganizationFeatureIntent: v1RemoveOrganizationFeatureIntent?
  public let setOrganizationFeatureIntent: v1SetOrganizationFeatureIntent?
  public let setPaymentMethodIntent: billingSetPaymentMethodIntent?
  public let setPaymentMethodIntentV2: billingSetPaymentMethodIntentV2?
  public let signRawPayloadIntent: v1SignRawPayloadIntent?
  public let signRawPayloadIntentV2: v1SignRawPayloadIntentV2?
  public let signRawPayloadsIntent: v1SignRawPayloadsIntent?
  public let signTransactionIntent: v1SignTransactionIntent?
  public let signTransactionIntentV2: v1SignTransactionIntentV2?
  public let stampLoginIntent: v1StampLoginIntent?
  public let updateAllowedOriginsIntent: v1UpdateAllowedOriginsIntent?
  public let updateAuthProxyConfigIntent: v1UpdateAuthProxyConfigIntent?
  public let updateFiatOnRampCredentialIntent: v1UpdateFiatOnRampCredentialIntent?
  public let updateOauth2CredentialIntent: v1UpdateOauth2CredentialIntent?
  public let updatePolicyIntent: v1UpdatePolicyIntent?
  public let updatePolicyIntentV2: v1UpdatePolicyIntentV2?
  public let updatePrivateKeyTagIntent: v1UpdatePrivateKeyTagIntent?
  public let updateRootQuorumIntent: v1UpdateRootQuorumIntent?
  public let updateUserEmailIntent: v1UpdateUserEmailIntent?
  public let updateUserIntent: v1UpdateUserIntent?
  public let updateUserNameIntent: v1UpdateUserNameIntent?
  public let updateUserPhoneNumberIntent: v1UpdateUserPhoneNumberIntent?
  public let updateUserTagIntent: v1UpdateUserTagIntent?
  public let updateWalletIntent: v1UpdateWalletIntent?
  public let verifyOtpIntent: v1VerifyOtpIntent?

  public init(
    acceptInvitationIntent: v1AcceptInvitationIntent? = nil,
    acceptInvitationIntentV2: v1AcceptInvitationIntentV2? = nil,
    activateBillingTierIntent: billingActivateBillingTierIntent? = nil,
    approveActivityIntent: v1ApproveActivityIntent? = nil,
    createApiKeysIntent: v1CreateApiKeysIntent? = nil,
    createApiKeysIntentV2: v1CreateApiKeysIntentV2? = nil,
    createApiOnlyUsersIntent: v1CreateApiOnlyUsersIntent? = nil,
    createAuthenticatorsIntent: v1CreateAuthenticatorsIntent? = nil,
    createAuthenticatorsIntentV2: v1CreateAuthenticatorsIntentV2? = nil,
    createFiatOnRampCredentialIntent: v1CreateFiatOnRampCredentialIntent? = nil,
    createInvitationsIntent: v1CreateInvitationsIntent? = nil,
    createOauth2CredentialIntent: v1CreateOauth2CredentialIntent? = nil,
    createOauthProvidersIntent: v1CreateOauthProvidersIntent? = nil,
    createOrganizationIntent: v1CreateOrganizationIntent? = nil,
    createOrganizationIntentV2: v1CreateOrganizationIntentV2? = nil,
    createPoliciesIntent: v1CreatePoliciesIntent? = nil,
    createPolicyIntent: v1CreatePolicyIntent? = nil,
    createPolicyIntentV2: v1CreatePolicyIntentV2? = nil,
    createPolicyIntentV3: v1CreatePolicyIntentV3? = nil,
    createPrivateKeyTagIntent: v1CreatePrivateKeyTagIntent? = nil,
    createPrivateKeysIntent: v1CreatePrivateKeysIntent? = nil,
    createPrivateKeysIntentV2: v1CreatePrivateKeysIntentV2? = nil,
    createReadOnlySessionIntent: v1CreateReadOnlySessionIntent? = nil,
    createReadWriteSessionIntent: v1CreateReadWriteSessionIntent? = nil,
    createReadWriteSessionIntentV2: v1CreateReadWriteSessionIntentV2? = nil,
    createSmartContractInterfaceIntent: v1CreateSmartContractInterfaceIntent? = nil,
    createSubOrganizationIntent: v1CreateSubOrganizationIntent? = nil,
    createSubOrganizationIntentV2: v1CreateSubOrganizationIntentV2? = nil,
    createSubOrganizationIntentV3: v1CreateSubOrganizationIntentV3? = nil,
    createSubOrganizationIntentV4: v1CreateSubOrganizationIntentV4? = nil,
    createSubOrganizationIntentV5: v1CreateSubOrganizationIntentV5? = nil,
    createSubOrganizationIntentV6: v1CreateSubOrganizationIntentV6? = nil,
    createSubOrganizationIntentV7: v1CreateSubOrganizationIntentV7? = nil,
    createUserTagIntent: v1CreateUserTagIntent? = nil,
    createUsersIntent: v1CreateUsersIntent? = nil,
    createUsersIntentV2: v1CreateUsersIntentV2? = nil,
    createUsersIntentV3: v1CreateUsersIntentV3? = nil,
    createWalletAccountsIntent: v1CreateWalletAccountsIntent? = nil,
    createWalletIntent: v1CreateWalletIntent? = nil,
    deleteApiKeysIntent: v1DeleteApiKeysIntent? = nil,
    deleteAuthenticatorsIntent: v1DeleteAuthenticatorsIntent? = nil,
    deleteFiatOnRampCredentialIntent: v1DeleteFiatOnRampCredentialIntent? = nil,
    deleteInvitationIntent: v1DeleteInvitationIntent? = nil,
    deleteOauth2CredentialIntent: v1DeleteOauth2CredentialIntent? = nil,
    deleteOauthProvidersIntent: v1DeleteOauthProvidersIntent? = nil,
    deleteOrganizationIntent: v1DeleteOrganizationIntent? = nil,
    deletePaymentMethodIntent: billingDeletePaymentMethodIntent? = nil,
    deletePoliciesIntent: v1DeletePoliciesIntent? = nil,
    deletePolicyIntent: v1DeletePolicyIntent? = nil,
    deletePrivateKeyTagsIntent: v1DeletePrivateKeyTagsIntent? = nil,
    deletePrivateKeysIntent: v1DeletePrivateKeysIntent? = nil,
    deleteSmartContractInterfaceIntent: v1DeleteSmartContractInterfaceIntent? = nil,
    deleteSubOrganizationIntent: v1DeleteSubOrganizationIntent? = nil,
    deleteUserTagsIntent: v1DeleteUserTagsIntent? = nil,
    deleteUsersIntent: v1DeleteUsersIntent? = nil,
    deleteWalletAccountsIntent: v1DeleteWalletAccountsIntent? = nil,
    deleteWalletsIntent: v1DeleteWalletsIntent? = nil,
    disableAuthProxyIntent: v1DisableAuthProxyIntent? = nil,
    disablePrivateKeyIntent: v1DisablePrivateKeyIntent? = nil,
    emailAuthIntent: v1EmailAuthIntent? = nil,
    emailAuthIntentV2: v1EmailAuthIntentV2? = nil,
    emailAuthIntentV3: v1EmailAuthIntentV3? = nil,
    enableAuthProxyIntent: v1EnableAuthProxyIntent? = nil,
    ethSendRawTransactionIntent: v1EthSendRawTransactionIntent? = nil,
    ethSendTransactionIntent: v1EthSendTransactionIntent? = nil,
    exportPrivateKeyIntent: v1ExportPrivateKeyIntent? = nil,
    exportWalletAccountIntent: v1ExportWalletAccountIntent? = nil,
    exportWalletIntent: v1ExportWalletIntent? = nil,
    importPrivateKeyIntent: v1ImportPrivateKeyIntent? = nil,
    importWalletIntent: v1ImportWalletIntent? = nil,
    initFiatOnRampIntent: v1InitFiatOnRampIntent? = nil,
    initImportPrivateKeyIntent: v1InitImportPrivateKeyIntent? = nil,
    initImportWalletIntent: v1InitImportWalletIntent? = nil,
    initOtpAuthIntent: v1InitOtpAuthIntent? = nil,
    initOtpAuthIntentV2: v1InitOtpAuthIntentV2? = nil,
    initOtpAuthIntentV3: v1InitOtpAuthIntentV3? = nil,
    initOtpIntent: v1InitOtpIntent? = nil,
    initOtpIntentV2: v1InitOtpIntentV2? = nil,
    initUserEmailRecoveryIntent: v1InitUserEmailRecoveryIntent? = nil,
    initUserEmailRecoveryIntentV2: v1InitUserEmailRecoveryIntentV2? = nil,
    oauth2AuthenticateIntent: v1Oauth2AuthenticateIntent? = nil,
    oauthIntent: v1OauthIntent? = nil,
    oauthLoginIntent: v1OauthLoginIntent? = nil,
    otpAuthIntent: v1OtpAuthIntent? = nil,
    otpLoginIntent: v1OtpLoginIntent? = nil,
    recoverUserIntent: v1RecoverUserIntent? = nil,
    rejectActivityIntent: v1RejectActivityIntent? = nil,
    removeOrganizationFeatureIntent: v1RemoveOrganizationFeatureIntent? = nil,
    setOrganizationFeatureIntent: v1SetOrganizationFeatureIntent? = nil,
    setPaymentMethodIntent: billingSetPaymentMethodIntent? = nil,
    setPaymentMethodIntentV2: billingSetPaymentMethodIntentV2? = nil,
    signRawPayloadIntent: v1SignRawPayloadIntent? = nil,
    signRawPayloadIntentV2: v1SignRawPayloadIntentV2? = nil,
    signRawPayloadsIntent: v1SignRawPayloadsIntent? = nil,
    signTransactionIntent: v1SignTransactionIntent? = nil,
    signTransactionIntentV2: v1SignTransactionIntentV2? = nil,
    stampLoginIntent: v1StampLoginIntent? = nil,
    updateAllowedOriginsIntent: v1UpdateAllowedOriginsIntent? = nil,
    updateAuthProxyConfigIntent: v1UpdateAuthProxyConfigIntent? = nil,
    updateFiatOnRampCredentialIntent: v1UpdateFiatOnRampCredentialIntent? = nil,
    updateOauth2CredentialIntent: v1UpdateOauth2CredentialIntent? = nil,
    updatePolicyIntent: v1UpdatePolicyIntent? = nil,
    updatePolicyIntentV2: v1UpdatePolicyIntentV2? = nil,
    updatePrivateKeyTagIntent: v1UpdatePrivateKeyTagIntent? = nil,
    updateRootQuorumIntent: v1UpdateRootQuorumIntent? = nil,
    updateUserEmailIntent: v1UpdateUserEmailIntent? = nil,
    updateUserIntent: v1UpdateUserIntent? = nil,
    updateUserNameIntent: v1UpdateUserNameIntent? = nil,
    updateUserPhoneNumberIntent: v1UpdateUserPhoneNumberIntent? = nil,
    updateUserTagIntent: v1UpdateUserTagIntent? = nil,
    updateWalletIntent: v1UpdateWalletIntent? = nil,
    verifyOtpIntent: v1VerifyOtpIntent? = nil
  ) {
    self.acceptInvitationIntent = acceptInvitationIntent
    self.acceptInvitationIntentV2 = acceptInvitationIntentV2
    self.activateBillingTierIntent = activateBillingTierIntent
    self.approveActivityIntent = approveActivityIntent
    self.createApiKeysIntent = createApiKeysIntent
    self.createApiKeysIntentV2 = createApiKeysIntentV2
    self.createApiOnlyUsersIntent = createApiOnlyUsersIntent
    self.createAuthenticatorsIntent = createAuthenticatorsIntent
    self.createAuthenticatorsIntentV2 = createAuthenticatorsIntentV2
    self.createFiatOnRampCredentialIntent = createFiatOnRampCredentialIntent
    self.createInvitationsIntent = createInvitationsIntent
    self.createOauth2CredentialIntent = createOauth2CredentialIntent
    self.createOauthProvidersIntent = createOauthProvidersIntent
    self.createOrganizationIntent = createOrganizationIntent
    self.createOrganizationIntentV2 = createOrganizationIntentV2
    self.createPoliciesIntent = createPoliciesIntent
    self.createPolicyIntent = createPolicyIntent
    self.createPolicyIntentV2 = createPolicyIntentV2
    self.createPolicyIntentV3 = createPolicyIntentV3
    self.createPrivateKeyTagIntent = createPrivateKeyTagIntent
    self.createPrivateKeysIntent = createPrivateKeysIntent
    self.createPrivateKeysIntentV2 = createPrivateKeysIntentV2
    self.createReadOnlySessionIntent = createReadOnlySessionIntent
    self.createReadWriteSessionIntent = createReadWriteSessionIntent
    self.createReadWriteSessionIntentV2 = createReadWriteSessionIntentV2
    self.createSmartContractInterfaceIntent = createSmartContractInterfaceIntent
    self.createSubOrganizationIntent = createSubOrganizationIntent
    self.createSubOrganizationIntentV2 = createSubOrganizationIntentV2
    self.createSubOrganizationIntentV3 = createSubOrganizationIntentV3
    self.createSubOrganizationIntentV4 = createSubOrganizationIntentV4
    self.createSubOrganizationIntentV5 = createSubOrganizationIntentV5
    self.createSubOrganizationIntentV6 = createSubOrganizationIntentV6
    self.createSubOrganizationIntentV7 = createSubOrganizationIntentV7
    self.createUserTagIntent = createUserTagIntent
    self.createUsersIntent = createUsersIntent
    self.createUsersIntentV2 = createUsersIntentV2
    self.createUsersIntentV3 = createUsersIntentV3
    self.createWalletAccountsIntent = createWalletAccountsIntent
    self.createWalletIntent = createWalletIntent
    self.deleteApiKeysIntent = deleteApiKeysIntent
    self.deleteAuthenticatorsIntent = deleteAuthenticatorsIntent
    self.deleteFiatOnRampCredentialIntent = deleteFiatOnRampCredentialIntent
    self.deleteInvitationIntent = deleteInvitationIntent
    self.deleteOauth2CredentialIntent = deleteOauth2CredentialIntent
    self.deleteOauthProvidersIntent = deleteOauthProvidersIntent
    self.deleteOrganizationIntent = deleteOrganizationIntent
    self.deletePaymentMethodIntent = deletePaymentMethodIntent
    self.deletePoliciesIntent = deletePoliciesIntent
    self.deletePolicyIntent = deletePolicyIntent
    self.deletePrivateKeyTagsIntent = deletePrivateKeyTagsIntent
    self.deletePrivateKeysIntent = deletePrivateKeysIntent
    self.deleteSmartContractInterfaceIntent = deleteSmartContractInterfaceIntent
    self.deleteSubOrganizationIntent = deleteSubOrganizationIntent
    self.deleteUserTagsIntent = deleteUserTagsIntent
    self.deleteUsersIntent = deleteUsersIntent
    self.deleteWalletAccountsIntent = deleteWalletAccountsIntent
    self.deleteWalletsIntent = deleteWalletsIntent
    self.disableAuthProxyIntent = disableAuthProxyIntent
    self.disablePrivateKeyIntent = disablePrivateKeyIntent
    self.emailAuthIntent = emailAuthIntent
    self.emailAuthIntentV2 = emailAuthIntentV2
    self.emailAuthIntentV3 = emailAuthIntentV3
    self.enableAuthProxyIntent = enableAuthProxyIntent
    self.ethSendRawTransactionIntent = ethSendRawTransactionIntent
    self.ethSendTransactionIntent = ethSendTransactionIntent
    self.exportPrivateKeyIntent = exportPrivateKeyIntent
    self.exportWalletAccountIntent = exportWalletAccountIntent
    self.exportWalletIntent = exportWalletIntent
    self.importPrivateKeyIntent = importPrivateKeyIntent
    self.importWalletIntent = importWalletIntent
    self.initFiatOnRampIntent = initFiatOnRampIntent
    self.initImportPrivateKeyIntent = initImportPrivateKeyIntent
    self.initImportWalletIntent = initImportWalletIntent
    self.initOtpAuthIntent = initOtpAuthIntent
    self.initOtpAuthIntentV2 = initOtpAuthIntentV2
    self.initOtpAuthIntentV3 = initOtpAuthIntentV3
    self.initOtpIntent = initOtpIntent
    self.initOtpIntentV2 = initOtpIntentV2
    self.initUserEmailRecoveryIntent = initUserEmailRecoveryIntent
    self.initUserEmailRecoveryIntentV2 = initUserEmailRecoveryIntentV2
    self.oauth2AuthenticateIntent = oauth2AuthenticateIntent
    self.oauthIntent = oauthIntent
    self.oauthLoginIntent = oauthLoginIntent
    self.otpAuthIntent = otpAuthIntent
    self.otpLoginIntent = otpLoginIntent
    self.recoverUserIntent = recoverUserIntent
    self.rejectActivityIntent = rejectActivityIntent
    self.removeOrganizationFeatureIntent = removeOrganizationFeatureIntent
    self.setOrganizationFeatureIntent = setOrganizationFeatureIntent
    self.setPaymentMethodIntent = setPaymentMethodIntent
    self.setPaymentMethodIntentV2 = setPaymentMethodIntentV2
    self.signRawPayloadIntent = signRawPayloadIntent
    self.signRawPayloadIntentV2 = signRawPayloadIntentV2
    self.signRawPayloadsIntent = signRawPayloadsIntent
    self.signTransactionIntent = signTransactionIntent
    self.signTransactionIntentV2 = signTransactionIntentV2
    self.stampLoginIntent = stampLoginIntent
    self.updateAllowedOriginsIntent = updateAllowedOriginsIntent
    self.updateAuthProxyConfigIntent = updateAuthProxyConfigIntent
    self.updateFiatOnRampCredentialIntent = updateFiatOnRampCredentialIntent
    self.updateOauth2CredentialIntent = updateOauth2CredentialIntent
    self.updatePolicyIntent = updatePolicyIntent
    self.updatePolicyIntentV2 = updatePolicyIntentV2
    self.updatePrivateKeyTagIntent = updatePrivateKeyTagIntent
    self.updateRootQuorumIntent = updateRootQuorumIntent
    self.updateUserEmailIntent = updateUserEmailIntent
    self.updateUserIntent = updateUserIntent
    self.updateUserNameIntent = updateUserNameIntent
    self.updateUserPhoneNumberIntent = updateUserPhoneNumberIntent
    self.updateUserTagIntent = updateUserTagIntent
    self.updateWalletIntent = updateWalletIntent
    self.verifyOtpIntent = verifyOtpIntent
  }
}

public struct v1Invitation: Codable, Sendable {
  /// The User's permissible access method(s).
  public let accessType: v1AccessType
  public let createdAt: externaldatav1Timestamp
  /// Unique identifier for a given Invitation object.
  public let invitationId: String
  /// The email address of the intended Invitation recipient.
  public let receiverEmail: String
  /// The name of the intended Invitation recipient.
  public let receiverUserName: String
  /// A list of tags assigned to the Invitation recipient.
  public let receiverUserTags: [String]
  /// Unique identifier for the Sender of an Invitation.
  public let senderUserId: String
  /// The current processing status of a specified Invitation.
  public let status: v1InvitationStatus
  public let updatedAt: externaldatav1Timestamp

  public init(
    accessType: v1AccessType,
    createdAt: externaldatav1Timestamp,
    invitationId: String,
    receiverEmail: String,
    receiverUserName: String,
    receiverUserTags: [String],
    senderUserId: String,
    status: v1InvitationStatus,
    updatedAt: externaldatav1Timestamp
  ) {
    self.accessType = accessType
    self.createdAt = createdAt
    self.invitationId = invitationId
    self.receiverEmail = receiverEmail
    self.receiverUserName = receiverUserName
    self.receiverUserTags = receiverUserTags
    self.senderUserId = senderUserId
    self.status = status
    self.updatedAt = updatedAt
  }
}

public struct v1InvitationParams: Codable, Sendable {
  /// The User's permissible access method(s).
  public let accessType: v1AccessType
  /// The email address of the intended Invitation recipient.
  public let receiverUserEmail: String
  /// The name of the intended Invitation recipient.
  public let receiverUserName: String
  /// A list of tags assigned to the Invitation recipient. This field, if not needed, should be an empty array in your request body.
  public let receiverUserTags: [String]
  /// Unique identifier for the Sender of an Invitation.
  public let senderUserId: String

  public init(
    accessType: v1AccessType,
    receiverUserEmail: String,
    receiverUserName: String,
    receiverUserTags: [String],
    senderUserId: String
  ) {
    self.accessType = accessType
    self.receiverUserEmail = receiverUserEmail
    self.receiverUserName = receiverUserName
    self.receiverUserTags = receiverUserTags
    self.senderUserId = senderUserId
  }
}

public enum v1InvitationStatus: String, Codable, Sendable {
  case invitation_status_created = "INVITATION_STATUS_CREATED"
  case invitation_status_accepted = "INVITATION_STATUS_ACCEPTED"
  case invitation_status_revoked = "INVITATION_STATUS_REVOKED"
}

public struct v1ListFiatOnRampCredentialsRequest: Codable, Sendable {
  /// Unique identifier for a given Organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1ListFiatOnRampCredentialsResponse: Codable, Sendable {
  public let fiatOnRampCredentials: [v1FiatOnRampCredential]

  public init(
    fiatOnRampCredentials: [v1FiatOnRampCredential]
  ) {
    self.fiatOnRampCredentials = fiatOnRampCredentials
  }
}

public struct v1ListOauth2CredentialsRequest: Codable, Sendable {
  /// Unique identifier for a given Organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1ListOauth2CredentialsResponse: Codable, Sendable {
  public let oauth2Credentials: [v1Oauth2Credential]

  public init(
    oauth2Credentials: [v1Oauth2Credential]
  ) {
    self.oauth2Credentials = oauth2Credentials
  }
}

public struct v1ListPrivateKeyTagsRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1ListPrivateKeyTagsResponse: Codable, Sendable {
  /// A list of private key tags.
  public let privateKeyTags: [datav1Tag]

  public init(
    privateKeyTags: [datav1Tag]
  ) {
    self.privateKeyTags = privateKeyTags
  }
}

public struct v1ListUserTagsRequest: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String

  public init(
    organizationId: String
  ) {
    self.organizationId = organizationId
  }
}

public struct v1ListUserTagsResponse: Codable, Sendable {
  /// A list of user tags.
  public let userTags: [datav1Tag]

  public init(
    userTags: [datav1Tag]
  ) {
    self.userTags = userTags
  }
}

public struct v1LoginUsage: Codable, Sendable {
  /// Public key for authentication
  public let publicKey: String

  public init(
    publicKey: String
  ) {
    self.publicKey = publicKey
  }
}

public enum v1MnemonicLanguage: String, Codable, Sendable {
  case mnemonic_language_english = "MNEMONIC_LANGUAGE_ENGLISH"
  case mnemonic_language_simplified_chinese = "MNEMONIC_LANGUAGE_SIMPLIFIED_CHINESE"
  case mnemonic_language_traditional_chinese = "MNEMONIC_LANGUAGE_TRADITIONAL_CHINESE"
  case mnemonic_language_czech = "MNEMONIC_LANGUAGE_CZECH"
  case mnemonic_language_french = "MNEMONIC_LANGUAGE_FRENCH"
  case mnemonic_language_italian = "MNEMONIC_LANGUAGE_ITALIAN"
  case mnemonic_language_japanese = "MNEMONIC_LANGUAGE_JAPANESE"
  case mnemonic_language_korean = "MNEMONIC_LANGUAGE_KOREAN"
  case mnemonic_language_spanish = "MNEMONIC_LANGUAGE_SPANISH"
}

public struct v1NOOPCodegenAnchorResponse: Codable, Sendable {
  public let stamp: v1WebAuthnStamp
  public let tokenUsage: v1TokenUsage?

  public init(
    stamp: v1WebAuthnStamp,
    tokenUsage: v1TokenUsage? = nil
  ) {
    self.stamp = stamp
    self.tokenUsage = tokenUsage
  }
}

public struct v1Oauth2AuthenticateIntent: Codable, Sendable {
  /// The auth_code provided by the OAuth 2.0 provider to the end user to be exchanged for a Bearer token in the OAuth 2.0 flow
  public let authCode: String
  /// An optional P256 public key to which, if provided, the bearer token will be encrypted and returned via the `encrypted_bearer_token` claim of the OIDC Token
  public let bearerTokenTargetPublicKey: String?
  /// The code verifier used by OAuth 2.0 PKCE providers
  public let codeVerifier: String
  /// An optional nonce used by the client to prevent replay/substitution of an ID token
  public let nonce: String?
  /// The OAuth 2.0 credential id whose client_id and client_secret will be used in the OAuth 2.0 flow
  public let oauth2CredentialId: String
  /// The URI the user is redirected to after they have authenticated with the OAuth 2.0 provider
  public let redirectUri: String

  public init(
    authCode: String,
    bearerTokenTargetPublicKey: String? = nil,
    codeVerifier: String,
    nonce: String? = nil,
    oauth2CredentialId: String,
    redirectUri: String
  ) {
    self.authCode = authCode
    self.bearerTokenTargetPublicKey = bearerTokenTargetPublicKey
    self.codeVerifier = codeVerifier
    self.nonce = nonce
    self.oauth2CredentialId = oauth2CredentialId
    self.redirectUri = redirectUri
  }
}

public struct v1Oauth2AuthenticateRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1Oauth2AuthenticateIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1Oauth2AuthenticateIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1Oauth2AuthenticateResult: Codable, Sendable {
  /// Base64 encoded OIDC token issued by Turnkey to be used with the LoginWithOAuth activity
  public let oidcToken: String

  public init(
    oidcToken: String
  ) {
    self.oidcToken = oidcToken
  }
}

public struct v1Oauth2Credential: Codable, Sendable {
  /// The client id for a given OAuth 2.0 Credential.
  public let clientId: String
  public let createdAt: externaldatav1Timestamp
  /// The encrypted client secret for a given OAuth 2.0 Credential encrypted to the TLS Fetcher quorum key.
  public let encryptedClientSecret: String
  /// Unique identifier for a given OAuth 2.0 Credential.
  public let oauth2CredentialId: String
  /// Unique identifier for an Organization.
  public let organizationId: String
  /// The provider for a given OAuth 2.0 Credential.
  public let provider: v1Oauth2Provider
  public let updatedAt: externaldatav1Timestamp

  public init(
    clientId: String,
    createdAt: externaldatav1Timestamp,
    encryptedClientSecret: String,
    oauth2CredentialId: String,
    organizationId: String,
    provider: v1Oauth2Provider,
    updatedAt: externaldatav1Timestamp
  ) {
    self.clientId = clientId
    self.createdAt = createdAt
    self.encryptedClientSecret = encryptedClientSecret
    self.oauth2CredentialId = oauth2CredentialId
    self.organizationId = organizationId
    self.provider = provider
    self.updatedAt = updatedAt
  }
}

public enum v1Oauth2Provider: String, Codable, Sendable {
  case oauth2_provider_x = "OAUTH2_PROVIDER_X"
  case oauth2_provider_discord = "OAUTH2_PROVIDER_DISCORD"
}

public struct v1OauthIntent: Codable, Sendable {
  /// Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp>
  public let apiKeyName: String?
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated Oauth API keys
  public let invalidateExisting: Bool?
  /// Base64 encoded OIDC token
  public let oidcToken: String
  /// Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted.
  public let targetPublicKey: String

  public init(
    apiKeyName: String? = nil,
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    oidcToken: String,
    targetPublicKey: String
  ) {
    self.apiKeyName = apiKeyName
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.oidcToken = oidcToken
    self.targetPublicKey = targetPublicKey
  }
}

public struct v1OauthLoginIntent: Codable, Sendable {
  /// Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated Login API keys
  public let invalidateExisting: Bool?
  /// Base64 encoded OIDC token
  public let oidcToken: String
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request
  public let publicKey: String

  public init(
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    oidcToken: String,
    publicKey: String
  ) {
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.oidcToken = oidcToken
    self.publicKey = publicKey
  }
}

public struct v1OauthLoginRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1OauthLoginIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1OauthLoginIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1OauthLoginResult: Codable, Sendable {
  /// Signed JWT containing an expiry, public key, session type, user id, and organization id
  public let session: String

  public init(
    session: String
  ) {
    self.session = session
  }
}

public struct v1OauthProvider: Codable, Sendable {
  /// Expected audience ('aud' attribute of the signed token) which represents the app ID
  public let audience: String
  public let createdAt: externaldatav1Timestamp
  /// The issuer of the token, typically a URL indicating the authentication server, e.g https://accounts.google.com
  public let issuer: String
  /// Unique identifier for an OAuth Provider
  public let providerId: String
  /// Human-readable name to identify a Provider.
  public let providerName: String
  /// Expected subject ('sub' attribute of the signed token) which represents the user ID
  public let subject: String
  public let updatedAt: externaldatav1Timestamp

  public init(
    audience: String,
    createdAt: externaldatav1Timestamp,
    issuer: String,
    providerId: String,
    providerName: String,
    subject: String,
    updatedAt: externaldatav1Timestamp
  ) {
    self.audience = audience
    self.createdAt = createdAt
    self.issuer = issuer
    self.providerId = providerId
    self.providerName = providerName
    self.subject = subject
    self.updatedAt = updatedAt
  }
}

public struct v1OauthProviderParams: Codable, Sendable {
  /// Base64 encoded OIDC token
  public let oidcToken: String
  /// Human-readable name to identify a Provider.
  public let providerName: String

  public init(
    oidcToken: String,
    providerName: String
  ) {
    self.oidcToken = oidcToken
    self.providerName = providerName
  }
}

public struct v1OauthRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1OauthIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1OauthIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1OauthResult: Codable, Sendable {
  /// Unique identifier for the created API key.
  public let apiKeyId: String
  /// HPKE encrypted credential bundle
  public let credentialBundle: String
  /// Unique identifier for the authenticating User.
  public let userId: String

  public init(
    apiKeyId: String,
    credentialBundle: String,
    userId: String
  ) {
    self.apiKeyId = apiKeyId
    self.credentialBundle = credentialBundle
    self.userId = userId
  }
}

public enum v1Operator: String, Codable, Sendable {
  case operator_equal = "OPERATOR_EQUAL"
  case operator_more_than = "OPERATOR_MORE_THAN"
  case operator_more_than_or_equal = "OPERATOR_MORE_THAN_OR_EQUAL"
  case operator_less_than = "OPERATOR_LESS_THAN"
  case operator_less_than_or_equal = "OPERATOR_LESS_THAN_OR_EQUAL"
  case operator_contains = "OPERATOR_CONTAINS"
  case operator_not_equal = "OPERATOR_NOT_EQUAL"
  case operator_in = "OPERATOR_IN"
  case operator_not_in = "OPERATOR_NOT_IN"
  case operator_contains_one = "OPERATOR_CONTAINS_ONE"
  case operator_contains_all = "OPERATOR_CONTAINS_ALL"
}

public struct v1OrganizationData: Codable, Sendable {
  public let features: [v1Feature]?
  public let invitations: [v1Invitation]?
  public let name: String?
  public let organizationId: String?
  public let policies: [v1Policy]?
  public let privateKeys: [v1PrivateKey]?
  public let rootQuorum: externaldatav1Quorum?
  public let smartContractInterfaceReferences: [v1SmartContractInterfaceReference]?
  public let tags: [datav1Tag]?
  public let users: [v1User]?
  public let wallets: [v1Wallet]?

  public init(
    features: [v1Feature]? = nil,
    invitations: [v1Invitation]? = nil,
    name: String? = nil,
    organizationId: String? = nil,
    policies: [v1Policy]? = nil,
    privateKeys: [v1PrivateKey]? = nil,
    rootQuorum: externaldatav1Quorum? = nil,
    smartContractInterfaceReferences: [v1SmartContractInterfaceReference]? = nil,
    tags: [datav1Tag]? = nil,
    users: [v1User]? = nil,
    wallets: [v1Wallet]? = nil
  ) {
    self.features = features
    self.invitations = invitations
    self.name = name
    self.organizationId = organizationId
    self.policies = policies
    self.privateKeys = privateKeys
    self.rootQuorum = rootQuorum
    self.smartContractInterfaceReferences = smartContractInterfaceReferences
    self.tags = tags
    self.users = users
    self.wallets = wallets
  }
}

public struct v1OtpAuthIntent: Codable, Sendable {
  /// Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp>
  public let apiKeyName: String?
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated OTP Auth API keys
  public let invalidateExisting: Bool?
  /// OTP sent out to a user's contact (email or SMS)
  public let otpCode: String
  /// ID representing the result of an init OTP activity.
  public let otpId: String
  /// Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted.
  public let targetPublicKey: String

  public init(
    apiKeyName: String? = nil,
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    otpCode: String,
    otpId: String,
    targetPublicKey: String
  ) {
    self.apiKeyName = apiKeyName
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.otpCode = otpCode
    self.otpId = otpId
    self.targetPublicKey = targetPublicKey
  }
}

public struct v1OtpAuthRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1OtpAuthIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1OtpAuthIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1OtpAuthResult: Codable, Sendable {
  /// Unique identifier for the created API key.
  public let apiKeyId: String?
  /// HPKE encrypted credential bundle
  public let credentialBundle: String?
  /// Unique identifier for the authenticating User.
  public let userId: String

  public init(
    apiKeyId: String? = nil,
    credentialBundle: String? = nil,
    userId: String
  ) {
    self.apiKeyId = apiKeyId
    self.credentialBundle = credentialBundle
    self.userId = userId
  }
}

public struct v1OtpLoginIntent: Codable, Sendable {
  /// Optional signature proving authorization for this login. The signature is over the verification token ID and the public key. Only required if a public key was provided during the verification step.
  public let clientSignature: v1ClientSignature?
  /// Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated Login API keys
  public let invalidateExisting: Bool?
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token
  public let publicKey: String
  /// Signed JWT containing a unique id, expiry, verification type, contact
  public let verificationToken: String

  public init(
    clientSignature: v1ClientSignature? = nil,
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    publicKey: String,
    verificationToken: String
  ) {
    self.clientSignature = clientSignature
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.publicKey = publicKey
    self.verificationToken = verificationToken
  }
}

public struct v1OtpLoginRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1OtpLoginIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1OtpLoginIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1OtpLoginResult: Codable, Sendable {
  /// Signed JWT containing an expiry, public key, session type, user id, and organization id
  public let session: String

  public init(
    session: String
  ) {
    self.session = session
  }
}

public enum v1Outcome: String, Codable, Sendable {
  case outcome_allow = "OUTCOME_ALLOW"
  case outcome_deny_explicit = "OUTCOME_DENY_EXPLICIT"
  case outcome_deny_implicit = "OUTCOME_DENY_IMPLICIT"
  case outcome_requires_consensus = "OUTCOME_REQUIRES_CONSENSUS"
  case outcome_rejected = "OUTCOME_REJECTED"
  case outcome_error = "OUTCOME_ERROR"
}

public struct v1Pagination: Codable, Sendable {
  /// A pagination cursor. This is an object ID that enables you to fetch all objects after this ID.
  public let after: String?
  /// A pagination cursor. This is an object ID that enables you to fetch all objects before this ID.
  public let before: String?
  /// A limit of the number of object to be returned, between 1 and 100. Defaults to 10.
  public let limit: String?

  public init(
    after: String? = nil,
    before: String? = nil,
    limit: String? = nil
  ) {
    self.after = after
    self.before = before
    self.limit = limit
  }
}

public enum v1PathFormat: String, Codable, Sendable {
  case path_format_bip32 = "PATH_FORMAT_BIP32"
}

public enum v1PayloadEncoding: String, Codable, Sendable {
  case payload_encoding_hexadecimal = "PAYLOAD_ENCODING_HEXADECIMAL"
  case payload_encoding_text_utf8 = "PAYLOAD_ENCODING_TEXT_UTF8"
  case payload_encoding_eip712 = "PAYLOAD_ENCODING_EIP712"
  case payload_encoding_eip7702_authorization = "PAYLOAD_ENCODING_EIP7702_AUTHORIZATION"
}

public struct v1Policy: Codable, Sendable {
  /// A condition expression that evalutes to true or false.
  public let condition: String
  /// A consensus expression that evalutes to true or false.
  public let consensus: String
  public let createdAt: externaldatav1Timestamp
  /// The instruction to DENY or ALLOW a particular activity following policy selector(s).
  public let effect: v1Effect
  /// Human-readable notes added by a User to describe a particular policy.
  public let notes: String
  /// Unique identifier for a given Policy.
  public let policyId: String
  /// Human-readable name for a Policy.
  public let policyName: String
  public let updatedAt: externaldatav1Timestamp

  public init(
    condition: String,
    consensus: String,
    createdAt: externaldatav1Timestamp,
    effect: v1Effect,
    notes: String,
    policyId: String,
    policyName: String,
    updatedAt: externaldatav1Timestamp
  ) {
    self.condition = condition
    self.consensus = consensus
    self.createdAt = createdAt
    self.effect = effect
    self.notes = notes
    self.policyId = policyId
    self.policyName = policyName
    self.updatedAt = updatedAt
  }
}

public struct v1PrivateKey: Codable, Sendable {
  /// Derived cryptocurrency addresses for a given Private Key.
  public let addresses: [externaldatav1Address]
  public let createdAt: externaldatav1Timestamp
  /// Cryptographic Curve used to generate a given Private Key.
  public let curve: v1Curve
  /// True when a given Private Key is exported, false otherwise.
  public let exported: Bool
  /// True when a given Private Key is imported, false otherwise.
  public let imported: Bool
  /// Unique identifier for a given Private Key.
  public let privateKeyId: String
  /// Human-readable name for a Private Key.
  public let privateKeyName: String
  /// A list of Private Key Tag IDs.
  public let privateKeyTags: [String]
  /// The public component of a cryptographic key pair used to sign messages and transactions.
  public let publicKey: String
  public let updatedAt: externaldatav1Timestamp

  public init(
    addresses: [externaldatav1Address],
    createdAt: externaldatav1Timestamp,
    curve: v1Curve,
    exported: Bool,
    imported: Bool,
    privateKeyId: String,
    privateKeyName: String,
    privateKeyTags: [String],
    publicKey: String,
    updatedAt: externaldatav1Timestamp
  ) {
    self.addresses = addresses
    self.createdAt = createdAt
    self.curve = curve
    self.exported = exported
    self.imported = imported
    self.privateKeyId = privateKeyId
    self.privateKeyName = privateKeyName
    self.privateKeyTags = privateKeyTags
    self.publicKey = publicKey
    self.updatedAt = updatedAt
  }
}

public struct v1PrivateKeyParams: Codable, Sendable {
  /// Cryptocurrency-specific formats for a derived address (e.g., Ethereum).
  public let addressFormats: [v1AddressFormat]
  /// Cryptographic Curve used to generate a given Private Key.
  public let curve: v1Curve
  /// Human-readable name for a Private Key.
  public let privateKeyName: String
  /// A list of Private Key Tag IDs. This field, if not needed, should be an empty array in your request body.
  public let privateKeyTags: [String]

  public init(
    addressFormats: [v1AddressFormat],
    curve: v1Curve,
    privateKeyName: String,
    privateKeyTags: [String]
  ) {
    self.addressFormats = addressFormats
    self.curve = curve
    self.privateKeyName = privateKeyName
    self.privateKeyTags = privateKeyTags
  }
}

public struct v1PrivateKeyResult: Codable, Sendable {
  public let addresses: [immutableactivityv1Address]?
  public let privateKeyId: String?

  public init(
    addresses: [immutableactivityv1Address]? = nil,
    privateKeyId: String? = nil
  ) {
    self.addresses = addresses
    self.privateKeyId = privateKeyId
  }
}

public struct v1PublicKeyCredentialWithAttestation: Codable, Sendable {
  public let authenticatorAttachment: String?
  public let clientExtensionResults: v1SimpleClientExtensionResults
  public let id: String
  public let rawId: String
  public let response: v1AuthenticatorAttestationResponse
  public let type: String

  public init(
    authenticatorAttachment: String? = nil,
    clientExtensionResults: v1SimpleClientExtensionResults,
    id: String,
    rawId: String,
    response: v1AuthenticatorAttestationResponse,
    type: String
  ) {
    self.authenticatorAttachment = authenticatorAttachment
    self.clientExtensionResults = clientExtensionResults
    self.id = id
    self.rawId = rawId
    self.response = response
    self.type = type
  }
}

public struct v1RecoverUserIntent: Codable, Sendable {
  /// The new authenticator to register.
  public let authenticator: v1AuthenticatorParamsV2
  /// Unique identifier for the user performing recovery.
  public let userId: String

  public init(
    authenticator: v1AuthenticatorParamsV2,
    userId: String
  ) {
    self.authenticator = authenticator
    self.userId = userId
  }
}

public struct v1RecoverUserRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1RecoverUserIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1RecoverUserIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1RecoverUserResult: Codable, Sendable {
  /// ID of the authenticator created.
  public let authenticatorId: [String]

  public init(
    authenticatorId: [String]
  ) {
    self.authenticatorId = authenticatorId
  }
}

public struct v1RejectActivityIntent: Codable, Sendable {
  /// An artifact verifying a User's action.
  public let fingerprint: String

  public init(
    fingerprint: String
  ) {
    self.fingerprint = fingerprint
  }
}

public struct v1RejectActivityRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1RejectActivityIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1RejectActivityIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1RemoveOrganizationFeatureIntent: Codable, Sendable {
  /// Name of the feature to remove
  public let name: v1FeatureName

  public init(
    name: v1FeatureName
  ) {
    self.name = name
  }
}

public struct v1RemoveOrganizationFeatureRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1RemoveOrganizationFeatureIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1RemoveOrganizationFeatureIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1RemoveOrganizationFeatureResult: Codable, Sendable {
  /// Resulting list of organization features.
  public let features: [v1Feature]

  public init(
    features: [v1Feature]
  ) {
    self.features = features
  }
}

public struct v1Result: Codable, Sendable {
  public let acceptInvitationResult: v1AcceptInvitationResult?
  public let activateBillingTierResult: billingActivateBillingTierResult?
  public let createApiKeysResult: v1CreateApiKeysResult?
  public let createApiOnlyUsersResult: v1CreateApiOnlyUsersResult?
  public let createAuthenticatorsResult: v1CreateAuthenticatorsResult?
  public let createFiatOnRampCredentialResult: v1CreateFiatOnRampCredentialResult?
  public let createInvitationsResult: v1CreateInvitationsResult?
  public let createOauth2CredentialResult: v1CreateOauth2CredentialResult?
  public let createOauthProvidersResult: v1CreateOauthProvidersResult?
  public let createOrganizationResult: v1CreateOrganizationResult?
  public let createPoliciesResult: v1CreatePoliciesResult?
  public let createPolicyResult: v1CreatePolicyResult?
  public let createPrivateKeyTagResult: v1CreatePrivateKeyTagResult?
  public let createPrivateKeysResult: v1CreatePrivateKeysResult?
  public let createPrivateKeysResultV2: v1CreatePrivateKeysResultV2?
  public let createReadOnlySessionResult: v1CreateReadOnlySessionResult?
  public let createReadWriteSessionResult: v1CreateReadWriteSessionResult?
  public let createReadWriteSessionResultV2: v1CreateReadWriteSessionResultV2?
  public let createSmartContractInterfaceResult: v1CreateSmartContractInterfaceResult?
  public let createSubOrganizationResult: v1CreateSubOrganizationResult?
  public let createSubOrganizationResultV3: v1CreateSubOrganizationResultV3?
  public let createSubOrganizationResultV4: v1CreateSubOrganizationResultV4?
  public let createSubOrganizationResultV5: v1CreateSubOrganizationResultV5?
  public let createSubOrganizationResultV6: v1CreateSubOrganizationResultV6?
  public let createSubOrganizationResultV7: v1CreateSubOrganizationResultV7?
  public let createUserTagResult: v1CreateUserTagResult?
  public let createUsersResult: v1CreateUsersResult?
  public let createWalletAccountsResult: v1CreateWalletAccountsResult?
  public let createWalletResult: v1CreateWalletResult?
  public let deleteApiKeysResult: v1DeleteApiKeysResult?
  public let deleteAuthenticatorsResult: v1DeleteAuthenticatorsResult?
  public let deleteFiatOnRampCredentialResult: v1DeleteFiatOnRampCredentialResult?
  public let deleteInvitationResult: v1DeleteInvitationResult?
  public let deleteOauth2CredentialResult: v1DeleteOauth2CredentialResult?
  public let deleteOauthProvidersResult: v1DeleteOauthProvidersResult?
  public let deleteOrganizationResult: v1DeleteOrganizationResult?
  public let deletePaymentMethodResult: billingDeletePaymentMethodResult?
  public let deletePoliciesResult: v1DeletePoliciesResult?
  public let deletePolicyResult: v1DeletePolicyResult?
  public let deletePrivateKeyTagsResult: v1DeletePrivateKeyTagsResult?
  public let deletePrivateKeysResult: v1DeletePrivateKeysResult?
  public let deleteSmartContractInterfaceResult: v1DeleteSmartContractInterfaceResult?
  public let deleteSubOrganizationResult: v1DeleteSubOrganizationResult?
  public let deleteUserTagsResult: v1DeleteUserTagsResult?
  public let deleteUsersResult: v1DeleteUsersResult?
  public let deleteWalletAccountsResult: v1DeleteWalletAccountsResult?
  public let deleteWalletsResult: v1DeleteWalletsResult?
  public let disableAuthProxyResult: v1DisableAuthProxyResult?
  public let disablePrivateKeyResult: v1DisablePrivateKeyResult?
  public let emailAuthResult: v1EmailAuthResult?
  public let enableAuthProxyResult: v1EnableAuthProxyResult?
  public let ethSendRawTransactionResult: v1EthSendRawTransactionResult?
  public let ethSendTransactionResult: v1EthSendTransactionResult?
  public let exportPrivateKeyResult: v1ExportPrivateKeyResult?
  public let exportWalletAccountResult: v1ExportWalletAccountResult?
  public let exportWalletResult: v1ExportWalletResult?
  public let importPrivateKeyResult: v1ImportPrivateKeyResult?
  public let importWalletResult: v1ImportWalletResult?
  public let initFiatOnRampResult: v1InitFiatOnRampResult?
  public let initImportPrivateKeyResult: v1InitImportPrivateKeyResult?
  public let initImportWalletResult: v1InitImportWalletResult?
  public let initOtpAuthResult: v1InitOtpAuthResult?
  public let initOtpAuthResultV2: v1InitOtpAuthResultV2?
  public let initOtpResult: v1InitOtpResult?
  public let initUserEmailRecoveryResult: v1InitUserEmailRecoveryResult?
  public let oauth2AuthenticateResult: v1Oauth2AuthenticateResult?
  public let oauthLoginResult: v1OauthLoginResult?
  public let oauthResult: v1OauthResult?
  public let otpAuthResult: v1OtpAuthResult?
  public let otpLoginResult: v1OtpLoginResult?
  public let recoverUserResult: v1RecoverUserResult?
  public let removeOrganizationFeatureResult: v1RemoveOrganizationFeatureResult?
  public let setOrganizationFeatureResult: v1SetOrganizationFeatureResult?
  public let setPaymentMethodResult: billingSetPaymentMethodResult?
  public let signRawPayloadResult: v1SignRawPayloadResult?
  public let signRawPayloadsResult: v1SignRawPayloadsResult?
  public let signTransactionResult: v1SignTransactionResult?
  public let stampLoginResult: v1StampLoginResult?
  public let updateAllowedOriginsResult: v1UpdateAllowedOriginsResult?
  public let updateAuthProxyConfigResult: v1UpdateAuthProxyConfigResult?
  public let updateFiatOnRampCredentialResult: v1UpdateFiatOnRampCredentialResult?
  public let updateOauth2CredentialResult: v1UpdateOauth2CredentialResult?
  public let updatePolicyResult: v1UpdatePolicyResult?
  public let updatePolicyResultV2: v1UpdatePolicyResultV2?
  public let updatePrivateKeyTagResult: v1UpdatePrivateKeyTagResult?
  public let updateRootQuorumResult: v1UpdateRootQuorumResult?
  public let updateUserEmailResult: v1UpdateUserEmailResult?
  public let updateUserNameResult: v1UpdateUserNameResult?
  public let updateUserPhoneNumberResult: v1UpdateUserPhoneNumberResult?
  public let updateUserResult: v1UpdateUserResult?
  public let updateUserTagResult: v1UpdateUserTagResult?
  public let updateWalletResult: v1UpdateWalletResult?
  public let verifyOtpResult: v1VerifyOtpResult?

  public init(
    acceptInvitationResult: v1AcceptInvitationResult? = nil,
    activateBillingTierResult: billingActivateBillingTierResult? = nil,
    createApiKeysResult: v1CreateApiKeysResult? = nil,
    createApiOnlyUsersResult: v1CreateApiOnlyUsersResult? = nil,
    createAuthenticatorsResult: v1CreateAuthenticatorsResult? = nil,
    createFiatOnRampCredentialResult: v1CreateFiatOnRampCredentialResult? = nil,
    createInvitationsResult: v1CreateInvitationsResult? = nil,
    createOauth2CredentialResult: v1CreateOauth2CredentialResult? = nil,
    createOauthProvidersResult: v1CreateOauthProvidersResult? = nil,
    createOrganizationResult: v1CreateOrganizationResult? = nil,
    createPoliciesResult: v1CreatePoliciesResult? = nil,
    createPolicyResult: v1CreatePolicyResult? = nil,
    createPrivateKeyTagResult: v1CreatePrivateKeyTagResult? = nil,
    createPrivateKeysResult: v1CreatePrivateKeysResult? = nil,
    createPrivateKeysResultV2: v1CreatePrivateKeysResultV2? = nil,
    createReadOnlySessionResult: v1CreateReadOnlySessionResult? = nil,
    createReadWriteSessionResult: v1CreateReadWriteSessionResult? = nil,
    createReadWriteSessionResultV2: v1CreateReadWriteSessionResultV2? = nil,
    createSmartContractInterfaceResult: v1CreateSmartContractInterfaceResult? = nil,
    createSubOrganizationResult: v1CreateSubOrganizationResult? = nil,
    createSubOrganizationResultV3: v1CreateSubOrganizationResultV3? = nil,
    createSubOrganizationResultV4: v1CreateSubOrganizationResultV4? = nil,
    createSubOrganizationResultV5: v1CreateSubOrganizationResultV5? = nil,
    createSubOrganizationResultV6: v1CreateSubOrganizationResultV6? = nil,
    createSubOrganizationResultV7: v1CreateSubOrganizationResultV7? = nil,
    createUserTagResult: v1CreateUserTagResult? = nil,
    createUsersResult: v1CreateUsersResult? = nil,
    createWalletAccountsResult: v1CreateWalletAccountsResult? = nil,
    createWalletResult: v1CreateWalletResult? = nil,
    deleteApiKeysResult: v1DeleteApiKeysResult? = nil,
    deleteAuthenticatorsResult: v1DeleteAuthenticatorsResult? = nil,
    deleteFiatOnRampCredentialResult: v1DeleteFiatOnRampCredentialResult? = nil,
    deleteInvitationResult: v1DeleteInvitationResult? = nil,
    deleteOauth2CredentialResult: v1DeleteOauth2CredentialResult? = nil,
    deleteOauthProvidersResult: v1DeleteOauthProvidersResult? = nil,
    deleteOrganizationResult: v1DeleteOrganizationResult? = nil,
    deletePaymentMethodResult: billingDeletePaymentMethodResult? = nil,
    deletePoliciesResult: v1DeletePoliciesResult? = nil,
    deletePolicyResult: v1DeletePolicyResult? = nil,
    deletePrivateKeyTagsResult: v1DeletePrivateKeyTagsResult? = nil,
    deletePrivateKeysResult: v1DeletePrivateKeysResult? = nil,
    deleteSmartContractInterfaceResult: v1DeleteSmartContractInterfaceResult? = nil,
    deleteSubOrganizationResult: v1DeleteSubOrganizationResult? = nil,
    deleteUserTagsResult: v1DeleteUserTagsResult? = nil,
    deleteUsersResult: v1DeleteUsersResult? = nil,
    deleteWalletAccountsResult: v1DeleteWalletAccountsResult? = nil,
    deleteWalletsResult: v1DeleteWalletsResult? = nil,
    disableAuthProxyResult: v1DisableAuthProxyResult? = nil,
    disablePrivateKeyResult: v1DisablePrivateKeyResult? = nil,
    emailAuthResult: v1EmailAuthResult? = nil,
    enableAuthProxyResult: v1EnableAuthProxyResult? = nil,
    ethSendRawTransactionResult: v1EthSendRawTransactionResult? = nil,
    ethSendTransactionResult: v1EthSendTransactionResult? = nil,
    exportPrivateKeyResult: v1ExportPrivateKeyResult? = nil,
    exportWalletAccountResult: v1ExportWalletAccountResult? = nil,
    exportWalletResult: v1ExportWalletResult? = nil,
    importPrivateKeyResult: v1ImportPrivateKeyResult? = nil,
    importWalletResult: v1ImportWalletResult? = nil,
    initFiatOnRampResult: v1InitFiatOnRampResult? = nil,
    initImportPrivateKeyResult: v1InitImportPrivateKeyResult? = nil,
    initImportWalletResult: v1InitImportWalletResult? = nil,
    initOtpAuthResult: v1InitOtpAuthResult? = nil,
    initOtpAuthResultV2: v1InitOtpAuthResultV2? = nil,
    initOtpResult: v1InitOtpResult? = nil,
    initUserEmailRecoveryResult: v1InitUserEmailRecoveryResult? = nil,
    oauth2AuthenticateResult: v1Oauth2AuthenticateResult? = nil,
    oauthLoginResult: v1OauthLoginResult? = nil,
    oauthResult: v1OauthResult? = nil,
    otpAuthResult: v1OtpAuthResult? = nil,
    otpLoginResult: v1OtpLoginResult? = nil,
    recoverUserResult: v1RecoverUserResult? = nil,
    removeOrganizationFeatureResult: v1RemoveOrganizationFeatureResult? = nil,
    setOrganizationFeatureResult: v1SetOrganizationFeatureResult? = nil,
    setPaymentMethodResult: billingSetPaymentMethodResult? = nil,
    signRawPayloadResult: v1SignRawPayloadResult? = nil,
    signRawPayloadsResult: v1SignRawPayloadsResult? = nil,
    signTransactionResult: v1SignTransactionResult? = nil,
    stampLoginResult: v1StampLoginResult? = nil,
    updateAllowedOriginsResult: v1UpdateAllowedOriginsResult? = nil,
    updateAuthProxyConfigResult: v1UpdateAuthProxyConfigResult? = nil,
    updateFiatOnRampCredentialResult: v1UpdateFiatOnRampCredentialResult? = nil,
    updateOauth2CredentialResult: v1UpdateOauth2CredentialResult? = nil,
    updatePolicyResult: v1UpdatePolicyResult? = nil,
    updatePolicyResultV2: v1UpdatePolicyResultV2? = nil,
    updatePrivateKeyTagResult: v1UpdatePrivateKeyTagResult? = nil,
    updateRootQuorumResult: v1UpdateRootQuorumResult? = nil,
    updateUserEmailResult: v1UpdateUserEmailResult? = nil,
    updateUserNameResult: v1UpdateUserNameResult? = nil,
    updateUserPhoneNumberResult: v1UpdateUserPhoneNumberResult? = nil,
    updateUserResult: v1UpdateUserResult? = nil,
    updateUserTagResult: v1UpdateUserTagResult? = nil,
    updateWalletResult: v1UpdateWalletResult? = nil,
    verifyOtpResult: v1VerifyOtpResult? = nil
  ) {
    self.acceptInvitationResult = acceptInvitationResult
    self.activateBillingTierResult = activateBillingTierResult
    self.createApiKeysResult = createApiKeysResult
    self.createApiOnlyUsersResult = createApiOnlyUsersResult
    self.createAuthenticatorsResult = createAuthenticatorsResult
    self.createFiatOnRampCredentialResult = createFiatOnRampCredentialResult
    self.createInvitationsResult = createInvitationsResult
    self.createOauth2CredentialResult = createOauth2CredentialResult
    self.createOauthProvidersResult = createOauthProvidersResult
    self.createOrganizationResult = createOrganizationResult
    self.createPoliciesResult = createPoliciesResult
    self.createPolicyResult = createPolicyResult
    self.createPrivateKeyTagResult = createPrivateKeyTagResult
    self.createPrivateKeysResult = createPrivateKeysResult
    self.createPrivateKeysResultV2 = createPrivateKeysResultV2
    self.createReadOnlySessionResult = createReadOnlySessionResult
    self.createReadWriteSessionResult = createReadWriteSessionResult
    self.createReadWriteSessionResultV2 = createReadWriteSessionResultV2
    self.createSmartContractInterfaceResult = createSmartContractInterfaceResult
    self.createSubOrganizationResult = createSubOrganizationResult
    self.createSubOrganizationResultV3 = createSubOrganizationResultV3
    self.createSubOrganizationResultV4 = createSubOrganizationResultV4
    self.createSubOrganizationResultV5 = createSubOrganizationResultV5
    self.createSubOrganizationResultV6 = createSubOrganizationResultV6
    self.createSubOrganizationResultV7 = createSubOrganizationResultV7
    self.createUserTagResult = createUserTagResult
    self.createUsersResult = createUsersResult
    self.createWalletAccountsResult = createWalletAccountsResult
    self.createWalletResult = createWalletResult
    self.deleteApiKeysResult = deleteApiKeysResult
    self.deleteAuthenticatorsResult = deleteAuthenticatorsResult
    self.deleteFiatOnRampCredentialResult = deleteFiatOnRampCredentialResult
    self.deleteInvitationResult = deleteInvitationResult
    self.deleteOauth2CredentialResult = deleteOauth2CredentialResult
    self.deleteOauthProvidersResult = deleteOauthProvidersResult
    self.deleteOrganizationResult = deleteOrganizationResult
    self.deletePaymentMethodResult = deletePaymentMethodResult
    self.deletePoliciesResult = deletePoliciesResult
    self.deletePolicyResult = deletePolicyResult
    self.deletePrivateKeyTagsResult = deletePrivateKeyTagsResult
    self.deletePrivateKeysResult = deletePrivateKeysResult
    self.deleteSmartContractInterfaceResult = deleteSmartContractInterfaceResult
    self.deleteSubOrganizationResult = deleteSubOrganizationResult
    self.deleteUserTagsResult = deleteUserTagsResult
    self.deleteUsersResult = deleteUsersResult
    self.deleteWalletAccountsResult = deleteWalletAccountsResult
    self.deleteWalletsResult = deleteWalletsResult
    self.disableAuthProxyResult = disableAuthProxyResult
    self.disablePrivateKeyResult = disablePrivateKeyResult
    self.emailAuthResult = emailAuthResult
    self.enableAuthProxyResult = enableAuthProxyResult
    self.ethSendRawTransactionResult = ethSendRawTransactionResult
    self.ethSendTransactionResult = ethSendTransactionResult
    self.exportPrivateKeyResult = exportPrivateKeyResult
    self.exportWalletAccountResult = exportWalletAccountResult
    self.exportWalletResult = exportWalletResult
    self.importPrivateKeyResult = importPrivateKeyResult
    self.importWalletResult = importWalletResult
    self.initFiatOnRampResult = initFiatOnRampResult
    self.initImportPrivateKeyResult = initImportPrivateKeyResult
    self.initImportWalletResult = initImportWalletResult
    self.initOtpAuthResult = initOtpAuthResult
    self.initOtpAuthResultV2 = initOtpAuthResultV2
    self.initOtpResult = initOtpResult
    self.initUserEmailRecoveryResult = initUserEmailRecoveryResult
    self.oauth2AuthenticateResult = oauth2AuthenticateResult
    self.oauthLoginResult = oauthLoginResult
    self.oauthResult = oauthResult
    self.otpAuthResult = otpAuthResult
    self.otpLoginResult = otpLoginResult
    self.recoverUserResult = recoverUserResult
    self.removeOrganizationFeatureResult = removeOrganizationFeatureResult
    self.setOrganizationFeatureResult = setOrganizationFeatureResult
    self.setPaymentMethodResult = setPaymentMethodResult
    self.signRawPayloadResult = signRawPayloadResult
    self.signRawPayloadsResult = signRawPayloadsResult
    self.signTransactionResult = signTransactionResult
    self.stampLoginResult = stampLoginResult
    self.updateAllowedOriginsResult = updateAllowedOriginsResult
    self.updateAuthProxyConfigResult = updateAuthProxyConfigResult
    self.updateFiatOnRampCredentialResult = updateFiatOnRampCredentialResult
    self.updateOauth2CredentialResult = updateOauth2CredentialResult
    self.updatePolicyResult = updatePolicyResult
    self.updatePolicyResultV2 = updatePolicyResultV2
    self.updatePrivateKeyTagResult = updatePrivateKeyTagResult
    self.updateRootQuorumResult = updateRootQuorumResult
    self.updateUserEmailResult = updateUserEmailResult
    self.updateUserNameResult = updateUserNameResult
    self.updateUserPhoneNumberResult = updateUserPhoneNumberResult
    self.updateUserResult = updateUserResult
    self.updateUserTagResult = updateUserTagResult
    self.updateWalletResult = updateWalletResult
    self.verifyOtpResult = verifyOtpResult
  }
}

public struct v1RootUserParams: Codable, Sendable {
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  public let apiKeys: [apiApiKeyParams]
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  public let authenticators: [v1AuthenticatorParamsV2]
  /// The user's email address.
  public let userEmail: String?
  /// Human-readable name for a User.
  public let userName: String

  public init(
    apiKeys: [apiApiKeyParams],
    authenticators: [v1AuthenticatorParamsV2],
    userEmail: String? = nil,
    userName: String
  ) {
    self.apiKeys = apiKeys
    self.authenticators = authenticators
    self.userEmail = userEmail
    self.userName = userName
  }
}

public struct v1RootUserParamsV2: Codable, Sendable {
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  public let apiKeys: [apiApiKeyParams]
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  public let authenticators: [v1AuthenticatorParamsV2]
  /// A list of Oauth providers. This field, if not needed, should be an empty array in your request body.
  public let oauthProviders: [v1OauthProviderParams]
  /// The user's email address.
  public let userEmail: String?
  /// Human-readable name for a User.
  public let userName: String

  public init(
    apiKeys: [apiApiKeyParams],
    authenticators: [v1AuthenticatorParamsV2],
    oauthProviders: [v1OauthProviderParams],
    userEmail: String? = nil,
    userName: String
  ) {
    self.apiKeys = apiKeys
    self.authenticators = authenticators
    self.oauthProviders = oauthProviders
    self.userEmail = userEmail
    self.userName = userName
  }
}

public struct v1RootUserParamsV3: Codable, Sendable {
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  public let apiKeys: [v1ApiKeyParamsV2]
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  public let authenticators: [v1AuthenticatorParamsV2]
  /// A list of Oauth providers. This field, if not needed, should be an empty array in your request body.
  public let oauthProviders: [v1OauthProviderParams]
  /// The user's email address.
  public let userEmail: String?
  /// Human-readable name for a User.
  public let userName: String

  public init(
    apiKeys: [v1ApiKeyParamsV2],
    authenticators: [v1AuthenticatorParamsV2],
    oauthProviders: [v1OauthProviderParams],
    userEmail: String? = nil,
    userName: String
  ) {
    self.apiKeys = apiKeys
    self.authenticators = authenticators
    self.oauthProviders = oauthProviders
    self.userEmail = userEmail
    self.userName = userName
  }
}

public struct v1RootUserParamsV4: Codable, Sendable {
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  public let apiKeys: [v1ApiKeyParamsV2]
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  public let authenticators: [v1AuthenticatorParamsV2]
  /// A list of Oauth providers. This field, if not needed, should be an empty array in your request body.
  public let oauthProviders: [v1OauthProviderParams]
  /// The user's email address.
  public let userEmail: String?
  /// Human-readable name for a User.
  public let userName: String
  /// The user's phone number in E.164 format e.g. +13214567890
  public let userPhoneNumber: String?

  public init(
    apiKeys: [v1ApiKeyParamsV2],
    authenticators: [v1AuthenticatorParamsV2],
    oauthProviders: [v1OauthProviderParams],
    userEmail: String? = nil,
    userName: String,
    userPhoneNumber: String? = nil
  ) {
    self.apiKeys = apiKeys
    self.authenticators = authenticators
    self.oauthProviders = oauthProviders
    self.userEmail = userEmail
    self.userName = userName
    self.userPhoneNumber = userPhoneNumber
  }
}

public struct v1Selector: Codable, Sendable {
  public let _operator: v1Operator?
  public let subject: String?
  public let target: String?

  public init(
    _operator: v1Operator? = nil,
    subject: String? = nil,
    target: String? = nil
  ) {
    self._operator = _operator
    self.subject = subject
    self.target = target
  }

  private enum CodingKeys: String, CodingKey {
    case _operator = "operator"
    case subject = "subject"
    case target = "target"
  }
}

public struct v1SelectorV2: Codable, Sendable {
  public let _operator: v1Operator?
  public let subject: String?
  public let targets: [String]?

  public init(
    _operator: v1Operator? = nil,
    subject: String? = nil,
    targets: [String]? = nil
  ) {
    self._operator = _operator
    self.subject = subject
    self.targets = targets
  }

  private enum CodingKeys: String, CodingKey {
    case _operator = "operator"
    case subject = "subject"
    case targets = "targets"
  }
}

public struct v1SetOrganizationFeatureIntent: Codable, Sendable {
  /// Name of the feature to set
  public let name: v1FeatureName
  /// Optional value for the feature. Will override existing values if feature is already set.
  public let value: String

  public init(
    name: v1FeatureName,
    value: String
  ) {
    self.name = name
    self.value = value
  }
}

public struct v1SetOrganizationFeatureRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1SetOrganizationFeatureIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1SetOrganizationFeatureIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1SetOrganizationFeatureResult: Codable, Sendable {
  /// Resulting list of organization features.
  public let features: [v1Feature]

  public init(
    features: [v1Feature]
  ) {
    self.features = features
  }
}

public struct v1SignRawPayloadIntent: Codable, Sendable {
  /// Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8).
  public let encoding: v1PayloadEncoding
  /// Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032.
  public let hashFunction: v1HashFunction
  /// Raw unsigned payload to be signed.
  public let payload: String
  /// Unique identifier for a given Private Key.
  public let privateKeyId: String

  public init(
    encoding: v1PayloadEncoding,
    hashFunction: v1HashFunction,
    payload: String,
    privateKeyId: String
  ) {
    self.encoding = encoding
    self.hashFunction = hashFunction
    self.payload = payload
    self.privateKeyId = privateKeyId
  }
}

public struct v1SignRawPayloadIntentV2: Codable, Sendable {
  /// Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8).
  public let encoding: v1PayloadEncoding
  /// Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032.
  public let hashFunction: v1HashFunction
  /// Raw unsigned payload to be signed.
  public let payload: String
  /// A Wallet account address, Private Key address, or Private Key identifier.
  public let signWith: String

  public init(
    encoding: v1PayloadEncoding,
    hashFunction: v1HashFunction,
    payload: String,
    signWith: String
  ) {
    self.encoding = encoding
    self.hashFunction = hashFunction
    self.payload = payload
    self.signWith = signWith
  }
}

public struct v1SignRawPayloadRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1SignRawPayloadIntentV2
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1SignRawPayloadIntentV2,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1SignRawPayloadResult: Codable, Sendable {
  /// Component of an ECSDA signature.
  public let r: String
  /// Component of an ECSDA signature.
  public let s: String
  /// Component of an ECSDA signature.
  public let v: String

  public init(
    r: String,
    s: String,
    v: String
  ) {
    self.r = r
    self.s = s
    self.v = v
  }
}

public struct v1SignRawPayloadsIntent: Codable, Sendable {
  /// Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8).
  public let encoding: v1PayloadEncoding
  /// Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032.
  public let hashFunction: v1HashFunction
  /// An array of raw unsigned payloads to be signed.
  public let payloads: [String]
  /// A Wallet account address, Private Key address, or Private Key identifier.
  public let signWith: String

  public init(
    encoding: v1PayloadEncoding,
    hashFunction: v1HashFunction,
    payloads: [String],
    signWith: String
  ) {
    self.encoding = encoding
    self.hashFunction = hashFunction
    self.payloads = payloads
    self.signWith = signWith
  }
}

public struct v1SignRawPayloadsRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1SignRawPayloadsIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1SignRawPayloadsIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1SignRawPayloadsResult: Codable, Sendable {
  public let signatures: [v1SignRawPayloadResult]?

  public init(
    signatures: [v1SignRawPayloadResult]? = nil
  ) {
    self.signatures = signatures
  }
}

public struct v1SignTransactionIntent: Codable, Sendable {
  /// Unique identifier for a given Private Key.
  public let privateKeyId: String
  public let type: v1TransactionType
  /// Raw unsigned transaction to be signed by a particular Private Key.
  public let unsignedTransaction: String

  public init(
    privateKeyId: String,
    type: v1TransactionType,
    unsignedTransaction: String
  ) {
    self.privateKeyId = privateKeyId
    self.type = type
    self.unsignedTransaction = unsignedTransaction
  }
}

public struct v1SignTransactionIntentV2: Codable, Sendable {
  /// A Wallet account address, Private Key address, or Private Key identifier.
  public let signWith: String
  public let type: v1TransactionType
  /// Raw unsigned transaction to be signed
  public let unsignedTransaction: String

  public init(
    signWith: String,
    type: v1TransactionType,
    unsignedTransaction: String
  ) {
    self.signWith = signWith
    self.type = type
    self.unsignedTransaction = unsignedTransaction
  }
}

public struct v1SignTransactionRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1SignTransactionIntentV2
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1SignTransactionIntentV2,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1SignTransactionResult: Codable, Sendable {
  public let signedTransaction: String

  public init(
    signedTransaction: String
  ) {
    self.signedTransaction = signedTransaction
  }
}

public struct v1SignupUsage: Codable, Sendable {
  public let apiKeys: [v1ApiKeyParamsV2]?
  public let authenticators: [v1AuthenticatorParamsV2]?
  public let email: String?
  public let oauthProviders: [v1OauthProviderParams]?
  public let phoneNumber: String?

  public init(
    apiKeys: [v1ApiKeyParamsV2]? = nil,
    authenticators: [v1AuthenticatorParamsV2]? = nil,
    email: String? = nil,
    oauthProviders: [v1OauthProviderParams]? = nil,
    phoneNumber: String? = nil
  ) {
    self.apiKeys = apiKeys
    self.authenticators = authenticators
    self.email = email
    self.oauthProviders = oauthProviders
    self.phoneNumber = phoneNumber
  }
}

public struct v1SimpleClientExtensionResults: Codable, Sendable {
  public let appid: Bool?
  public let appidExclude: Bool?
  public let credProps: v1CredPropsAuthenticationExtensionsClientOutputs?

  public init(
    appid: Bool? = nil,
    appidExclude: Bool? = nil,
    credProps: v1CredPropsAuthenticationExtensionsClientOutputs? = nil
  ) {
    self.appid = appid
    self.appidExclude = appidExclude
    self.credProps = credProps
  }
}

public struct v1SmartContractInterfaceReference: Codable, Sendable {
  public let digest: String?
  public let smartContractAddress: String?
  public let smartContractInterfaceId: String?

  public init(
    digest: String? = nil,
    smartContractAddress: String? = nil,
    smartContractInterfaceId: String? = nil
  ) {
    self.digest = digest
    self.smartContractAddress = smartContractAddress
    self.smartContractInterfaceId = smartContractInterfaceId
  }
}

public enum v1SmartContractInterfaceType: String, Codable, Sendable {
  case smart_contract_interface_type_ethereum = "SMART_CONTRACT_INTERFACE_TYPE_ETHEREUM"
  case smart_contract_interface_type_solana = "SMART_CONTRACT_INTERFACE_TYPE_SOLANA"
}

public struct v1SmsCustomizationParams: Codable, Sendable {
  /// Template containing references to .OtpCode i.e Your OTP is {{.OtpCode}}
  public let template: String?

  public init(
    template: String? = nil
  ) {
    self.template = template
  }
}

public struct v1StampLoginIntent: Codable, Sendable {
  /// Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated Login API keys
  public let invalidateExisting: Bool?
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the passkey stamp associated with this request
  public let publicKey: String

  public init(
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    publicKey: String
  ) {
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.publicKey = publicKey
  }
}

public struct v1StampLoginRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1StampLoginIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1StampLoginIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1StampLoginResult: Codable, Sendable {
  /// Signed JWT containing an expiry, public key, session type, user id, and organization id
  public let session: String

  public init(
    session: String
  ) {
    self.session = session
  }
}

public enum v1TagType: String, Codable, Sendable {
  case tag_type_user = "TAG_TYPE_USER"
  case tag_type_private_key = "TAG_TYPE_PRIVATE_KEY"
}

public struct v1TestRateLimitsRequest: Codable, Sendable {
  /// Whether or not to set a limit on this request.
  public let isSetLimit: Bool
  /// Rate limit to set for org, if is_set_limit is set to true.
  public let limit: Int
  /// Unique identifier for a given organization. If the request is being made by a WebAuthN user and their sub-organization ID is unknown, this can be the parent organization ID; using the sub-organization ID when possible is preferred due to performance reasons.
  public let organizationId: String

  public init(
    isSetLimit: Bool,
    limit: Int,
    organizationId: String
  ) {
    self.isSetLimit = isSetLimit
    self.limit = limit
    self.organizationId = organizationId
  }
}

public struct v1TestRateLimitsResponse: Codable, Sendable {
  public init() {}
}

public struct v1TokenUsage: Codable, Sendable {
  public let login: v1LoginUsage?
  public let signup: v1SignupUsage?
  /// Unique identifier for the verification token
  public let tokenId: String
  /// Type of token usage
  public let type: v1UsageType

  public init(
    login: v1LoginUsage? = nil,
    signup: v1SignupUsage? = nil,
    tokenId: String,
    type: v1UsageType
  ) {
    self.login = login
    self.signup = signup
    self.tokenId = tokenId
    self.type = type
  }
}

public enum v1TransactionType: String, Codable, Sendable {
  case transaction_type_ethereum = "TRANSACTION_TYPE_ETHEREUM"
  case transaction_type_solana = "TRANSACTION_TYPE_SOLANA"
  case transaction_type_tron = "TRANSACTION_TYPE_TRON"
  case transaction_type_bitcoin = "TRANSACTION_TYPE_BITCOIN"
}

public struct v1UpdateAllowedOriginsIntent: Codable, Sendable {
  /// Additional origins requests are allowed from besides Turnkey origins
  public let allowedOrigins: [String]

  public init(
    allowedOrigins: [String]
  ) {
    self.allowedOrigins = allowedOrigins
  }
}

public struct v1UpdateAllowedOriginsResult: Codable, Sendable {
  public init() {}
}

public struct v1UpdateAuthProxyConfigIntent: Codable, Sendable {
  /// Updated list of allowed proxy authentication methods.
  public let allowedAuthMethods: [String]?
  /// Updated list of allowed origins for CORS.
  public let allowedOrigins: [String]?
  /// Template ID for email-auth messages.
  public let emailAuthTemplateId: String?
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomizationParams: v1EmailCustomizationParams?
  /// Enable alphanumeric OTP codes.
  public let otpAlphanumeric: Bool?
  /// OTP code lifetime in seconds.
  public let otpExpirationSeconds: Int?
  /// Desired OTP code length (69).
  public let otpLength: Int?
  /// Template ID for OTP SMS messages.
  public let otpTemplateId: String?
  /// Custom reply-to address for auth-related emails.
  public let replyToEmailAddress: String?
  /// Custom 'from' address for auth-related emails.
  public let sendFromEmailAddress: String?
  /// Custom 'from' email sender for auth-related emails.
  public let sendFromEmailSenderName: String?
  /// Session lifetime in seconds.
  public let sessionExpirationSeconds: Int?
  /// Overrides for auth-related SMS content.
  public let smsCustomizationParams: v1SmsCustomizationParams?
  /// Verification-token lifetime in seconds.
  public let verificationTokenExpirationSeconds: Int?
  /// Verification token required for get account with PII (email/phone number). Default false.
  public let verificationTokenRequiredForGetAccountPii: Bool?
  /// Overrides for react wallet kit related settings.
  public let walletKitSettings: v1WalletKitSettingsParams?

  public init(
    allowedAuthMethods: [String]? = nil,
    allowedOrigins: [String]? = nil,
    emailAuthTemplateId: String? = nil,
    emailCustomizationParams: v1EmailCustomizationParams? = nil,
    otpAlphanumeric: Bool? = nil,
    otpExpirationSeconds: Int? = nil,
    otpLength: Int? = nil,
    otpTemplateId: String? = nil,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    sessionExpirationSeconds: Int? = nil,
    smsCustomizationParams: v1SmsCustomizationParams? = nil,
    verificationTokenExpirationSeconds: Int? = nil,
    verificationTokenRequiredForGetAccountPii: Bool? = nil,
    walletKitSettings: v1WalletKitSettingsParams? = nil
  ) {
    self.allowedAuthMethods = allowedAuthMethods
    self.allowedOrigins = allowedOrigins
    self.emailAuthTemplateId = emailAuthTemplateId
    self.emailCustomizationParams = emailCustomizationParams
    self.otpAlphanumeric = otpAlphanumeric
    self.otpExpirationSeconds = otpExpirationSeconds
    self.otpLength = otpLength
    self.otpTemplateId = otpTemplateId
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.sessionExpirationSeconds = sessionExpirationSeconds
    self.smsCustomizationParams = smsCustomizationParams
    self.verificationTokenExpirationSeconds = verificationTokenExpirationSeconds
    self.verificationTokenRequiredForGetAccountPii = verificationTokenRequiredForGetAccountPii
    self.walletKitSettings = walletKitSettings
  }
}

public struct v1UpdateAuthProxyConfigResult: Codable, Sendable {
  /// Unique identifier for a given User. (representing the turnkey signer user id)
  public let configId: String?

  public init(
    configId: String? = nil
  ) {
    self.configId = configId
  }
}

public struct v1UpdateFiatOnRampCredentialIntent: Codable, Sendable {
  /// Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.
  public let encryptedPrivateApiKey: String?
  /// Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key
  public let encryptedSecretApiKey: String
  /// The ID of the fiat on-ramp credential to update
  public let fiatOnrampCredentialId: String
  /// The fiat on-ramp provider
  public let onrampProvider: v1FiatOnRampProvider
  /// Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier.
  public let projectId: String?
  /// Publishable API key for the on-ramp provider
  public let publishableApiKey: String

  public init(
    encryptedPrivateApiKey: String? = nil,
    encryptedSecretApiKey: String,
    fiatOnrampCredentialId: String,
    onrampProvider: v1FiatOnRampProvider,
    projectId: String? = nil,
    publishableApiKey: String
  ) {
    self.encryptedPrivateApiKey = encryptedPrivateApiKey
    self.encryptedSecretApiKey = encryptedSecretApiKey
    self.fiatOnrampCredentialId = fiatOnrampCredentialId
    self.onrampProvider = onrampProvider
    self.projectId = projectId
    self.publishableApiKey = publishableApiKey
  }
}

public struct v1UpdateFiatOnRampCredentialRequest: Codable, Sendable {
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1UpdateFiatOnRampCredentialIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    organizationId: String,
    parameters: v1UpdateFiatOnRampCredentialIntent,
    timestampMs: String,
    type: String
  ) {
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1UpdateFiatOnRampCredentialResult: Codable, Sendable {
  /// Unique identifier of the Fiat On-Ramp credential that was updated
  public let fiatOnRampCredentialId: String

  public init(
    fiatOnRampCredentialId: String
  ) {
    self.fiatOnRampCredentialId = fiatOnRampCredentialId
  }
}

public struct v1UpdateOauth2CredentialIntent: Codable, Sendable {
  /// The Client ID issued by the OAuth 2.0 provider
  public let clientId: String
  /// The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key
  public let encryptedClientSecret: String
  /// The ID of the OAuth 2.0 credential to update
  public let oauth2CredentialId: String
  /// The OAuth 2.0 provider
  public let provider: v1Oauth2Provider

  public init(
    clientId: String,
    encryptedClientSecret: String,
    oauth2CredentialId: String,
    provider: v1Oauth2Provider
  ) {
    self.clientId = clientId
    self.encryptedClientSecret = encryptedClientSecret
    self.oauth2CredentialId = oauth2CredentialId
    self.provider = provider
  }
}

public struct v1UpdateOauth2CredentialRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1UpdateOauth2CredentialIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1UpdateOauth2CredentialIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1UpdateOauth2CredentialResult: Codable, Sendable {
  /// Unique identifier of the OAuth 2.0 credential that was updated
  public let oauth2CredentialId: String

  public init(
    oauth2CredentialId: String
  ) {
    self.oauth2CredentialId = oauth2CredentialId
  }
}

public struct v1UpdatePolicyIntent: Codable, Sendable {
  /// The condition expression that triggers the Effect (optional).
  public let policyCondition: String?
  /// The consensus expression that triggers the Effect (optional).
  public let policyConsensus: String?
  /// The instruction to DENY or ALLOW an activity (optional).
  public let policyEffect: v1Effect?
  /// Unique identifier for a given Policy.
  public let policyId: String
  /// Human-readable name for a Policy.
  public let policyName: String?
  /// Accompanying notes for a Policy (optional).
  public let policyNotes: String?

  public init(
    policyCondition: String? = nil,
    policyConsensus: String? = nil,
    policyEffect: v1Effect? = nil,
    policyId: String,
    policyName: String? = nil,
    policyNotes: String? = nil
  ) {
    self.policyCondition = policyCondition
    self.policyConsensus = policyConsensus
    self.policyEffect = policyEffect
    self.policyId = policyId
    self.policyName = policyName
    self.policyNotes = policyNotes
  }
}

public struct v1UpdatePolicyIntentV2: Codable, Sendable {
  /// The condition expression that triggers the Effect (optional).
  public let policyCondition: String?
  /// The consensus expression that triggers the Effect (optional).
  public let policyConsensus: String?
  /// The instruction to DENY or ALLOW an activity (optional).
  public let policyEffect: v1Effect?
  /// Unique identifier for a given Policy.
  public let policyId: String
  /// Human-readable name for a Policy.
  public let policyName: String?
  /// Accompanying notes for a Policy (optional).
  public let policyNotes: String?

  public init(
    policyCondition: String? = nil,
    policyConsensus: String? = nil,
    policyEffect: v1Effect? = nil,
    policyId: String,
    policyName: String? = nil,
    policyNotes: String? = nil
  ) {
    self.policyCondition = policyCondition
    self.policyConsensus = policyConsensus
    self.policyEffect = policyEffect
    self.policyId = policyId
    self.policyName = policyName
    self.policyNotes = policyNotes
  }
}

public struct v1UpdatePolicyRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1UpdatePolicyIntentV2
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1UpdatePolicyIntentV2,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1UpdatePolicyResult: Codable, Sendable {
  /// Unique identifier for a given Policy.
  public let policyId: String

  public init(
    policyId: String
  ) {
    self.policyId = policyId
  }
}

public struct v1UpdatePolicyResultV2: Codable, Sendable {
  /// Unique identifier for a given Policy.
  public let policyId: String

  public init(
    policyId: String
  ) {
    self.policyId = policyId
  }
}

public struct v1UpdatePrivateKeyTagIntent: Codable, Sendable {
  /// A list of Private Keys IDs to add this tag to.
  public let addPrivateKeyIds: [String]
  /// The new, human-readable name for the tag with the given ID.
  public let newPrivateKeyTagName: String?
  /// Unique identifier for a given Private Key Tag.
  public let privateKeyTagId: String
  /// A list of Private Key IDs to remove this tag from.
  public let removePrivateKeyIds: [String]

  public init(
    addPrivateKeyIds: [String],
    newPrivateKeyTagName: String? = nil,
    privateKeyTagId: String,
    removePrivateKeyIds: [String]
  ) {
    self.addPrivateKeyIds = addPrivateKeyIds
    self.newPrivateKeyTagName = newPrivateKeyTagName
    self.privateKeyTagId = privateKeyTagId
    self.removePrivateKeyIds = removePrivateKeyIds
  }
}

public struct v1UpdatePrivateKeyTagRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1UpdatePrivateKeyTagIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1UpdatePrivateKeyTagIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1UpdatePrivateKeyTagResult: Codable, Sendable {
  /// Unique identifier for a given Private Key Tag.
  public let privateKeyTagId: String

  public init(
    privateKeyTagId: String
  ) {
    self.privateKeyTagId = privateKeyTagId
  }
}

public struct v1UpdateRootQuorumIntent: Codable, Sendable {
  /// The threshold of unique approvals to reach quorum.
  public let threshold: Int
  /// The unique identifiers of users who comprise the quorum set.
  public let userIds: [String]

  public init(
    threshold: Int,
    userIds: [String]
  ) {
    self.threshold = threshold
    self.userIds = userIds
  }
}

public struct v1UpdateRootQuorumRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1UpdateRootQuorumIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1UpdateRootQuorumIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1UpdateRootQuorumResult: Codable, Sendable {
  public init() {}
}

public struct v1UpdateUserEmailIntent: Codable, Sendable {
  /// The user's email address. Setting this to an empty string will remove the user's email.
  public let userEmail: String
  /// Unique identifier for a given User.
  public let userId: String
  /// Signed JWT containing a unique id, expiry, verification type, contact
  public let verificationToken: String?

  public init(
    userEmail: String,
    userId: String,
    verificationToken: String? = nil
  ) {
    self.userEmail = userEmail
    self.userId = userId
    self.verificationToken = verificationToken
  }
}

public struct v1UpdateUserEmailRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1UpdateUserEmailIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1UpdateUserEmailIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1UpdateUserEmailResult: Codable, Sendable {
  /// Unique identifier of the User whose email was updated.
  public let userId: String

  public init(
    userId: String
  ) {
    self.userId = userId
  }
}

public struct v1UpdateUserIntent: Codable, Sendable {
  /// The user's email address.
  public let userEmail: String?
  /// Unique identifier for a given User.
  public let userId: String
  /// Human-readable name for a User.
  public let userName: String?
  /// The user's phone number in E.164 format e.g. +13214567890
  public let userPhoneNumber: String?
  /// An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body.
  public let userTagIds: [String]?

  public init(
    userEmail: String? = nil,
    userId: String,
    userName: String? = nil,
    userPhoneNumber: String? = nil,
    userTagIds: [String]? = nil
  ) {
    self.userEmail = userEmail
    self.userId = userId
    self.userName = userName
    self.userPhoneNumber = userPhoneNumber
    self.userTagIds = userTagIds
  }
}

public struct v1UpdateUserNameIntent: Codable, Sendable {
  /// Unique identifier for a given User.
  public let userId: String
  /// Human-readable name for a User.
  public let userName: String

  public init(
    userId: String,
    userName: String
  ) {
    self.userId = userId
    self.userName = userName
  }
}

public struct v1UpdateUserNameRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1UpdateUserNameIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1UpdateUserNameIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1UpdateUserNameResult: Codable, Sendable {
  /// Unique identifier of the User whose name was updated.
  public let userId: String

  public init(
    userId: String
  ) {
    self.userId = userId
  }
}

public struct v1UpdateUserPhoneNumberIntent: Codable, Sendable {
  /// Unique identifier for a given User.
  public let userId: String
  /// The user's phone number in E.164 format e.g. +13214567890. Setting this to an empty string will remove the user's phone number.
  public let userPhoneNumber: String
  /// Signed JWT containing a unique id, expiry, verification type, contact
  public let verificationToken: String?

  public init(
    userId: String,
    userPhoneNumber: String,
    verificationToken: String? = nil
  ) {
    self.userId = userId
    self.userPhoneNumber = userPhoneNumber
    self.verificationToken = verificationToken
  }
}

public struct v1UpdateUserPhoneNumberRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1UpdateUserPhoneNumberIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1UpdateUserPhoneNumberIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1UpdateUserPhoneNumberResult: Codable, Sendable {
  /// Unique identifier of the User whose phone number was updated.
  public let userId: String

  public init(
    userId: String
  ) {
    self.userId = userId
  }
}

public struct v1UpdateUserRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1UpdateUserIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1UpdateUserIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1UpdateUserResult: Codable, Sendable {
  /// A User ID.
  public let userId: String

  public init(
    userId: String
  ) {
    self.userId = userId
  }
}

public struct v1UpdateUserTagIntent: Codable, Sendable {
  /// A list of User IDs to add this tag to.
  public let addUserIds: [String]
  /// The new, human-readable name for the tag with the given ID.
  public let newUserTagName: String?
  /// A list of User IDs to remove this tag from.
  public let removeUserIds: [String]
  /// Unique identifier for a given User Tag.
  public let userTagId: String

  public init(
    addUserIds: [String],
    newUserTagName: String? = nil,
    removeUserIds: [String],
    userTagId: String
  ) {
    self.addUserIds = addUserIds
    self.newUserTagName = newUserTagName
    self.removeUserIds = removeUserIds
    self.userTagId = userTagId
  }
}

public struct v1UpdateUserTagRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1UpdateUserTagIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1UpdateUserTagIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1UpdateUserTagResult: Codable, Sendable {
  /// Unique identifier for a given User Tag.
  public let userTagId: String

  public init(
    userTagId: String
  ) {
    self.userTagId = userTagId
  }
}

public struct v1UpdateWalletIntent: Codable, Sendable {
  /// Unique identifier for a given Wallet.
  public let walletId: String
  /// Human-readable name for a Wallet.
  public let walletName: String?

  public init(
    walletId: String,
    walletName: String? = nil
  ) {
    self.walletId = walletId
    self.walletName = walletName
  }
}

public struct v1UpdateWalletRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1UpdateWalletIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1UpdateWalletIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1UpdateWalletResult: Codable, Sendable {
  /// A Wallet ID.
  public let walletId: String

  public init(
    walletId: String
  ) {
    self.walletId = walletId
  }
}

public enum v1UsageType: String, Codable, Sendable {
  case usage_type_signup = "USAGE_TYPE_SIGNUP"
  case usage_type_login = "USAGE_TYPE_LOGIN"
}

public struct v1User: Codable, Sendable {
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  public let apiKeys: [v1ApiKey]
  /// A list of Authenticator parameters.
  public let authenticators: [v1Authenticator]
  public let createdAt: externaldatav1Timestamp
  /// A list of Oauth Providers.
  public let oauthProviders: [v1OauthProvider]
  public let updatedAt: externaldatav1Timestamp
  /// The user's email address.
  public let userEmail: String?
  /// Unique identifier for a given User.
  public let userId: String
  /// Human-readable name for a User.
  public let userName: String
  /// The user's phone number in E.164 format e.g. +13214567890
  public let userPhoneNumber: String?
  /// A list of User Tag IDs.
  public let userTags: [String]

  public init(
    apiKeys: [v1ApiKey],
    authenticators: [v1Authenticator],
    createdAt: externaldatav1Timestamp,
    oauthProviders: [v1OauthProvider],
    updatedAt: externaldatav1Timestamp,
    userEmail: String? = nil,
    userId: String,
    userName: String,
    userPhoneNumber: String? = nil,
    userTags: [String]
  ) {
    self.apiKeys = apiKeys
    self.authenticators = authenticators
    self.createdAt = createdAt
    self.oauthProviders = oauthProviders
    self.updatedAt = updatedAt
    self.userEmail = userEmail
    self.userId = userId
    self.userName = userName
    self.userPhoneNumber = userPhoneNumber
    self.userTags = userTags
  }
}

public struct v1UserParams: Codable, Sendable {
  /// The User's permissible access method(s).
  public let accessType: v1AccessType
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  public let apiKeys: [apiApiKeyParams]
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  public let authenticators: [v1AuthenticatorParams]
  /// The user's email address.
  public let userEmail: String?
  /// Human-readable name for a User.
  public let userName: String
  /// A list of User Tag IDs. This field, if not needed, should be an empty array in your request body.
  public let userTags: [String]

  public init(
    accessType: v1AccessType,
    apiKeys: [apiApiKeyParams],
    authenticators: [v1AuthenticatorParams],
    userEmail: String? = nil,
    userName: String,
    userTags: [String]
  ) {
    self.accessType = accessType
    self.apiKeys = apiKeys
    self.authenticators = authenticators
    self.userEmail = userEmail
    self.userName = userName
    self.userTags = userTags
  }
}

public struct v1UserParamsV2: Codable, Sendable {
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  public let apiKeys: [apiApiKeyParams]
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  public let authenticators: [v1AuthenticatorParamsV2]
  /// The user's email address.
  public let userEmail: String?
  /// Human-readable name for a User.
  public let userName: String
  /// A list of User Tag IDs. This field, if not needed, should be an empty array in your request body.
  public let userTags: [String]

  public init(
    apiKeys: [apiApiKeyParams],
    authenticators: [v1AuthenticatorParamsV2],
    userEmail: String? = nil,
    userName: String,
    userTags: [String]
  ) {
    self.apiKeys = apiKeys
    self.authenticators = authenticators
    self.userEmail = userEmail
    self.userName = userName
    self.userTags = userTags
  }
}

public struct v1UserParamsV3: Codable, Sendable {
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  public let apiKeys: [v1ApiKeyParamsV2]
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  public let authenticators: [v1AuthenticatorParamsV2]
  /// A list of Oauth providers. This field, if not needed, should be an empty array in your request body.
  public let oauthProviders: [v1OauthProviderParams]
  /// The user's email address.
  public let userEmail: String?
  /// Human-readable name for a User.
  public let userName: String
  /// The user's phone number in E.164 format e.g. +13214567890
  public let userPhoneNumber: String?
  /// A list of User Tag IDs. This field, if not needed, should be an empty array in your request body.
  public let userTags: [String]

  public init(
    apiKeys: [v1ApiKeyParamsV2],
    authenticators: [v1AuthenticatorParamsV2],
    oauthProviders: [v1OauthProviderParams],
    userEmail: String? = nil,
    userName: String,
    userPhoneNumber: String? = nil,
    userTags: [String]
  ) {
    self.apiKeys = apiKeys
    self.authenticators = authenticators
    self.oauthProviders = oauthProviders
    self.userEmail = userEmail
    self.userName = userName
    self.userPhoneNumber = userPhoneNumber
    self.userTags = userTags
  }
}

public struct v1VerifyOtpIntent: Codable, Sendable {
  /// Expiration window (in seconds) indicating how long the verification token is valid for. If not provided, a default of 1 hour will be used. Maximum value is 86400 seconds (24 hours)
  public let expirationSeconds: String?
  /// OTP sent out to a user's contact (email or SMS)
  public let otpCode: String
  /// ID representing the result of an init OTP activity.
  public let otpId: String
  /// Client-side public key generated by the user, which will be added to the JWT response and verified in subsequent requests via a client proof signature
  public let publicKey: String?

  public init(
    expirationSeconds: String? = nil,
    otpCode: String,
    otpId: String,
    publicKey: String? = nil
  ) {
    self.expirationSeconds = expirationSeconds
    self.otpCode = otpCode
    self.otpId = otpId
    self.publicKey = publicKey
  }
}

public struct v1VerifyOtpRequest: Codable, Sendable {
  public let generateAppProofs: Bool?
  /// Unique identifier for a given Organization.
  public let organizationId: String
  public let parameters: v1VerifyOtpIntent
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  public let timestampMs: String
  public let type: String

  public init(
    generateAppProofs: Bool? = nil,
    organizationId: String,
    parameters: v1VerifyOtpIntent,
    timestampMs: String,
    type: String
  ) {
    self.generateAppProofs = generateAppProofs
    self.organizationId = organizationId
    self.parameters = parameters
    self.timestampMs = timestampMs
    self.type = type
  }
}

public struct v1VerifyOtpResult: Codable, Sendable {
  /// Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests)
  public let verificationToken: String

  public init(
    verificationToken: String
  ) {
    self.verificationToken = verificationToken
  }
}

public struct v1Vote: Codable, Sendable {
  /// Unique identifier for a given Activity object.
  public let activityId: String
  public let createdAt: externaldatav1Timestamp
  /// Unique identifier for a given Vote object.
  public let id: String
  /// The raw message being signed within a Vote.
  public let message: String
  /// The public component of a cryptographic key pair used to sign messages and transactions.
  public let publicKey: String
  /// Method used to produce a signature.
  public let scheme: String
  public let selection: String
  /// The signature applied to a particular vote.
  public let signature: String
  /// Web and/or API user within your Organization.
  public let user: v1User
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    activityId: String,
    createdAt: externaldatav1Timestamp,
    id: String,
    message: String,
    publicKey: String,
    scheme: String,
    selection: String,
    signature: String,
    user: v1User,
    userId: String
  ) {
    self.activityId = activityId
    self.createdAt = createdAt
    self.id = id
    self.message = message
    self.publicKey = publicKey
    self.scheme = scheme
    self.selection = selection
    self.signature = signature
    self.user = user
    self.userId = userId
  }
}

public struct v1Wallet: Codable, Sendable {
  public let createdAt: externaldatav1Timestamp
  /// True when a given Wallet is exported, false otherwise.
  public let exported: Bool
  /// True when a given Wallet is imported, false otherwise.
  public let imported: Bool
  public let updatedAt: externaldatav1Timestamp
  /// Unique identifier for a given Wallet.
  public let walletId: String
  /// Human-readable name for a Wallet.
  public let walletName: String

  public init(
    createdAt: externaldatav1Timestamp,
    exported: Bool,
    imported: Bool,
    updatedAt: externaldatav1Timestamp,
    walletId: String,
    walletName: String
  ) {
    self.createdAt = createdAt
    self.exported = exported
    self.imported = imported
    self.updatedAt = updatedAt
    self.walletId = walletId
    self.walletName = walletName
  }
}

public struct v1WalletAccount: Codable, Sendable {
  /// Address generated using the Wallet seed and Account parameters.
  public let address: String
  /// Address format used to generate the Account.
  public let addressFormat: v1AddressFormat
  public let createdAt: externaldatav1Timestamp
  /// Cryptographic curve used to generate the Account.
  public let curve: v1Curve
  /// The Organization the Account belongs to.
  public let organizationId: String
  /// Path used to generate the Account.
  public let path: String
  /// Path format used to generate the Account.
  public let pathFormat: v1PathFormat
  /// The public component of this wallet account's underlying cryptographic key pair.
  public let publicKey: String?
  public let updatedAt: externaldatav1Timestamp
  /// Unique identifier for a given Wallet Account.
  public let walletAccountId: String
  /// Wallet details for this account. This is only present when include_wallet_details=true.
  public let walletDetails: v1Wallet?
  /// The Wallet the Account was derived from.
  public let walletId: String

  public init(
    address: String,
    addressFormat: v1AddressFormat,
    createdAt: externaldatav1Timestamp,
    curve: v1Curve,
    organizationId: String,
    path: String,
    pathFormat: v1PathFormat,
    publicKey: String? = nil,
    updatedAt: externaldatav1Timestamp,
    walletAccountId: String,
    walletDetails: v1Wallet? = nil,
    walletId: String
  ) {
    self.address = address
    self.addressFormat = addressFormat
    self.createdAt = createdAt
    self.curve = curve
    self.organizationId = organizationId
    self.path = path
    self.pathFormat = pathFormat
    self.publicKey = publicKey
    self.updatedAt = updatedAt
    self.walletAccountId = walletAccountId
    self.walletDetails = walletDetails
    self.walletId = walletId
  }
}

public struct v1WalletAccountParams: Codable, Sendable {
  /// Address format used to generate a wallet Acccount.
  public let addressFormat: v1AddressFormat
  /// Cryptographic curve used to generate a wallet Account.
  public let curve: v1Curve
  /// Path used to generate a wallet Account.
  public let path: String
  /// Path format used to generate a wallet Account.
  public let pathFormat: v1PathFormat

  public init(
    addressFormat: v1AddressFormat,
    curve: v1Curve,
    path: String,
    pathFormat: v1PathFormat
  ) {
    self.addressFormat = addressFormat
    self.curve = curve
    self.path = path
    self.pathFormat = pathFormat
  }
}

public struct v1WalletKitSettingsParams: Codable, Sendable {
  /// List of enabled social login providers (e.g., 'apple', 'google', 'facebook')
  public let enabledSocialProviders: [String]?
  /// Mapping of social login providers to their Oauth client IDs.
  public let oauthClientIds: [String: String]?
  /// Oauth redirect URL to be used for social login flows.
  public let oauthRedirectUrl: String?

  public init(
    enabledSocialProviders: [String]? = nil,
    oauthClientIds: [String: String]? = nil,
    oauthRedirectUrl: String? = nil
  ) {
    self.enabledSocialProviders = enabledSocialProviders
    self.oauthClientIds = oauthClientIds
    self.oauthRedirectUrl = oauthRedirectUrl
  }
}

public struct v1WalletParams: Codable, Sendable {
  /// A list of wallet Accounts. This field, if not needed, should be an empty array in your request body.
  public let accounts: [v1WalletAccountParams]
  /// Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24.
  public let mnemonicLength: Int?
  /// Human-readable name for a Wallet.
  public let walletName: String

  public init(
    accounts: [v1WalletAccountParams],
    mnemonicLength: Int? = nil,
    walletName: String
  ) {
    self.accounts = accounts
    self.mnemonicLength = mnemonicLength
    self.walletName = walletName
  }
}

public struct v1WalletResult: Codable, Sendable {
  /// A list of account addresses.
  public let addresses: [String]
  public let walletId: String

  public init(
    addresses: [String],
    walletId: String
  ) {
    self.addresses = addresses
    self.walletId = walletId
  }
}

public struct v1WebAuthnStamp: Codable, Sendable {
  /// A base64 encoded payload containing metadata about the authenticator.
  public let authenticatorData: String
  /// A base64 encoded payload containing metadata about the signing context and the challenge.
  public let clientDataJson: String
  /// A base64 url encoded Unique identifier for a given credential.
  public let credentialId: String
  /// The base64 url encoded signature bytes contained within the WebAuthn assertion response.
  public let signature: String

  public init(
    authenticatorData: String,
    clientDataJson: String,
    credentialId: String,
    signature: String
  ) {
    self.authenticatorData = authenticatorData
    self.clientDataJson = clientDataJson
    self.credentialId = credentialId
    self.signature = signature
  }
}

// MARK: - API Types from Swagger Paths

// MARK: - TGetActivityResponse

public struct TGetActivityResponse: Codable, Sendable {
  /// An action that can be taken within the Turnkey infrastructure.
  public let activity: v1Activity
}

// MARK: - TGetActivityBody

public struct TGetActivityBody: Codable, Sendable {
  public let organizationId: String?
  /// Unique identifier for a given activity object.
  public let activityId: String

  public init(
    organizationId: String? = nil,
    activityId: String
  ) {
    self.organizationId = organizationId
    self.activityId = activityId
  }
}

// MARK: - TGetActivityInput

public struct TGetActivityInput: Codable, Sendable {
  public let body: TGetActivityBody

  public init(
    body: TGetActivityBody
  ) {
    self.body = body
  }
}

// MARK: - TGetApiKeyResponse

public struct TGetApiKeyResponse: Codable, Sendable {
  /// An API key.
  public let apiKey: v1ApiKey
}

// MARK: - TGetApiKeyBody

public struct TGetApiKeyBody: Codable, Sendable {
  public let organizationId: String?
  /// Unique identifier for a given API key.
  public let apiKeyId: String

  public init(
    organizationId: String? = nil,
    apiKeyId: String
  ) {
    self.organizationId = organizationId
    self.apiKeyId = apiKeyId
  }
}

// MARK: - TGetApiKeyInput

public struct TGetApiKeyInput: Codable, Sendable {
  public let body: TGetApiKeyBody

  public init(
    body: TGetApiKeyBody
  ) {
    self.body = body
  }
}

// MARK: - TGetApiKeysResponse

public struct TGetApiKeysResponse: Codable, Sendable {
  /// A list of API keys.
  public let apiKeys: [v1ApiKey]
}

// MARK: - TGetApiKeysBody

public struct TGetApiKeysBody: Codable, Sendable {
  public let organizationId: String?
  /// Unique identifier for a given user.
  public let userId: String?

  public init(
    organizationId: String? = nil,
    userId: String? = nil
  ) {
    self.organizationId = organizationId
    self.userId = userId
  }
}

// MARK: - TGetApiKeysInput

public struct TGetApiKeysInput: Codable, Sendable {
  public let body: TGetApiKeysBody

  public init(
    body: TGetApiKeysBody
  ) {
    self.body = body
  }
}

// MARK: - TGetAttestationDocumentResponse

public struct TGetAttestationDocumentResponse: Codable, Sendable {
  /// Raw (CBOR-encoded) attestation document.
  public let attestationDocument: String
}

// MARK: - TGetAttestationDocumentBody

public struct TGetAttestationDocumentBody: Codable, Sendable {
  public let organizationId: String?
  /// The enclave type, one of: ump, notarizer, signer, evm-parser.
  public let enclaveType: String

  public init(
    organizationId: String? = nil,
    enclaveType: String
  ) {
    self.organizationId = organizationId
    self.enclaveType = enclaveType
  }
}

// MARK: - TGetAttestationDocumentInput

public struct TGetAttestationDocumentInput: Codable, Sendable {
  public let body: TGetAttestationDocumentBody

  public init(
    body: TGetAttestationDocumentBody
  ) {
    self.body = body
  }
}

// MARK: - TGetAuthenticatorResponse

public struct TGetAuthenticatorResponse: Codable, Sendable {
  /// An authenticator.
  public let authenticator: v1Authenticator
}

// MARK: - TGetAuthenticatorBody

public struct TGetAuthenticatorBody: Codable, Sendable {
  public let organizationId: String?
  /// Unique identifier for a given authenticator.
  public let authenticatorId: String

  public init(
    organizationId: String? = nil,
    authenticatorId: String
  ) {
    self.organizationId = organizationId
    self.authenticatorId = authenticatorId
  }
}

// MARK: - TGetAuthenticatorInput

public struct TGetAuthenticatorInput: Codable, Sendable {
  public let body: TGetAuthenticatorBody

  public init(
    body: TGetAuthenticatorBody
  ) {
    self.body = body
  }
}

// MARK: - TGetAuthenticatorsResponse

public struct TGetAuthenticatorsResponse: Codable, Sendable {
  /// A list of authenticators.
  public let authenticators: [v1Authenticator]
}

// MARK: - TGetAuthenticatorsBody

public struct TGetAuthenticatorsBody: Codable, Sendable {
  public let organizationId: String?
  /// Unique identifier for a given user.
  public let userId: String

  public init(
    organizationId: String? = nil,
    userId: String
  ) {
    self.organizationId = organizationId
    self.userId = userId
  }
}

// MARK: - TGetAuthenticatorsInput

public struct TGetAuthenticatorsInput: Codable, Sendable {
  public let body: TGetAuthenticatorsBody

  public init(
    body: TGetAuthenticatorsBody
  ) {
    self.body = body
  }
}

// MARK: - TGetBootProofResponse

public struct TGetBootProofResponse: Codable, Sendable {
  public let bootProof: v1BootProof
}

// MARK: - TGetBootProofBody

public struct TGetBootProofBody: Codable, Sendable {
  public let organizationId: String?
  /// Hex encoded ephemeral public key.
  public let ephemeralKey: String

  public init(
    organizationId: String? = nil,
    ephemeralKey: String
  ) {
    self.organizationId = organizationId
    self.ephemeralKey = ephemeralKey
  }
}

// MARK: - TGetBootProofInput

public struct TGetBootProofInput: Codable, Sendable {
  public let body: TGetBootProofBody

  public init(
    body: TGetBootProofBody
  ) {
    self.body = body
  }
}

// MARK: - TGetGasUsageResponse

public struct TGetGasUsageResponse: Codable, Sendable {
  /// The total gas usage (in USD) of all sponsored transactions processed over the last `window_duration_minutes`
  public let usageUsd: String
  /// The window duration (in minutes) for the organization or sub-organization.
  public let windowDurationMinutes: Int
  /// The window limit (in USD) for the organization or sub-organization.
  public let windowLimitUsd: String
}

// MARK: - TGetGasUsageBody

public struct TGetGasUsageBody: Codable, Sendable {
  public let organizationId: String?

  public init(
    organizationId: String? = nil
  ) {
    self.organizationId = organizationId
  }
}

// MARK: - TGetGasUsageInput

public struct TGetGasUsageInput: Codable, Sendable {
  public let body: TGetGasUsageBody

  public init(
    body: TGetGasUsageBody
  ) {
    self.body = body
  }
}

// MARK: - TGetLatestBootProofResponse

public struct TGetLatestBootProofResponse: Codable, Sendable {
  public let bootProof: v1BootProof
}

// MARK: - TGetLatestBootProofBody

public struct TGetLatestBootProofBody: Codable, Sendable {
  public let organizationId: String?
  /// Name of enclave app.
  public let appName: String

  public init(
    organizationId: String? = nil,
    appName: String
  ) {
    self.organizationId = organizationId
    self.appName = appName
  }
}

// MARK: - TGetLatestBootProofInput

public struct TGetLatestBootProofInput: Codable, Sendable {
  public let body: TGetLatestBootProofBody

  public init(
    body: TGetLatestBootProofBody
  ) {
    self.body = body
  }
}

// MARK: - TGetOauth2CredentialResponse

public struct TGetOauth2CredentialResponse: Codable, Sendable {
  public let oauth2Credential: v1Oauth2Credential
}

// MARK: - TGetOauth2CredentialBody

public struct TGetOauth2CredentialBody: Codable, Sendable {
  public let organizationId: String?
  /// Unique identifier for a given OAuth 2.0 Credential.
  public let oauth2CredentialId: String

  public init(
    organizationId: String? = nil,
    oauth2CredentialId: String
  ) {
    self.organizationId = organizationId
    self.oauth2CredentialId = oauth2CredentialId
  }
}

// MARK: - TGetOauth2CredentialInput

public struct TGetOauth2CredentialInput: Codable, Sendable {
  public let body: TGetOauth2CredentialBody

  public init(
    body: TGetOauth2CredentialBody
  ) {
    self.body = body
  }
}

// MARK: - TGetOauthProvidersResponse

public struct TGetOauthProvidersResponse: Codable, Sendable {
  /// A list of Oauth providers.
  public let oauthProviders: [v1OauthProvider]
}

// MARK: - TGetOauthProvidersBody

public struct TGetOauthProvidersBody: Codable, Sendable {
  public let organizationId: String?
  /// Unique identifier for a given user.
  public let userId: String?

  public init(
    organizationId: String? = nil,
    userId: String? = nil
  ) {
    self.organizationId = organizationId
    self.userId = userId
  }
}

// MARK: - TGetOauthProvidersInput

public struct TGetOauthProvidersInput: Codable, Sendable {
  public let body: TGetOauthProvidersBody

  public init(
    body: TGetOauthProvidersBody
  ) {
    self.body = body
  }
}

// MARK: - TGetOnRampTransactionStatusResponse

public struct TGetOnRampTransactionStatusResponse: Codable, Sendable {
  /// The status of the fiat on ramp transaction.
  public let transactionStatus: String
}

// MARK: - TGetOnRampTransactionStatusBody

public struct TGetOnRampTransactionStatusBody: Codable, Sendable {
  public let organizationId: String?
  /// Optional flag to specify if the transaction status should be refreshed from the fiat on ramp provider. Default = false.
  public let refresh: Bool?
  /// The unique identifier for the fiat on ramp transaction.
  public let transactionId: String

  public init(
    organizationId: String? = nil,
    refresh: Bool? = nil,
    transactionId: String
  ) {
    self.organizationId = organizationId
    self.refresh = refresh
    self.transactionId = transactionId
  }
}

// MARK: - TGetOnRampTransactionStatusInput

public struct TGetOnRampTransactionStatusInput: Codable, Sendable {
  public let body: TGetOnRampTransactionStatusBody

  public init(
    body: TGetOnRampTransactionStatusBody
  ) {
    self.body = body
  }
}

// MARK: - TGetOrganizationResponse

public struct TGetOrganizationResponse: Codable, Sendable {
  /// Object representing the full current and deleted / disabled collection of users, policies, private keys, and invitations attributable to a particular organization.
  public let organizationData: v1OrganizationData
}

// MARK: - TGetOrganizationBody

public struct TGetOrganizationBody: Codable, Sendable {
  public let organizationId: String?

  public init(
    organizationId: String? = nil
  ) {
    self.organizationId = organizationId
  }
}

// MARK: - TGetOrganizationInput

public struct TGetOrganizationInput: Codable, Sendable {
  public let body: TGetOrganizationBody

  public init(
    body: TGetOrganizationBody
  ) {
    self.body = body
  }
}

// MARK: - TGetOrganizationConfigsResponse

public struct TGetOrganizationConfigsResponse: Codable, Sendable {
  /// Organization configs including quorum settings and organization features.
  public let configs: v1Config
}

// MARK: - TGetOrganizationConfigsBody

public struct TGetOrganizationConfigsBody: Codable, Sendable {
  public let organizationId: String?

  public init(
    organizationId: String? = nil
  ) {
    self.organizationId = organizationId
  }
}

// MARK: - TGetOrganizationConfigsInput

public struct TGetOrganizationConfigsInput: Codable, Sendable {
  public let body: TGetOrganizationConfigsBody

  public init(
    body: TGetOrganizationConfigsBody
  ) {
    self.body = body
  }
}

// MARK: - TGetPolicyResponse

public struct TGetPolicyResponse: Codable, Sendable {
  /// Object that codifies rules defining the actions that are permissible within an organization.
  public let policy: v1Policy
}

// MARK: - TGetPolicyBody

public struct TGetPolicyBody: Codable, Sendable {
  public let organizationId: String?
  /// Unique identifier for a given policy.
  public let policyId: String

  public init(
    organizationId: String? = nil,
    policyId: String
  ) {
    self.organizationId = organizationId
    self.policyId = policyId
  }
}

// MARK: - TGetPolicyInput

public struct TGetPolicyInput: Codable, Sendable {
  public let body: TGetPolicyBody

  public init(
    body: TGetPolicyBody
  ) {
    self.body = body
  }
}

// MARK: - TGetPolicyEvaluationsResponse

public struct TGetPolicyEvaluationsResponse: Codable, Sendable {
  public let policyEvaluations: [externalactivityv1PolicyEvaluation]
}

// MARK: - TGetPolicyEvaluationsBody

public struct TGetPolicyEvaluationsBody: Codable, Sendable {
  public let organizationId: String?
  /// Unique identifier for a given activity.
  public let activityId: String

  public init(
    organizationId: String? = nil,
    activityId: String
  ) {
    self.organizationId = organizationId
    self.activityId = activityId
  }
}

// MARK: - TGetPolicyEvaluationsInput

public struct TGetPolicyEvaluationsInput: Codable, Sendable {
  public let body: TGetPolicyEvaluationsBody

  public init(
    body: TGetPolicyEvaluationsBody
  ) {
    self.body = body
  }
}

// MARK: - TGetPrivateKeyResponse

public struct TGetPrivateKeyResponse: Codable, Sendable {
  /// Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption.
  public let privateKey: v1PrivateKey
}

// MARK: - TGetPrivateKeyBody

public struct TGetPrivateKeyBody: Codable, Sendable {
  public let organizationId: String?
  /// Unique identifier for a given private key.
  public let privateKeyId: String

  public init(
    organizationId: String? = nil,
    privateKeyId: String
  ) {
    self.organizationId = organizationId
    self.privateKeyId = privateKeyId
  }
}

// MARK: - TGetPrivateKeyInput

public struct TGetPrivateKeyInput: Codable, Sendable {
  public let body: TGetPrivateKeyBody

  public init(
    body: TGetPrivateKeyBody
  ) {
    self.body = body
  }
}

// MARK: - TGetSendTransactionStatusResponse

public struct TGetSendTransactionStatusResponse: Codable, Sendable {
  /// Ethereum-specific transaction status.
  public let eth: v1EthSendTransactionStatus?
  /// The error encountered when broadcasting or confirming the transaction, if any.
  public let txError: String?
  /// The current status of the send transaction.
  public let txStatus: String
}

// MARK: - TGetSendTransactionStatusBody

public struct TGetSendTransactionStatusBody: Codable, Sendable {
  public let organizationId: String?
  /// The unique identifier of a send transaction request.
  public let sendTransactionStatusId: String

  public init(
    organizationId: String? = nil,
    sendTransactionStatusId: String
  ) {
    self.organizationId = organizationId
    self.sendTransactionStatusId = sendTransactionStatusId
  }
}

// MARK: - TGetSendTransactionStatusInput

public struct TGetSendTransactionStatusInput: Codable, Sendable {
  public let body: TGetSendTransactionStatusBody

  public init(
    body: TGetSendTransactionStatusBody
  ) {
    self.body = body
  }
}

// MARK: - TGetSmartContractInterfaceResponse

public struct TGetSmartContractInterfaceResponse: Codable, Sendable {
  /// Object to be used in conjunction with policies to guard transaction signing.
  public let smartContractInterface: externaldatav1SmartContractInterface
}

// MARK: - TGetSmartContractInterfaceBody

public struct TGetSmartContractInterfaceBody: Codable, Sendable {
  public let organizationId: String?
  /// Unique identifier for a given smart contract interface.
  public let smartContractInterfaceId: String

  public init(
    organizationId: String? = nil,
    smartContractInterfaceId: String
  ) {
    self.organizationId = organizationId
    self.smartContractInterfaceId = smartContractInterfaceId
  }
}

// MARK: - TGetSmartContractInterfaceInput

public struct TGetSmartContractInterfaceInput: Codable, Sendable {
  public let body: TGetSmartContractInterfaceBody

  public init(
    body: TGetSmartContractInterfaceBody
  ) {
    self.body = body
  }
}

// MARK: - TGetUserResponse

public struct TGetUserResponse: Codable, Sendable {
  /// Web and/or API user within your organization.
  public let user: v1User
}

// MARK: - TGetUserBody

public struct TGetUserBody: Codable, Sendable {
  public let organizationId: String?
  /// Unique identifier for a given user.
  public let userId: String

  public init(
    organizationId: String? = nil,
    userId: String
  ) {
    self.organizationId = organizationId
    self.userId = userId
  }
}

// MARK: - TGetUserInput

public struct TGetUserInput: Codable, Sendable {
  public let body: TGetUserBody

  public init(
    body: TGetUserBody
  ) {
    self.body = body
  }
}

// MARK: - TGetWalletResponse

public struct TGetWalletResponse: Codable, Sendable {
  /// A collection of deterministically generated cryptographic public / private key pairs that share a common seed.
  public let wallet: v1Wallet
}

// MARK: - TGetWalletBody

public struct TGetWalletBody: Codable, Sendable {
  public let organizationId: String?
  /// Unique identifier for a given wallet.
  public let walletId: String

  public init(
    organizationId: String? = nil,
    walletId: String
  ) {
    self.organizationId = organizationId
    self.walletId = walletId
  }
}

// MARK: - TGetWalletInput

public struct TGetWalletInput: Codable, Sendable {
  public let body: TGetWalletBody

  public init(
    body: TGetWalletBody
  ) {
    self.body = body
  }
}

// MARK: - TGetWalletAccountResponse

public struct TGetWalletAccountResponse: Codable, Sendable {
  /// The resulting wallet account.
  public let account: v1WalletAccount
}

// MARK: - TGetWalletAccountBody

public struct TGetWalletAccountBody: Codable, Sendable {
  public let organizationId: String?
  /// Address corresponding to a wallet account.
  public let address: String?
  /// Path corresponding to a wallet account.
  public let path: String?
  /// Unique identifier for a given wallet.
  public let walletId: String

  public init(
    organizationId: String? = nil,
    address: String? = nil,
    path: String? = nil,
    walletId: String
  ) {
    self.organizationId = organizationId
    self.address = address
    self.path = path
    self.walletId = walletId
  }
}

// MARK: - TGetWalletAccountInput

public struct TGetWalletAccountInput: Codable, Sendable {
  public let body: TGetWalletAccountBody

  public init(
    body: TGetWalletAccountBody
  ) {
    self.body = body
  }
}

// MARK: - TGetActivitiesResponse

public struct TGetActivitiesResponse: Codable, Sendable {
  /// A list of activities.
  public let activities: [v1Activity]
}

// MARK: - TGetActivitiesBody

public struct TGetActivitiesBody: Codable, Sendable {
  public let organizationId: String?
  /// Array of activity statuses filtering which activities will be listed in the response.
  public let filterByStatus: [v1ActivityStatus]?
  /// Array of activity types filtering which activities will be listed in the response.
  public let filterByType: [v1ActivityType]?
  /// Parameters used for cursor-based pagination.
  public let paginationOptions: v1Pagination?

  public init(
    organizationId: String? = nil,
    filterByStatus: [v1ActivityStatus]? = nil,
    filterByType: [v1ActivityType]? = nil,
    paginationOptions: v1Pagination? = nil
  ) {
    self.organizationId = organizationId
    self.filterByStatus = filterByStatus
    self.filterByType = filterByType
    self.paginationOptions = paginationOptions
  }
}

// MARK: - TGetActivitiesInput

public struct TGetActivitiesInput: Codable, Sendable {
  public let body: TGetActivitiesBody

  public init(
    body: TGetActivitiesBody
  ) {
    self.body = body
  }
}

// MARK: - TGetAppProofsResponse

public struct TGetAppProofsResponse: Codable, Sendable {
  public let appProofs: [v1AppProof]
}

// MARK: - TGetAppProofsBody

public struct TGetAppProofsBody: Codable, Sendable {
  public let organizationId: String?
  /// Unique identifier for a given activity.
  public let activityId: String

  public init(
    organizationId: String? = nil,
    activityId: String
  ) {
    self.organizationId = organizationId
    self.activityId = activityId
  }
}

// MARK: - TGetAppProofsInput

public struct TGetAppProofsInput: Codable, Sendable {
  public let body: TGetAppProofsBody

  public init(
    body: TGetAppProofsBody
  ) {
    self.body = body
  }
}

// MARK: - TListFiatOnRampCredentialsResponse

public struct TListFiatOnRampCredentialsResponse: Codable, Sendable {
  public let fiatOnRampCredentials: [v1FiatOnRampCredential]
}

// MARK: - TListFiatOnRampCredentialsBody

public struct TListFiatOnRampCredentialsBody: Codable, Sendable {
  public let organizationId: String?

  public init(
    organizationId: String? = nil
  ) {
    self.organizationId = organizationId
  }
}

// MARK: - TListFiatOnRampCredentialsInput

public struct TListFiatOnRampCredentialsInput: Codable, Sendable {
  public let body: TListFiatOnRampCredentialsBody

  public init(
    body: TListFiatOnRampCredentialsBody
  ) {
    self.body = body
  }
}

// MARK: - TListOauth2CredentialsResponse

public struct TListOauth2CredentialsResponse: Codable, Sendable {
  public let oauth2Credentials: [v1Oauth2Credential]
}

// MARK: - TListOauth2CredentialsBody

public struct TListOauth2CredentialsBody: Codable, Sendable {
  public let organizationId: String?

  public init(
    organizationId: String? = nil
  ) {
    self.organizationId = organizationId
  }
}

// MARK: - TListOauth2CredentialsInput

public struct TListOauth2CredentialsInput: Codable, Sendable {
  public let body: TListOauth2CredentialsBody

  public init(
    body: TListOauth2CredentialsBody
  ) {
    self.body = body
  }
}

// MARK: - TGetPoliciesResponse

public struct TGetPoliciesResponse: Codable, Sendable {
  /// A list of policies.
  public let policies: [v1Policy]
}

// MARK: - TGetPoliciesBody

public struct TGetPoliciesBody: Codable, Sendable {
  public let organizationId: String?

  public init(
    organizationId: String? = nil
  ) {
    self.organizationId = organizationId
  }
}

// MARK: - TGetPoliciesInput

public struct TGetPoliciesInput: Codable, Sendable {
  public let body: TGetPoliciesBody

  public init(
    body: TGetPoliciesBody
  ) {
    self.body = body
  }
}

// MARK: - TListPrivateKeyTagsResponse

public struct TListPrivateKeyTagsResponse: Codable, Sendable {
  /// A list of private key tags.
  public let privateKeyTags: [datav1Tag]
}

// MARK: - TListPrivateKeyTagsBody

public struct TListPrivateKeyTagsBody: Codable, Sendable {
  public let organizationId: String?

  public init(
    organizationId: String? = nil
  ) {
    self.organizationId = organizationId
  }
}

// MARK: - TListPrivateKeyTagsInput

public struct TListPrivateKeyTagsInput: Codable, Sendable {
  public let body: TListPrivateKeyTagsBody

  public init(
    body: TListPrivateKeyTagsBody
  ) {
    self.body = body
  }
}

// MARK: - TGetPrivateKeysResponse

public struct TGetPrivateKeysResponse: Codable, Sendable {
  /// A list of private keys.
  public let privateKeys: [v1PrivateKey]
}

// MARK: - TGetPrivateKeysBody

public struct TGetPrivateKeysBody: Codable, Sendable {
  public let organizationId: String?

  public init(
    organizationId: String? = nil
  ) {
    self.organizationId = organizationId
  }
}

// MARK: - TGetPrivateKeysInput

public struct TGetPrivateKeysInput: Codable, Sendable {
  public let body: TGetPrivateKeysBody

  public init(
    body: TGetPrivateKeysBody
  ) {
    self.body = body
  }
}

// MARK: - TGetSmartContractInterfacesResponse

public struct TGetSmartContractInterfacesResponse: Codable, Sendable {
  /// A list of smart contract interfaces.
  public let smartContractInterfaces: [externaldatav1SmartContractInterface]
}

// MARK: - TGetSmartContractInterfacesBody

public struct TGetSmartContractInterfacesBody: Codable, Sendable {
  public let organizationId: String?

  public init(
    organizationId: String? = nil
  ) {
    self.organizationId = organizationId
  }
}

// MARK: - TGetSmartContractInterfacesInput

public struct TGetSmartContractInterfacesInput: Codable, Sendable {
  public let body: TGetSmartContractInterfacesBody

  public init(
    body: TGetSmartContractInterfacesBody
  ) {
    self.body = body
  }
}

// MARK: - TGetSubOrgIdsResponse

public struct TGetSubOrgIdsResponse: Codable, Sendable {
  /// List of unique identifiers for the matching sub-organizations.
  public let organizationIds: [String]
}

// MARK: - TGetSubOrgIdsBody

public struct TGetSubOrgIdsBody: Codable, Sendable {
  public let organizationId: String?
  /// Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN', 'WALLET_ACCOUNT_ADDRESS' or 'PUBLIC_KEY'
  public let filterType: String?
  /// The value of the filter to apply for the specified type. For example, a specific email or name string.
  public let filterValue: String?
  /// Parameters used for cursor-based pagination.
  public let paginationOptions: v1Pagination?

  public init(
    organizationId: String? = nil,
    filterType: String? = nil,
    filterValue: String? = nil,
    paginationOptions: v1Pagination? = nil
  ) {
    self.organizationId = organizationId
    self.filterType = filterType
    self.filterValue = filterValue
    self.paginationOptions = paginationOptions
  }
}

// MARK: - TGetSubOrgIdsInput

public struct TGetSubOrgIdsInput: Codable, Sendable {
  public let body: TGetSubOrgIdsBody

  public init(
    body: TGetSubOrgIdsBody
  ) {
    self.body = body
  }
}

// MARK: - TListUserTagsResponse

public struct TListUserTagsResponse: Codable, Sendable {
  /// A list of user tags.
  public let userTags: [datav1Tag]
}

// MARK: - TListUserTagsBody

public struct TListUserTagsBody: Codable, Sendable {
  public let organizationId: String?

  public init(
    organizationId: String? = nil
  ) {
    self.organizationId = organizationId
  }
}

// MARK: - TListUserTagsInput

public struct TListUserTagsInput: Codable, Sendable {
  public let body: TListUserTagsBody

  public init(
    body: TListUserTagsBody
  ) {
    self.body = body
  }
}

// MARK: - TGetUsersResponse

public struct TGetUsersResponse: Codable, Sendable {
  /// A list of users.
  public let users: [v1User]
}

// MARK: - TGetUsersBody

public struct TGetUsersBody: Codable, Sendable {
  public let organizationId: String?

  public init(
    organizationId: String? = nil
  ) {
    self.organizationId = organizationId
  }
}

// MARK: - TGetUsersInput

public struct TGetUsersInput: Codable, Sendable {
  public let body: TGetUsersBody

  public init(
    body: TGetUsersBody
  ) {
    self.body = body
  }
}

// MARK: - TGetVerifiedSubOrgIdsResponse

public struct TGetVerifiedSubOrgIdsResponse: Codable, Sendable {
  /// List of unique identifiers for the matching sub-organizations.
  public let organizationIds: [String]
}

// MARK: - TGetVerifiedSubOrgIdsBody

public struct TGetVerifiedSubOrgIdsBody: Codable, Sendable {
  public let organizationId: String?
  /// Specifies the type of filter to apply, i.e 'EMAIL', 'PHONE_NUMBER'.
  public let filterType: String?
  /// The value of the filter to apply for the specified type. For example, a specific email or phone number string.
  public let filterValue: String?
  /// Parameters used for cursor-based pagination.
  public let paginationOptions: v1Pagination?

  public init(
    organizationId: String? = nil,
    filterType: String? = nil,
    filterValue: String? = nil,
    paginationOptions: v1Pagination? = nil
  ) {
    self.organizationId = organizationId
    self.filterType = filterType
    self.filterValue = filterValue
    self.paginationOptions = paginationOptions
  }
}

// MARK: - TGetVerifiedSubOrgIdsInput

public struct TGetVerifiedSubOrgIdsInput: Codable, Sendable {
  public let body: TGetVerifiedSubOrgIdsBody

  public init(
    body: TGetVerifiedSubOrgIdsBody
  ) {
    self.body = body
  }
}

// MARK: - TGetWalletAccountsResponse

public struct TGetWalletAccountsResponse: Codable, Sendable {
  /// A list of accounts generated from a wallet that share a common seed.
  public let accounts: [v1WalletAccount]
}

// MARK: - TGetWalletAccountsBody

public struct TGetWalletAccountsBody: Codable, Sendable {
  public let organizationId: String?
  /// Optional flag to specify if the wallet details should be included in the response. Default = false.
  public let includeWalletDetails: Bool?
  /// Parameters used for cursor-based pagination.
  public let paginationOptions: v1Pagination?
  /// Unique identifier for a given wallet. If not provided, all accounts for the organization will be returned.
  public let walletId: String?

  public init(
    organizationId: String? = nil,
    includeWalletDetails: Bool? = nil,
    paginationOptions: v1Pagination? = nil,
    walletId: String? = nil
  ) {
    self.organizationId = organizationId
    self.includeWalletDetails = includeWalletDetails
    self.paginationOptions = paginationOptions
    self.walletId = walletId
  }
}

// MARK: - TGetWalletAccountsInput

public struct TGetWalletAccountsInput: Codable, Sendable {
  public let body: TGetWalletAccountsBody

  public init(
    body: TGetWalletAccountsBody
  ) {
    self.body = body
  }
}

// MARK: - TGetWalletsResponse

public struct TGetWalletsResponse: Codable, Sendable {
  /// A list of wallets.
  public let wallets: [v1Wallet]
}

// MARK: - TGetWalletsBody

public struct TGetWalletsBody: Codable, Sendable {
  public let organizationId: String?

  public init(
    organizationId: String? = nil
  ) {
    self.organizationId = organizationId
  }
}

// MARK: - TGetWalletsInput

public struct TGetWalletsInput: Codable, Sendable {
  public let body: TGetWalletsBody

  public init(
    body: TGetWalletsBody
  ) {
    self.body = body
  }
}

// MARK: - TGetWhoamiResponse

public struct TGetWhoamiResponse: Codable, Sendable {
  /// Unique identifier for a given organization.
  public let organizationId: String
  /// Human-readable name for an organization.
  public let organizationName: String
  /// Unique identifier for a given user.
  public let userId: String
  /// Human-readable name for a user.
  public let username: String
}

// MARK: - TGetWhoamiBody

public struct TGetWhoamiBody: Codable, Sendable {
  public let organizationId: String?

  public init(
    organizationId: String? = nil
  ) {
    self.organizationId = organizationId
  }
}

// MARK: - TGetWhoamiInput

public struct TGetWhoamiInput: Codable, Sendable {
  public let body: TGetWhoamiBody

  public init(
    body: TGetWhoamiBody
  ) {
    self.body = body
  }
}

// MARK: - TApproveActivityResponse

public struct TApproveActivityResponse: Codable, Sendable {
  public let activity: v1Activity
}

// MARK: - TApproveActivityBody

public struct TApproveActivityBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// An artifact verifying a User's action.
  public let fingerprint: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    fingerprint: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.fingerprint = fingerprint
  }
}

// MARK: - TApproveActivityInput

public struct TApproveActivityInput: Codable, Sendable {
  public let body: TApproveActivityBody

  public init(
    body: TApproveActivityBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateApiKeysResponse

public struct TCreateApiKeysResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of API Key IDs.
  public let apiKeyIds: [String]
}

// MARK: - TCreateApiKeysBody

public struct TCreateApiKeysBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of API Keys.
  public let apiKeys: [v1ApiKeyParamsV2]
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    apiKeys: [v1ApiKeyParamsV2],
    userId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.apiKeys = apiKeys
    self.userId = userId
  }
}

// MARK: - TCreateApiKeysInput

public struct TCreateApiKeysInput: Codable, Sendable {
  public let body: TCreateApiKeysBody

  public init(
    body: TCreateApiKeysBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateApiOnlyUsersResponse

public struct TCreateApiOnlyUsersResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of API-only User IDs.
  public let userIds: [String]
}

// MARK: - TCreateApiOnlyUsersBody

public struct TCreateApiOnlyUsersBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of API-only Users to create.
  public let apiOnlyUsers: [v1ApiOnlyUserParams]

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    apiOnlyUsers: [v1ApiOnlyUserParams]
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.apiOnlyUsers = apiOnlyUsers
  }
}

// MARK: - TCreateApiOnlyUsersInput

public struct TCreateApiOnlyUsersInput: Codable, Sendable {
  public let body: TCreateApiOnlyUsersBody

  public init(
    body: TCreateApiOnlyUsersBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateAuthenticatorsResponse

public struct TCreateAuthenticatorsResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of Authenticator IDs.
  public let authenticatorIds: [String]
}

// MARK: - TCreateAuthenticatorsBody

public struct TCreateAuthenticatorsBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of Authenticators.
  public let authenticators: [v1AuthenticatorParamsV2]
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    authenticators: [v1AuthenticatorParamsV2],
    userId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.authenticators = authenticators
    self.userId = userId
  }
}

// MARK: - TCreateAuthenticatorsInput

public struct TCreateAuthenticatorsInput: Codable, Sendable {
  public let body: TCreateAuthenticatorsBody

  public init(
    body: TCreateAuthenticatorsBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateFiatOnRampCredentialResponse

public struct TCreateFiatOnRampCredentialResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier of the Fiat On-Ramp credential that was created
  public let fiatOnRampCredentialId: String
}

// MARK: - TCreateFiatOnRampCredentialBody

public struct TCreateFiatOnRampCredentialBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.
  public let encryptedPrivateApiKey: String?
  /// Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key
  public let encryptedSecretApiKey: String
  /// The fiat on-ramp provider
  public let onrampProvider: v1FiatOnRampProvider
  /// Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier
  public let projectId: String?
  /// Publishable API key for the on-ramp provider
  public let publishableApiKey: String
  /// If the on-ramp credential is a sandbox credential
  public let sandboxMode: Bool?

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    encryptedPrivateApiKey: String? = nil,
    encryptedSecretApiKey: String,
    onrampProvider: v1FiatOnRampProvider,
    projectId: String? = nil,
    publishableApiKey: String,
    sandboxMode: Bool? = nil
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.encryptedPrivateApiKey = encryptedPrivateApiKey
    self.encryptedSecretApiKey = encryptedSecretApiKey
    self.onrampProvider = onrampProvider
    self.projectId = projectId
    self.publishableApiKey = publishableApiKey
    self.sandboxMode = sandboxMode
  }
}

// MARK: - TCreateFiatOnRampCredentialInput

public struct TCreateFiatOnRampCredentialInput: Codable, Sendable {
  public let body: TCreateFiatOnRampCredentialBody

  public init(
    body: TCreateFiatOnRampCredentialBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateInvitationsResponse

public struct TCreateInvitationsResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of Invitation IDs
  public let invitationIds: [String]
}

// MARK: - TCreateInvitationsBody

public struct TCreateInvitationsBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of Invitations.
  public let invitations: [v1InvitationParams]

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    invitations: [v1InvitationParams]
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.invitations = invitations
  }
}

// MARK: - TCreateInvitationsInput

public struct TCreateInvitationsInput: Codable, Sendable {
  public let body: TCreateInvitationsBody

  public init(
    body: TCreateInvitationsBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateOauth2CredentialResponse

public struct TCreateOauth2CredentialResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier of the OAuth 2.0 credential that was created
  public let oauth2CredentialId: String
}

// MARK: - TCreateOauth2CredentialBody

public struct TCreateOauth2CredentialBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The Client ID issued by the OAuth 2.0 provider
  public let clientId: String
  /// The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key
  public let encryptedClientSecret: String
  /// The OAuth 2.0 provider
  public let provider: v1Oauth2Provider

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    clientId: String,
    encryptedClientSecret: String,
    provider: v1Oauth2Provider
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.clientId = clientId
    self.encryptedClientSecret = encryptedClientSecret
    self.provider = provider
  }
}

// MARK: - TCreateOauth2CredentialInput

public struct TCreateOauth2CredentialInput: Codable, Sendable {
  public let body: TCreateOauth2CredentialBody

  public init(
    body: TCreateOauth2CredentialBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateOauthProvidersResponse

public struct TCreateOauthProvidersResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of unique identifiers for Oauth Providers
  public let providerIds: [String]
}

// MARK: - TCreateOauthProvidersBody

public struct TCreateOauthProvidersBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of Oauth providers.
  public let oauthProviders: [v1OauthProviderParams]
  /// The ID of the User to add an Oauth provider to
  public let userId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    oauthProviders: [v1OauthProviderParams],
    userId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.oauthProviders = oauthProviders
    self.userId = userId
  }
}

// MARK: - TCreateOauthProvidersInput

public struct TCreateOauthProvidersInput: Codable, Sendable {
  public let body: TCreateOauthProvidersBody

  public init(
    body: TCreateOauthProvidersBody
  ) {
    self.body = body
  }
}

// MARK: - TCreatePoliciesResponse

public struct TCreatePoliciesResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of unique identifiers for the created policies.
  public let policyIds: [String]
}

// MARK: - TCreatePoliciesBody

public struct TCreatePoliciesBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// An array of policy intents to be created.
  public let policies: [v1CreatePolicyIntentV3]

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    policies: [v1CreatePolicyIntentV3]
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.policies = policies
  }
}

// MARK: - TCreatePoliciesInput

public struct TCreatePoliciesInput: Codable, Sendable {
  public let body: TCreatePoliciesBody

  public init(
    body: TCreatePoliciesBody
  ) {
    self.body = body
  }
}

// MARK: - TCreatePolicyResponse

public struct TCreatePolicyResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for a given Policy.
  public let policyId: String
}

// MARK: - TCreatePolicyBody

public struct TCreatePolicyBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The condition expression that triggers the Effect
  public let condition: String?
  /// The consensus expression that triggers the Effect
  public let consensus: String?
  /// The instruction to DENY or ALLOW an activity.
  public let effect: v1Effect
  public let notes: String?
  /// Human-readable name for a Policy.
  public let policyName: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    condition: String? = nil,
    consensus: String? = nil,
    effect: v1Effect,
    notes: String? = nil,
    policyName: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.condition = condition
    self.consensus = consensus
    self.effect = effect
    self.notes = notes
    self.policyName = policyName
  }
}

// MARK: - TCreatePolicyInput

public struct TCreatePolicyInput: Codable, Sendable {
  public let body: TCreatePolicyBody

  public init(
    body: TCreatePolicyBody
  ) {
    self.body = body
  }
}

// MARK: - TCreatePrivateKeyTagResponse

public struct TCreatePrivateKeyTagResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of Private Key IDs.
  public let privateKeyIds: [String]
  /// Unique identifier for a given Private Key Tag.
  public let privateKeyTagId: String
}

// MARK: - TCreatePrivateKeyTagBody

public struct TCreatePrivateKeyTagBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of Private Key IDs.
  public let privateKeyIds: [String]
  /// Human-readable name for a Private Key Tag.
  public let privateKeyTagName: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    privateKeyIds: [String],
    privateKeyTagName: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.privateKeyIds = privateKeyIds
    self.privateKeyTagName = privateKeyTagName
  }
}

// MARK: - TCreatePrivateKeyTagInput

public struct TCreatePrivateKeyTagInput: Codable, Sendable {
  public let body: TCreatePrivateKeyTagBody

  public init(
    body: TCreatePrivateKeyTagBody
  ) {
    self.body = body
  }
}

// MARK: - TCreatePrivateKeysResponse

public struct TCreatePrivateKeysResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of Private Key IDs and addresses.
  public let privateKeys: [v1PrivateKeyResult]
}

// MARK: - TCreatePrivateKeysBody

public struct TCreatePrivateKeysBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of Private Keys.
  public let privateKeys: [v1PrivateKeyParams]

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    privateKeys: [v1PrivateKeyParams]
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.privateKeys = privateKeys
  }
}

// MARK: - TCreatePrivateKeysInput

public struct TCreatePrivateKeysInput: Codable, Sendable {
  public let body: TCreatePrivateKeysBody

  public init(
    body: TCreatePrivateKeysBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateReadOnlySessionResponse

public struct TCreateReadOnlySessionResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons.
  public let organizationId: String
  /// Human-readable name for an Organization.
  public let organizationName: String
  /// String representing a read only session
  public let session: String
  /// UTC timestamp in seconds representing the expiry time for the read only session.
  public let sessionExpiry: String
  /// Unique identifier for a given User.
  public let userId: String
  /// Human-readable name for a User.
  public let username: String
}

// MARK: - TCreateReadOnlySessionBody

public struct TCreateReadOnlySessionBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
  }
}

// MARK: - TCreateReadOnlySessionInput

public struct TCreateReadOnlySessionInput: Codable, Sendable {
  public let body: TCreateReadOnlySessionBody

  public init(
    body: TCreateReadOnlySessionBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateReadWriteSessionResponse

public struct TCreateReadWriteSessionResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for the created API key.
  public let apiKeyId: String
  /// HPKE encrypted credential bundle
  public let credentialBundle: String
  /// Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons.
  public let organizationId: String
  /// Human-readable name for an Organization.
  public let organizationName: String
  /// Unique identifier for a given User.
  public let userId: String
  /// Human-readable name for a User.
  public let username: String
}

// MARK: - TCreateReadWriteSessionBody

public struct TCreateReadWriteSessionBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp>
  public let apiKeyName: String?
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated ReadWriteSession API keys
  public let invalidateExisting: Bool?
  /// Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted.
  public let targetPublicKey: String
  /// Unique identifier for a given User.
  public let userId: String?

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    apiKeyName: String? = nil,
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    targetPublicKey: String,
    userId: String? = nil
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.apiKeyName = apiKeyName
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.targetPublicKey = targetPublicKey
    self.userId = userId
  }
}

// MARK: - TCreateReadWriteSessionInput

public struct TCreateReadWriteSessionInput: Codable, Sendable {
  public let body: TCreateReadWriteSessionBody

  public init(
    body: TCreateReadWriteSessionBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateSmartContractInterfaceResponse

public struct TCreateSmartContractInterfaceResponse: Codable, Sendable {
  public let activity: v1Activity
  /// The ID of the created Smart Contract Interface.
  public let smartContractInterfaceId: String
}

// MARK: - TCreateSmartContractInterfaceBody

public struct TCreateSmartContractInterfaceBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Human-readable name for a Smart Contract Interface.
  public let label: String
  /// Notes for a Smart Contract Interface.
  public let notes: String?
  /// Corresponding contract address or program ID
  public let smartContractAddress: String
  /// ABI/IDL as a JSON string
  public let smartContractInterface: String
  public let type: v1SmartContractInterfaceType

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    label: String,
    notes: String? = nil,
    smartContractAddress: String,
    smartContractInterface: String,
    type: v1SmartContractInterfaceType
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.label = label
    self.notes = notes
    self.smartContractAddress = smartContractAddress
    self.smartContractInterface = smartContractInterface
    self.type = type
  }
}

// MARK: - TCreateSmartContractInterfaceInput

public struct TCreateSmartContractInterfaceInput: Codable, Sendable {
  public let body: TCreateSmartContractInterfaceBody

  public init(
    body: TCreateSmartContractInterfaceBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateSubOrganizationResponse

public struct TCreateSubOrganizationResponse: Codable, Sendable {
  public let activity: v1Activity
  public let rootUserIds: [String]?
  public let subOrganizationId: String
  public let wallet: v1WalletResult?
}

// MARK: - TCreateSubOrganizationBody

public struct TCreateSubOrganizationBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Optional signature proving authorization for this sub-organization creation. The signature is over the verification token ID and the root user parameters for the root user associated with the verification token. Only required if a public key was provided during the verification step.
  public let clientSignature: v1ClientSignature?
  /// Disable email auth for the sub-organization
  public let disableEmailAuth: Bool?
  /// Disable email recovery for the sub-organization
  public let disableEmailRecovery: Bool?
  /// Disable OTP email auth for the sub-organization
  public let disableOtpEmailAuth: Bool?
  /// Disable OTP SMS auth for the sub-organization
  public let disableSmsAuth: Bool?
  /// The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
  public let rootQuorumThreshold: Int
  /// Root users to create within this sub-organization
  public let rootUsers: [v1RootUserParamsV4]
  /// Name for this sub-organization
  public let subOrganizationName: String
  /// Signed JWT containing a unique id, expiry, verification type, contact
  public let verificationToken: String?
  /// The wallet to create for the sub-organization
  public let wallet: v1WalletParams?

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    clientSignature: v1ClientSignature? = nil,
    disableEmailAuth: Bool? = nil,
    disableEmailRecovery: Bool? = nil,
    disableOtpEmailAuth: Bool? = nil,
    disableSmsAuth: Bool? = nil,
    rootQuorumThreshold: Int,
    rootUsers: [v1RootUserParamsV4],
    subOrganizationName: String,
    verificationToken: String? = nil,
    wallet: v1WalletParams? = nil
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.clientSignature = clientSignature
    self.disableEmailAuth = disableEmailAuth
    self.disableEmailRecovery = disableEmailRecovery
    self.disableOtpEmailAuth = disableOtpEmailAuth
    self.disableSmsAuth = disableSmsAuth
    self.rootQuorumThreshold = rootQuorumThreshold
    self.rootUsers = rootUsers
    self.subOrganizationName = subOrganizationName
    self.verificationToken = verificationToken
    self.wallet = wallet
  }
}

// MARK: - TCreateSubOrganizationInput

public struct TCreateSubOrganizationInput: Codable, Sendable {
  public let body: TCreateSubOrganizationBody

  public init(
    body: TCreateSubOrganizationBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateUserTagResponse

public struct TCreateUserTagResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of User IDs.
  public let userIds: [String]
  /// Unique identifier for a given User Tag.
  public let userTagId: String
}

// MARK: - TCreateUserTagBody

public struct TCreateUserTagBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of User IDs.
  public let userIds: [String]
  /// Human-readable name for a User Tag.
  public let userTagName: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    userIds: [String],
    userTagName: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.userIds = userIds
    self.userTagName = userTagName
  }
}

// MARK: - TCreateUserTagInput

public struct TCreateUserTagInput: Codable, Sendable {
  public let body: TCreateUserTagBody

  public init(
    body: TCreateUserTagBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateUsersResponse

public struct TCreateUsersResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of User IDs.
  public let userIds: [String]
}

// MARK: - TCreateUsersBody

public struct TCreateUsersBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of Users.
  public let users: [v1UserParamsV3]

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    users: [v1UserParamsV3]
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.users = users
  }
}

// MARK: - TCreateUsersInput

public struct TCreateUsersInput: Codable, Sendable {
  public let body: TCreateUsersBody

  public init(
    body: TCreateUsersBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateWalletResponse

public struct TCreateWalletResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of account addresses.
  public let addresses: [String]
  /// Unique identifier for a Wallet.
  public let walletId: String
}

// MARK: - TCreateWalletBody

public struct TCreateWalletBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of wallet Accounts. This field, if not needed, should be an empty array in your request body.
  public let accounts: [v1WalletAccountParams]
  /// Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24.
  public let mnemonicLength: Int?
  /// Human-readable name for a Wallet.
  public let walletName: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    accounts: [v1WalletAccountParams],
    mnemonicLength: Int? = nil,
    walletName: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.accounts = accounts
    self.mnemonicLength = mnemonicLength
    self.walletName = walletName
  }
}

// MARK: - TCreateWalletInput

public struct TCreateWalletInput: Codable, Sendable {
  public let body: TCreateWalletBody

  public init(
    body: TCreateWalletBody
  ) {
    self.body = body
  }
}

// MARK: - TCreateWalletAccountsResponse

public struct TCreateWalletAccountsResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of derived addresses.
  public let addresses: [String]
}

// MARK: - TCreateWalletAccountsBody

public struct TCreateWalletAccountsBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of wallet Accounts.
  public let accounts: [v1WalletAccountParams]
  /// Indicates if the wallet accounts should be persisted. This is helpful if you'd like to see the addresses of different derivation paths without actually creating the accounts. Defaults to true.
  public let persist: Bool?
  /// Unique identifier for a given Wallet.
  public let walletId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    accounts: [v1WalletAccountParams],
    persist: Bool? = nil,
    walletId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.accounts = accounts
    self.persist = persist
    self.walletId = walletId
  }
}

// MARK: - TCreateWalletAccountsInput

public struct TCreateWalletAccountsInput: Codable, Sendable {
  public let body: TCreateWalletAccountsBody

  public init(
    body: TCreateWalletAccountsBody
  ) {
    self.body = body
  }
}

// MARK: - TDeleteApiKeysResponse

public struct TDeleteApiKeysResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of API Key IDs.
  public let apiKeyIds: [String]
}

// MARK: - TDeleteApiKeysBody

public struct TDeleteApiKeysBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of API Key IDs.
  public let apiKeyIds: [String]
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    apiKeyIds: [String],
    userId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.apiKeyIds = apiKeyIds
    self.userId = userId
  }
}

// MARK: - TDeleteApiKeysInput

public struct TDeleteApiKeysInput: Codable, Sendable {
  public let body: TDeleteApiKeysBody

  public init(
    body: TDeleteApiKeysBody
  ) {
    self.body = body
  }
}

// MARK: - TDeleteAuthenticatorsResponse

public struct TDeleteAuthenticatorsResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for a given Authenticator.
  public let authenticatorIds: [String]
}

// MARK: - TDeleteAuthenticatorsBody

public struct TDeleteAuthenticatorsBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of Authenticator IDs.
  public let authenticatorIds: [String]
  /// Unique identifier for a given User.
  public let userId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    authenticatorIds: [String],
    userId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.authenticatorIds = authenticatorIds
    self.userId = userId
  }
}

// MARK: - TDeleteAuthenticatorsInput

public struct TDeleteAuthenticatorsInput: Codable, Sendable {
  public let body: TDeleteAuthenticatorsBody

  public init(
    body: TDeleteAuthenticatorsBody
  ) {
    self.body = body
  }
}

// MARK: - TDeleteFiatOnRampCredentialResponse

public struct TDeleteFiatOnRampCredentialResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier of the Fiat On-Ramp credential that was deleted
  public let fiatOnRampCredentialId: String
}

// MARK: - TDeleteFiatOnRampCredentialBody

public struct TDeleteFiatOnRampCredentialBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The ID of the fiat on-ramp credential to delete
  public let fiatOnrampCredentialId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    fiatOnrampCredentialId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.fiatOnrampCredentialId = fiatOnrampCredentialId
  }
}

// MARK: - TDeleteFiatOnRampCredentialInput

public struct TDeleteFiatOnRampCredentialInput: Codable, Sendable {
  public let body: TDeleteFiatOnRampCredentialBody

  public init(
    body: TDeleteFiatOnRampCredentialBody
  ) {
    self.body = body
  }
}

// MARK: - TDeleteInvitationResponse

public struct TDeleteInvitationResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for a given Invitation.
  public let invitationId: String
}

// MARK: - TDeleteInvitationBody

public struct TDeleteInvitationBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Unique identifier for a given Invitation object.
  public let invitationId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    invitationId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.invitationId = invitationId
  }
}

// MARK: - TDeleteInvitationInput

public struct TDeleteInvitationInput: Codable, Sendable {
  public let body: TDeleteInvitationBody

  public init(
    body: TDeleteInvitationBody
  ) {
    self.body = body
  }
}

// MARK: - TDeleteOauth2CredentialResponse

public struct TDeleteOauth2CredentialResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier of the OAuth 2.0 credential that was deleted
  public let oauth2CredentialId: String
}

// MARK: - TDeleteOauth2CredentialBody

public struct TDeleteOauth2CredentialBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The ID of the OAuth 2.0 credential to delete
  public let oauth2CredentialId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    oauth2CredentialId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.oauth2CredentialId = oauth2CredentialId
  }
}

// MARK: - TDeleteOauth2CredentialInput

public struct TDeleteOauth2CredentialInput: Codable, Sendable {
  public let body: TDeleteOauth2CredentialBody

  public init(
    body: TDeleteOauth2CredentialBody
  ) {
    self.body = body
  }
}

// MARK: - TDeleteOauthProvidersResponse

public struct TDeleteOauthProvidersResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of unique identifiers for Oauth Providers
  public let providerIds: [String]
}

// MARK: - TDeleteOauthProvidersBody

public struct TDeleteOauthProvidersBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Unique identifier for a given Provider.
  public let providerIds: [String]
  /// The ID of the User to remove an Oauth provider from
  public let userId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    providerIds: [String],
    userId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.providerIds = providerIds
    self.userId = userId
  }
}

// MARK: - TDeleteOauthProvidersInput

public struct TDeleteOauthProvidersInput: Codable, Sendable {
  public let body: TDeleteOauthProvidersBody

  public init(
    body: TDeleteOauthProvidersBody
  ) {
    self.body = body
  }
}

// MARK: - TDeletePoliciesResponse

public struct TDeletePoliciesResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of unique identifiers for the deleted policies.
  public let policyIds: [String]
}

// MARK: - TDeletePoliciesBody

public struct TDeletePoliciesBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// List of unique identifiers for policies within an organization
  public let policyIds: [String]

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    policyIds: [String]
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.policyIds = policyIds
  }
}

// MARK: - TDeletePoliciesInput

public struct TDeletePoliciesInput: Codable, Sendable {
  public let body: TDeletePoliciesBody

  public init(
    body: TDeletePoliciesBody
  ) {
    self.body = body
  }
}

// MARK: - TDeletePolicyResponse

public struct TDeletePolicyResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for a given Policy.
  public let policyId: String
}

// MARK: - TDeletePolicyBody

public struct TDeletePolicyBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Unique identifier for a given Policy.
  public let policyId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    policyId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.policyId = policyId
  }
}

// MARK: - TDeletePolicyInput

public struct TDeletePolicyInput: Codable, Sendable {
  public let body: TDeletePolicyBody

  public init(
    body: TDeletePolicyBody
  ) {
    self.body = body
  }
}

// MARK: - TDeletePrivateKeyTagsResponse

public struct TDeletePrivateKeyTagsResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of Private Key IDs.
  public let privateKeyIds: [String]
  /// A list of Private Key Tag IDs.
  public let privateKeyTagIds: [String]
}

// MARK: - TDeletePrivateKeyTagsBody

public struct TDeletePrivateKeyTagsBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of Private Key Tag IDs.
  public let privateKeyTagIds: [String]

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    privateKeyTagIds: [String]
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.privateKeyTagIds = privateKeyTagIds
  }
}

// MARK: - TDeletePrivateKeyTagsInput

public struct TDeletePrivateKeyTagsInput: Codable, Sendable {
  public let body: TDeletePrivateKeyTagsBody

  public init(
    body: TDeletePrivateKeyTagsBody
  ) {
    self.body = body
  }
}

// MARK: - TDeletePrivateKeysResponse

public struct TDeletePrivateKeysResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of private key unique identifiers that were removed
  public let privateKeyIds: [String]
}

// MARK: - TDeletePrivateKeysBody

public struct TDeletePrivateKeysBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored.
  public let deleteWithoutExport: Bool?
  /// List of unique identifiers for private keys within an organization
  public let privateKeyIds: [String]

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    deleteWithoutExport: Bool? = nil,
    privateKeyIds: [String]
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.deleteWithoutExport = deleteWithoutExport
    self.privateKeyIds = privateKeyIds
  }
}

// MARK: - TDeletePrivateKeysInput

public struct TDeletePrivateKeysInput: Codable, Sendable {
  public let body: TDeletePrivateKeysBody

  public init(
    body: TDeletePrivateKeysBody
  ) {
    self.body = body
  }
}

// MARK: - TDeleteSmartContractInterfaceResponse

public struct TDeleteSmartContractInterfaceResponse: Codable, Sendable {
  public let activity: v1Activity
  /// The ID of the deleted Smart Contract Interface.
  public let smartContractInterfaceId: String
}

// MARK: - TDeleteSmartContractInterfaceBody

public struct TDeleteSmartContractInterfaceBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The ID of a Smart Contract Interface intended for deletion.
  public let smartContractInterfaceId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    smartContractInterfaceId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.smartContractInterfaceId = smartContractInterfaceId
  }
}

// MARK: - TDeleteSmartContractInterfaceInput

public struct TDeleteSmartContractInterfaceInput: Codable, Sendable {
  public let body: TDeleteSmartContractInterfaceBody

  public init(
    body: TDeleteSmartContractInterfaceBody
  ) {
    self.body = body
  }
}

// MARK: - TDeleteSubOrganizationResponse

public struct TDeleteSubOrganizationResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier of the sub organization that was removed
  public let subOrganizationUuid: String
}

// MARK: - TDeleteSubOrganizationBody

public struct TDeleteSubOrganizationBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false.
  public let deleteWithoutExport: Bool?

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    deleteWithoutExport: Bool? = nil
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.deleteWithoutExport = deleteWithoutExport
  }
}

// MARK: - TDeleteSubOrganizationInput

public struct TDeleteSubOrganizationInput: Codable, Sendable {
  public let body: TDeleteSubOrganizationBody

  public init(
    body: TDeleteSubOrganizationBody
  ) {
    self.body = body
  }
}

// MARK: - TDeleteUserTagsResponse

public struct TDeleteUserTagsResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of User IDs.
  public let userIds: [String]
  /// A list of User Tag IDs.
  public let userTagIds: [String]
}

// MARK: - TDeleteUserTagsBody

public struct TDeleteUserTagsBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of User Tag IDs.
  public let userTagIds: [String]

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    userTagIds: [String]
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.userTagIds = userTagIds
  }
}

// MARK: - TDeleteUserTagsInput

public struct TDeleteUserTagsInput: Codable, Sendable {
  public let body: TDeleteUserTagsBody

  public init(
    body: TDeleteUserTagsBody
  ) {
    self.body = body
  }
}

// MARK: - TDeleteUsersResponse

public struct TDeleteUsersResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of User IDs.
  public let userIds: [String]
}

// MARK: - TDeleteUsersBody

public struct TDeleteUsersBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of User IDs.
  public let userIds: [String]

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    userIds: [String]
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.userIds = userIds
  }
}

// MARK: - TDeleteUsersInput

public struct TDeleteUsersInput: Codable, Sendable {
  public let body: TDeleteUsersBody

  public init(
    body: TDeleteUsersBody
  ) {
    self.body = body
  }
}

// MARK: - TDeleteWalletAccountsResponse

public struct TDeleteWalletAccountsResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of wallet account unique identifiers that were removed
  public let walletAccountIds: [String]
}

// MARK: - TDeleteWalletAccountsBody

public struct TDeleteWalletAccountsBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Optional parameter for deleting the wallet accounts, even if any have not been previously exported. If they have been exported, this field is ignored.
  public let deleteWithoutExport: Bool?
  /// List of unique identifiers for wallet accounts within an organization
  public let walletAccountIds: [String]

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    deleteWithoutExport: Bool? = nil,
    walletAccountIds: [String]
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.deleteWithoutExport = deleteWithoutExport
    self.walletAccountIds = walletAccountIds
  }
}

// MARK: - TDeleteWalletAccountsInput

public struct TDeleteWalletAccountsInput: Codable, Sendable {
  public let body: TDeleteWalletAccountsBody

  public init(
    body: TDeleteWalletAccountsBody
  ) {
    self.body = body
  }
}

// MARK: - TDeleteWalletsResponse

public struct TDeleteWalletsResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of wallet unique identifiers that were removed
  public let walletIds: [String]
}

// MARK: - TDeleteWalletsBody

public struct TDeleteWalletsBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored.
  public let deleteWithoutExport: Bool?
  /// List of unique identifiers for wallets within an organization
  public let walletIds: [String]

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    deleteWithoutExport: Bool? = nil,
    walletIds: [String]
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.deleteWithoutExport = deleteWithoutExport
    self.walletIds = walletIds
  }
}

// MARK: - TDeleteWalletsInput

public struct TDeleteWalletsInput: Codable, Sendable {
  public let body: TDeleteWalletsBody

  public init(
    body: TDeleteWalletsBody
  ) {
    self.body = body
  }
}

// MARK: - TEmailAuthResponse

public struct TEmailAuthResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for the created API key.
  public let apiKeyId: String
  /// Unique identifier for the authenticating User.
  public let userId: String
}

// MARK: - TEmailAuthBody

public struct TEmailAuthBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp>
  public let apiKeyName: String?
  /// The name of the application.
  public let appName: String
  /// Email of the authenticating user.
  public let email: String
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomization: v1EmailCustomizationParams?
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated Email Auth API keys
  public let invalidateExisting: Bool?
  /// Optional custom email address to use as reply-to
  public let replyToEmailAddress: String?
  /// Optional custom email address from which to send the email
  public let sendFromEmailAddress: String?
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  public let sendFromEmailSenderName: String?
  /// Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted.
  public let targetPublicKey: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    apiKeyName: String? = nil,
    appName: String,
    email: String,
    emailCustomization: v1EmailCustomizationParams? = nil,
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    targetPublicKey: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.apiKeyName = apiKeyName
    self.appName = appName
    self.email = email
    self.emailCustomization = emailCustomization
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.targetPublicKey = targetPublicKey
  }
}

// MARK: - TEmailAuthInput

public struct TEmailAuthInput: Codable, Sendable {
  public let body: TEmailAuthBody

  public init(
    body: TEmailAuthBody
  ) {
    self.body = body
  }
}

// MARK: - TEthSendRawTransactionResponse

public struct TEthSendRawTransactionResponse: Codable, Sendable {
  public let activity: v1Activity
  /// The transaction hash of the sent transaction
  public let transactionHash: String
}

// MARK: - TEthSendRawTransactionBody

public struct TEthSendRawTransactionBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet).
  public let caip2: String
  /// The raw, signed transaction to be sent.
  public let signedTransaction: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    caip2: String,
    signedTransaction: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.caip2 = caip2
    self.signedTransaction = signedTransaction
  }
}

// MARK: - TEthSendRawTransactionInput

public struct TEthSendRawTransactionInput: Codable, Sendable {
  public let body: TEthSendRawTransactionBody

  public init(
    body: TEthSendRawTransactionBody
  ) {
    self.body = body
  }
}

// MARK: - TEthSendTransactionResponse

public struct TEthSendTransactionResponse: Codable, Sendable {
  public let activity: v1Activity
  /// The send_transaction_status ID associated with the transaction submission for sponsored transactions
  public let sendTransactionStatusId: String
}

// MARK: - TEthSendTransactionBody

public struct TEthSendTransactionBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet).
  public let caip2: String
  /// Hex-encoded call data for contract interactions.
  public let data: String?
  /// A wallet or private key address to sign with. This does not support private key IDs.
  public let from: String
  /// Maximum amount of gas to use for this transaction, for EIP-1559 transactions.
  public let gasLimit: String?
  /// Maximum total fee per gas unit (base fee + priority fee) in wei. Required for non-sponsored (EIP-1559) transactions. Not used for sponsored transactions.
  public let maxFeePerGas: String?
  /// Maximum priority fee (tip) per gas unit in wei. Required for non-sponsored (EIP-1559) transactions. Not used for sponsored transactions.
  public let maxPriorityFeePerGas: String?
  /// Transaction nonce, for EIP-1559 and Turnkey Gas Station authorizations.
  public let nonce: String?
  /// Whether to sponsor this transaction via Gas Station.
  public let sponsor: Bool?
  /// Recipient address as a hex string with 0x prefix.
  public let to: String
  /// Amount of native asset to send in wei.
  public let value: String?

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    caip2: String,
    data: String? = nil,
    from: String,
    gasLimit: String? = nil,
    maxFeePerGas: String? = nil,
    maxPriorityFeePerGas: String? = nil,
    nonce: String? = nil,
    sponsor: Bool? = nil,
    to: String,
    value: String? = nil
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.caip2 = caip2
    self.data = data
    self.from = from
    self.gasLimit = gasLimit
    self.maxFeePerGas = maxFeePerGas
    self.maxPriorityFeePerGas = maxPriorityFeePerGas
    self.nonce = nonce
    self.sponsor = sponsor
    self.to = to
    self.value = value
  }
}

// MARK: - TEthSendTransactionInput

public struct TEthSendTransactionInput: Codable, Sendable {
  public let body: TEthSendTransactionBody

  public init(
    body: TEthSendTransactionBody
  ) {
    self.body = body
  }
}

// MARK: - TExportPrivateKeyResponse

public struct TExportPrivateKeyResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Export bundle containing a private key encrypted to the client's target public key.
  public let exportBundle: String
  /// Unique identifier for a given Private Key.
  public let privateKeyId: String
}

// MARK: - TExportPrivateKeyBody

public struct TExportPrivateKeyBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Unique identifier for a given Private Key.
  public let privateKeyId: String
  /// Client-side public key generated by the user, to which the export bundle will be encrypted.
  public let targetPublicKey: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    privateKeyId: String,
    targetPublicKey: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.privateKeyId = privateKeyId
    self.targetPublicKey = targetPublicKey
  }
}

// MARK: - TExportPrivateKeyInput

public struct TExportPrivateKeyInput: Codable, Sendable {
  public let body: TExportPrivateKeyBody

  public init(
    body: TExportPrivateKeyBody
  ) {
    self.body = body
  }
}

// MARK: - TExportWalletResponse

public struct TExportWalletResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Export bundle containing a wallet mnemonic + optional newline passphrase encrypted by the client's target public key.
  public let exportBundle: String
  /// Unique identifier for a given Wallet.
  public let walletId: String
}

// MARK: - TExportWalletBody

public struct TExportWalletBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The language of the mnemonic to export. Defaults to English.
  public let language: v1MnemonicLanguage?
  /// Client-side public key generated by the user, to which the export bundle will be encrypted.
  public let targetPublicKey: String
  /// Unique identifier for a given Wallet.
  public let walletId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    language: v1MnemonicLanguage? = nil,
    targetPublicKey: String,
    walletId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.language = language
    self.targetPublicKey = targetPublicKey
    self.walletId = walletId
  }
}

// MARK: - TExportWalletInput

public struct TExportWalletInput: Codable, Sendable {
  public let body: TExportWalletBody

  public init(
    body: TExportWalletBody
  ) {
    self.body = body
  }
}

// MARK: - TExportWalletAccountResponse

public struct TExportWalletAccountResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Address to identify Wallet Account.
  public let address: String
  /// Export bundle containing a private key encrypted by the client's target public key.
  public let exportBundle: String
}

// MARK: - TExportWalletAccountBody

public struct TExportWalletAccountBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Address to identify Wallet Account.
  public let address: String
  /// Client-side public key generated by the user, to which the export bundle will be encrypted.
  public let targetPublicKey: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    address: String,
    targetPublicKey: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.address = address
    self.targetPublicKey = targetPublicKey
  }
}

// MARK: - TExportWalletAccountInput

public struct TExportWalletAccountInput: Codable, Sendable {
  public let body: TExportWalletAccountBody

  public init(
    body: TExportWalletAccountBody
  ) {
    self.body = body
  }
}

// MARK: - TImportPrivateKeyResponse

public struct TImportPrivateKeyResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of addresses.
  public let addresses: [immutableactivityv1Address]
  /// Unique identifier for a Private Key.
  public let privateKeyId: String
}

// MARK: - TImportPrivateKeyBody

public struct TImportPrivateKeyBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Cryptocurrency-specific formats for a derived address (e.g., Ethereum).
  public let addressFormats: [v1AddressFormat]
  /// Cryptographic Curve used to generate a given Private Key.
  public let curve: v1Curve
  /// Bundle containing a raw private key encrypted to the enclave's target public key.
  public let encryptedBundle: String
  /// Human-readable name for a Private Key.
  public let privateKeyName: String
  /// The ID of the User importing a Private Key.
  public let userId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    addressFormats: [v1AddressFormat],
    curve: v1Curve,
    encryptedBundle: String,
    privateKeyName: String,
    userId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.addressFormats = addressFormats
    self.curve = curve
    self.encryptedBundle = encryptedBundle
    self.privateKeyName = privateKeyName
    self.userId = userId
  }
}

// MARK: - TImportPrivateKeyInput

public struct TImportPrivateKeyInput: Codable, Sendable {
  public let body: TImportPrivateKeyBody

  public init(
    body: TImportPrivateKeyBody
  ) {
    self.body = body
  }
}

// MARK: - TImportWalletResponse

public struct TImportWalletResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A list of account addresses.
  public let addresses: [String]
  /// Unique identifier for a Wallet.
  public let walletId: String
}

// MARK: - TImportWalletBody

public struct TImportWalletBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of wallet Accounts.
  public let accounts: [v1WalletAccountParams]
  /// Bundle containing a wallet mnemonic encrypted to the enclave's target public key.
  public let encryptedBundle: String
  /// The ID of the User importing a Wallet.
  public let userId: String
  /// Human-readable name for a Wallet.
  public let walletName: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    accounts: [v1WalletAccountParams],
    encryptedBundle: String,
    userId: String,
    walletName: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.accounts = accounts
    self.encryptedBundle = encryptedBundle
    self.userId = userId
    self.walletName = walletName
  }
}

// MARK: - TImportWalletInput

public struct TImportWalletInput: Codable, Sendable {
  public let body: TImportWalletBody

  public init(
    body: TImportWalletBody
  ) {
    self.body = body
  }
}

// MARK: - TInitFiatOnRampResponse

public struct TInitFiatOnRampResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier used to retrieve transaction statuses for a given fiat on-ramp flow.
  public let onRampTransactionId: String
  /// Unique URL for a given fiat on-ramp flow.
  public let onRampUrl: String
  /// Optional signature of the MoonPay Widget URL. The signature is generated if the Init Fiat On Ramp intent includes the urlForSignature field. The signature can be used to initialize the MoonPay SDKs when URL signing is enabled for your project.
  public let onRampUrlSignature: String?
}

// MARK: - TInitFiatOnRampBody

public struct TInitFiatOnRampBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// ISO 3166-1 two-digit country code for Coinbase representing the purchasing users country of residence, e.g., US, GB.
  public let countryCode: String?
  /// ISO 3166-2 two-digit country subdivision code for Coinbase representing the purchasing users subdivision of residence within their country, e.g. NY. Required if country_code=US.
  public let countrySubdivisionCode: String?
  /// Code for the cryptocurrency to be purchased, e.g., btc, eth. Maps to MoonPay's currencyCode or Coinbase's defaultAsset.
  public let cryptoCurrencyCode: v1FiatOnRampCryptoCurrency
  /// Specifies a preset fiat amount for the transaction, e.g., '100'. Must be greater than '20'. If not provided, the user will be prompted to enter an amount.
  public let fiatCurrencyAmount: String?
  /// Code for the fiat currency to be used in the transaction, e.g., USD, EUR.
  public let fiatCurrencyCode: v1FiatOnRampCurrency?
  /// Blockchain network to be used for the transaction, e.g., bitcoin, ethereum. Maps to MoonPay's network or Coinbase's defaultNetwork.
  public let network: v1FiatOnRampBlockchainNetwork
  /// Enum to specifiy which on-ramp provider to use
  public let onrampProvider: v1FiatOnRampProvider
  /// Pre-selected payment method, e.g., CREDIT_DEBIT_CARD, APPLE_PAY. Validated against the chosen provider.
  public let paymentMethod: v1FiatOnRampPaymentMethod?
  /// Optional flag to indicate whether to use the sandbox mode to simulate transactions for the on-ramp provider. Default is false.
  public let sandboxMode: Bool?
  /// Optional MoonPay Widget URL to sign when using MoonPay client SDKs with URL Signing enabled.
  public let urlForSignature: String?
  /// Destination wallet address for the buy transaction.
  public let walletAddress: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    countryCode: String? = nil,
    countrySubdivisionCode: String? = nil,
    cryptoCurrencyCode: v1FiatOnRampCryptoCurrency,
    fiatCurrencyAmount: String? = nil,
    fiatCurrencyCode: v1FiatOnRampCurrency? = nil,
    network: v1FiatOnRampBlockchainNetwork,
    onrampProvider: v1FiatOnRampProvider,
    paymentMethod: v1FiatOnRampPaymentMethod? = nil,
    sandboxMode: Bool? = nil,
    urlForSignature: String? = nil,
    walletAddress: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.countryCode = countryCode
    self.countrySubdivisionCode = countrySubdivisionCode
    self.cryptoCurrencyCode = cryptoCurrencyCode
    self.fiatCurrencyAmount = fiatCurrencyAmount
    self.fiatCurrencyCode = fiatCurrencyCode
    self.network = network
    self.onrampProvider = onrampProvider
    self.paymentMethod = paymentMethod
    self.sandboxMode = sandboxMode
    self.urlForSignature = urlForSignature
    self.walletAddress = walletAddress
  }
}

// MARK: - TInitFiatOnRampInput

public struct TInitFiatOnRampInput: Codable, Sendable {
  public let body: TInitFiatOnRampBody

  public init(
    body: TInitFiatOnRampBody
  ) {
    self.body = body
  }
}

// MARK: - TInitImportPrivateKeyResponse

public struct TInitImportPrivateKeyResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Import bundle containing a public key and signature to use for importing client data.
  public let importBundle: String
}

// MARK: - TInitImportPrivateKeyBody

public struct TInitImportPrivateKeyBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The ID of the User importing a Private Key.
  public let userId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    userId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.userId = userId
  }
}

// MARK: - TInitImportPrivateKeyInput

public struct TInitImportPrivateKeyInput: Codable, Sendable {
  public let body: TInitImportPrivateKeyBody

  public init(
    body: TInitImportPrivateKeyBody
  ) {
    self.body = body
  }
}

// MARK: - TInitImportWalletResponse

public struct TInitImportWalletResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Import bundle containing a public key and signature to use for importing client data.
  public let importBundle: String
}

// MARK: - TInitImportWalletBody

public struct TInitImportWalletBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The ID of the User importing a Wallet.
  public let userId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    userId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.userId = userId
  }
}

// MARK: - TInitImportWalletInput

public struct TInitImportWalletInput: Codable, Sendable {
  public let body: TInitImportWalletBody

  public init(
    body: TInitImportWalletBody
  ) {
    self.body = body
  }
}

// MARK: - TInitOtpResponse

public struct TInitOtpResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for an OTP authentication
  public let otpId: String
}

// MARK: - TInitOtpBody

public struct TInitOtpBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true
  public let alphanumeric: Bool?
  /// The name of the application.
  public let appName: String
  /// Email or phone number to send the OTP code to
  public let contact: String
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomization: v1EmailCustomizationParams?
  /// Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes)
  public let expirationSeconds: String?
  /// Optional length of the OTP code. Default = 9
  public let otpLength: Int?
  /// Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL
  public let otpType: String
  /// Optional custom email address to use as reply-to
  public let replyToEmailAddress: String?
  /// Optional custom email address from which to send the OTP email
  public let sendFromEmailAddress: String?
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  public let sendFromEmailSenderName: String?
  /// Optional parameters for customizing SMS message. If not provided, the default sms message will be used.
  public let smsCustomization: v1SmsCustomizationParams?
  /// Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.
  public let userIdentifier: String?

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    alphanumeric: Bool? = nil,
    appName: String,
    contact: String,
    emailCustomization: v1EmailCustomizationParams? = nil,
    expirationSeconds: String? = nil,
    otpLength: Int? = nil,
    otpType: String,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    smsCustomization: v1SmsCustomizationParams? = nil,
    userIdentifier: String? = nil
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.alphanumeric = alphanumeric
    self.appName = appName
    self.contact = contact
    self.emailCustomization = emailCustomization
    self.expirationSeconds = expirationSeconds
    self.otpLength = otpLength
    self.otpType = otpType
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.smsCustomization = smsCustomization
    self.userIdentifier = userIdentifier
  }
}

// MARK: - TInitOtpInput

public struct TInitOtpInput: Codable, Sendable {
  public let body: TInitOtpBody

  public init(
    body: TInitOtpBody
  ) {
    self.body = body
  }
}

// MARK: - TInitOtpAuthResponse

public struct TInitOtpAuthResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for an OTP authentication
  public let otpId: String
}

// MARK: - TInitOtpAuthBody

public struct TInitOtpAuthBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true
  public let alphanumeric: Bool?
  /// The name of the application.
  public let appName: String
  /// Email or phone number to send the OTP code to
  public let contact: String
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomization: v1EmailCustomizationParams?
  /// Optional length of the OTP code. Default = 9
  public let otpLength: Int?
  /// Enum to specifiy whether to send OTP via SMS or email
  public let otpType: String
  /// Optional custom email address to use as reply-to
  public let replyToEmailAddress: String?
  /// Optional custom email address from which to send the OTP email
  public let sendFromEmailAddress: String?
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  public let sendFromEmailSenderName: String?
  /// Optional parameters for customizing SMS message. If not provided, the default sms message will be used.
  public let smsCustomization: v1SmsCustomizationParams?
  /// Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.
  public let userIdentifier: String?

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    alphanumeric: Bool? = nil,
    appName: String,
    contact: String,
    emailCustomization: v1EmailCustomizationParams? = nil,
    otpLength: Int? = nil,
    otpType: String,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    smsCustomization: v1SmsCustomizationParams? = nil,
    userIdentifier: String? = nil
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.alphanumeric = alphanumeric
    self.appName = appName
    self.contact = contact
    self.emailCustomization = emailCustomization
    self.otpLength = otpLength
    self.otpType = otpType
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.smsCustomization = smsCustomization
    self.userIdentifier = userIdentifier
  }
}

// MARK: - TInitOtpAuthInput

public struct TInitOtpAuthInput: Codable, Sendable {
  public let body: TInitOtpAuthBody

  public init(
    body: TInitOtpAuthBody
  ) {
    self.body = body
  }
}

// MARK: - TInitUserEmailRecoveryResponse

public struct TInitUserEmailRecoveryResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for the user being recovered.
  public let userId: String
}

// MARK: - TInitUserEmailRecoveryBody

public struct TInitUserEmailRecoveryBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The name of the application.
  public let appName: String
  /// Email of the user starting recovery
  public let email: String
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  public let emailCustomization: v1EmailCustomizationParams?
  /// Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Optional custom email address to use as reply-to
  public let replyToEmailAddress: String?
  /// Optional custom email address from which to send the OTP email
  public let sendFromEmailAddress: String?
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  public let sendFromEmailSenderName: String?
  /// Client-side public key generated by the user, to which the recovery bundle will be encrypted.
  public let targetPublicKey: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    appName: String,
    email: String,
    emailCustomization: v1EmailCustomizationParams? = nil,
    expirationSeconds: String? = nil,
    replyToEmailAddress: String? = nil,
    sendFromEmailAddress: String? = nil,
    sendFromEmailSenderName: String? = nil,
    targetPublicKey: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.appName = appName
    self.email = email
    self.emailCustomization = emailCustomization
    self.expirationSeconds = expirationSeconds
    self.replyToEmailAddress = replyToEmailAddress
    self.sendFromEmailAddress = sendFromEmailAddress
    self.sendFromEmailSenderName = sendFromEmailSenderName
    self.targetPublicKey = targetPublicKey
  }
}

// MARK: - TInitUserEmailRecoveryInput

public struct TInitUserEmailRecoveryInput: Codable, Sendable {
  public let body: TInitUserEmailRecoveryBody

  public init(
    body: TInitUserEmailRecoveryBody
  ) {
    self.body = body
  }
}

// MARK: - TOauthResponse

public struct TOauthResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for the created API key.
  public let apiKeyId: String
  /// HPKE encrypted credential bundle
  public let credentialBundle: String
  /// Unique identifier for the authenticating User.
  public let userId: String
}

// MARK: - TOauthBody

public struct TOauthBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp>
  public let apiKeyName: String?
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated Oauth API keys
  public let invalidateExisting: Bool?
  /// Base64 encoded OIDC token
  public let oidcToken: String
  /// Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted.
  public let targetPublicKey: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    apiKeyName: String? = nil,
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    oidcToken: String,
    targetPublicKey: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.apiKeyName = apiKeyName
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.oidcToken = oidcToken
    self.targetPublicKey = targetPublicKey
  }
}

// MARK: - TOauthInput

public struct TOauthInput: Codable, Sendable {
  public let body: TOauthBody

  public init(
    body: TOauthBody
  ) {
    self.body = body
  }
}

// MARK: - TOauth2AuthenticateResponse

public struct TOauth2AuthenticateResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Base64 encoded OIDC token issued by Turnkey to be used with the LoginWithOAuth activity
  public let oidcToken: String
}

// MARK: - TOauth2AuthenticateBody

public struct TOauth2AuthenticateBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The auth_code provided by the OAuth 2.0 provider to the end user to be exchanged for a Bearer token in the OAuth 2.0 flow
  public let authCode: String
  /// An optional P256 public key to which, if provided, the bearer token will be encrypted and returned via the `encrypted_bearer_token` claim of the OIDC Token
  public let bearerTokenTargetPublicKey: String?
  /// The code verifier used by OAuth 2.0 PKCE providers
  public let codeVerifier: String
  /// An optional nonce used by the client to prevent replay/substitution of an ID token
  public let nonce: String?
  /// The OAuth 2.0 credential id whose client_id and client_secret will be used in the OAuth 2.0 flow
  public let oauth2CredentialId: String
  /// The URI the user is redirected to after they have authenticated with the OAuth 2.0 provider
  public let redirectUri: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    authCode: String,
    bearerTokenTargetPublicKey: String? = nil,
    codeVerifier: String,
    nonce: String? = nil,
    oauth2CredentialId: String,
    redirectUri: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.authCode = authCode
    self.bearerTokenTargetPublicKey = bearerTokenTargetPublicKey
    self.codeVerifier = codeVerifier
    self.nonce = nonce
    self.oauth2CredentialId = oauth2CredentialId
    self.redirectUri = redirectUri
  }
}

// MARK: - TOauth2AuthenticateInput

public struct TOauth2AuthenticateInput: Codable, Sendable {
  public let body: TOauth2AuthenticateBody

  public init(
    body: TOauth2AuthenticateBody
  ) {
    self.body = body
  }
}

// MARK: - TOauthLoginResponse

public struct TOauthLoginResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Signed JWT containing an expiry, public key, session type, user id, and organization id
  public let session: String
}

// MARK: - TOauthLoginBody

public struct TOauthLoginBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated Login API keys
  public let invalidateExisting: Bool?
  /// Base64 encoded OIDC token
  public let oidcToken: String
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request
  public let publicKey: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    oidcToken: String,
    publicKey: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.oidcToken = oidcToken
    self.publicKey = publicKey
  }
}

// MARK: - TOauthLoginInput

public struct TOauthLoginInput: Codable, Sendable {
  public let body: TOauthLoginBody

  public init(
    body: TOauthLoginBody
  ) {
    self.body = body
  }
}

// MARK: - TOtpAuthResponse

public struct TOtpAuthResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for the created API key.
  public let apiKeyId: String?
  /// HPKE encrypted credential bundle
  public let credentialBundle: String?
  /// Unique identifier for the authenticating User.
  public let userId: String
}

// MARK: - TOtpAuthBody

public struct TOtpAuthBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp>
  public let apiKeyName: String?
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated OTP Auth API keys
  public let invalidateExisting: Bool?
  /// OTP sent out to a user's contact (email or SMS)
  public let otpCode: String
  /// ID representing the result of an init OTP activity.
  public let otpId: String
  /// Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted.
  public let targetPublicKey: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    apiKeyName: String? = nil,
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    otpCode: String,
    otpId: String,
    targetPublicKey: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.apiKeyName = apiKeyName
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.otpCode = otpCode
    self.otpId = otpId
    self.targetPublicKey = targetPublicKey
  }
}

// MARK: - TOtpAuthInput

public struct TOtpAuthInput: Codable, Sendable {
  public let body: TOtpAuthBody

  public init(
    body: TOtpAuthBody
  ) {
    self.body = body
  }
}

// MARK: - TOtpLoginResponse

public struct TOtpLoginResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Signed JWT containing an expiry, public key, session type, user id, and organization id
  public let session: String
}

// MARK: - TOtpLoginBody

public struct TOtpLoginBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Optional signature proving authorization for this login. The signature is over the verification token ID and the public key. Only required if a public key was provided during the verification step.
  public let clientSignature: v1ClientSignature?
  /// Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated Login API keys
  public let invalidateExisting: Bool?
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token
  public let publicKey: String
  /// Signed JWT containing a unique id, expiry, verification type, contact
  public let verificationToken: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    clientSignature: v1ClientSignature? = nil,
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    publicKey: String,
    verificationToken: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.clientSignature = clientSignature
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.publicKey = publicKey
    self.verificationToken = verificationToken
  }
}

// MARK: - TOtpLoginInput

public struct TOtpLoginInput: Codable, Sendable {
  public let body: TOtpLoginBody

  public init(
    body: TOtpLoginBody
  ) {
    self.body = body
  }
}

// MARK: - TRecoverUserResponse

public struct TRecoverUserResponse: Codable, Sendable {
  public let activity: v1Activity
  /// ID of the authenticator created.
  public let authenticatorId: [String]
}

// MARK: - TRecoverUserBody

public struct TRecoverUserBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The new authenticator to register.
  public let authenticator: v1AuthenticatorParamsV2
  /// Unique identifier for the user performing recovery.
  public let userId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    authenticator: v1AuthenticatorParamsV2,
    userId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.authenticator = authenticator
    self.userId = userId
  }
}

// MARK: - TRecoverUserInput

public struct TRecoverUserInput: Codable, Sendable {
  public let body: TRecoverUserBody

  public init(
    body: TRecoverUserBody
  ) {
    self.body = body
  }
}

// MARK: - TRejectActivityResponse

public struct TRejectActivityResponse: Codable, Sendable {
  public let activity: v1Activity
}

// MARK: - TRejectActivityBody

public struct TRejectActivityBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// An artifact verifying a User's action.
  public let fingerprint: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    fingerprint: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.fingerprint = fingerprint
  }
}

// MARK: - TRejectActivityInput

public struct TRejectActivityInput: Codable, Sendable {
  public let body: TRejectActivityBody

  public init(
    body: TRejectActivityBody
  ) {
    self.body = body
  }
}

// MARK: - TRemoveOrganizationFeatureResponse

public struct TRemoveOrganizationFeatureResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Resulting list of organization features.
  public let features: [v1Feature]
}

// MARK: - TRemoveOrganizationFeatureBody

public struct TRemoveOrganizationFeatureBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Name of the feature to remove
  public let name: v1FeatureName

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    name: v1FeatureName
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.name = name
  }
}

// MARK: - TRemoveOrganizationFeatureInput

public struct TRemoveOrganizationFeatureInput: Codable, Sendable {
  public let body: TRemoveOrganizationFeatureBody

  public init(
    body: TRemoveOrganizationFeatureBody
  ) {
    self.body = body
  }
}

// MARK: - TSetOrganizationFeatureResponse

public struct TSetOrganizationFeatureResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Resulting list of organization features.
  public let features: [v1Feature]
}

// MARK: - TSetOrganizationFeatureBody

public struct TSetOrganizationFeatureBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Name of the feature to set
  public let name: v1FeatureName
  /// Optional value for the feature. Will override existing values if feature is already set.
  public let value: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    name: v1FeatureName,
    value: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.name = name
    self.value = value
  }
}

// MARK: - TSetOrganizationFeatureInput

public struct TSetOrganizationFeatureInput: Codable, Sendable {
  public let body: TSetOrganizationFeatureBody

  public init(
    body: TSetOrganizationFeatureBody
  ) {
    self.body = body
  }
}

// MARK: - TSignRawPayloadResponse

public struct TSignRawPayloadResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Component of an ECSDA signature.
  public let r: String
  /// Component of an ECSDA signature.
  public let s: String
  /// Component of an ECSDA signature.
  public let v: String
}

// MARK: - TSignRawPayloadBody

public struct TSignRawPayloadBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8).
  public let encoding: v1PayloadEncoding
  /// Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032.
  public let hashFunction: v1HashFunction
  /// Raw unsigned payload to be signed.
  public let payload: String
  /// A Wallet account address, Private Key address, or Private Key identifier.
  public let signWith: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    encoding: v1PayloadEncoding,
    hashFunction: v1HashFunction,
    payload: String,
    signWith: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.encoding = encoding
    self.hashFunction = hashFunction
    self.payload = payload
    self.signWith = signWith
  }
}

// MARK: - TSignRawPayloadInput

public struct TSignRawPayloadInput: Codable, Sendable {
  public let body: TSignRawPayloadBody

  public init(
    body: TSignRawPayloadBody
  ) {
    self.body = body
  }
}

// MARK: - TSignRawPayloadsResponse

public struct TSignRawPayloadsResponse: Codable, Sendable {
  public let activity: v1Activity
  public let signatures: [v1SignRawPayloadResult]?
}

// MARK: - TSignRawPayloadsBody

public struct TSignRawPayloadsBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8).
  public let encoding: v1PayloadEncoding
  /// Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032.
  public let hashFunction: v1HashFunction
  /// An array of raw unsigned payloads to be signed.
  public let payloads: [String]
  /// A Wallet account address, Private Key address, or Private Key identifier.
  public let signWith: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    encoding: v1PayloadEncoding,
    hashFunction: v1HashFunction,
    payloads: [String],
    signWith: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.encoding = encoding
    self.hashFunction = hashFunction
    self.payloads = payloads
    self.signWith = signWith
  }
}

// MARK: - TSignRawPayloadsInput

public struct TSignRawPayloadsInput: Codable, Sendable {
  public let body: TSignRawPayloadsBody

  public init(
    body: TSignRawPayloadsBody
  ) {
    self.body = body
  }
}

// MARK: - TSignTransactionResponse

public struct TSignTransactionResponse: Codable, Sendable {
  public let activity: v1Activity
  public let signedTransaction: String
}

// MARK: - TSignTransactionBody

public struct TSignTransactionBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A Wallet account address, Private Key address, or Private Key identifier.
  public let signWith: String
  public let type: v1TransactionType
  /// Raw unsigned transaction to be signed
  public let unsignedTransaction: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    signWith: String,
    type: v1TransactionType,
    unsignedTransaction: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.signWith = signWith
    self.type = type
    self.unsignedTransaction = unsignedTransaction
  }
}

// MARK: - TSignTransactionInput

public struct TSignTransactionInput: Codable, Sendable {
  public let body: TSignTransactionBody

  public init(
    body: TSignTransactionBody
  ) {
    self.body = body
  }
}

// MARK: - TStampLoginResponse

public struct TStampLoginResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Signed JWT containing an expiry, public key, session type, user id, and organization id
  public let session: String
}

// MARK: - TStampLoginBody

public struct TStampLoginBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.
  public let expirationSeconds: String?
  /// Invalidate all other previously generated Login API keys
  public let invalidateExisting: Bool?
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the passkey stamp associated with this request
  public let publicKey: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    expirationSeconds: String? = nil,
    invalidateExisting: Bool? = nil,
    publicKey: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.expirationSeconds = expirationSeconds
    self.invalidateExisting = invalidateExisting
    self.publicKey = publicKey
  }
}

// MARK: - TStampLoginInput

public struct TStampLoginInput: Codable, Sendable {
  public let body: TStampLoginBody

  public init(
    body: TStampLoginBody
  ) {
    self.body = body
  }
}

// MARK: - TUpdateFiatOnRampCredentialResponse

public struct TUpdateFiatOnRampCredentialResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier of the Fiat On-Ramp credential that was updated
  public let fiatOnRampCredentialId: String
}

// MARK: - TUpdateFiatOnRampCredentialBody

public struct TUpdateFiatOnRampCredentialBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.
  public let encryptedPrivateApiKey: String?
  /// Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key
  public let encryptedSecretApiKey: String
  /// The ID of the fiat on-ramp credential to update
  public let fiatOnrampCredentialId: String
  /// The fiat on-ramp provider
  public let onrampProvider: v1FiatOnRampProvider
  /// Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier.
  public let projectId: String?
  /// Publishable API key for the on-ramp provider
  public let publishableApiKey: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    encryptedPrivateApiKey: String? = nil,
    encryptedSecretApiKey: String,
    fiatOnrampCredentialId: String,
    onrampProvider: v1FiatOnRampProvider,
    projectId: String? = nil,
    publishableApiKey: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.encryptedPrivateApiKey = encryptedPrivateApiKey
    self.encryptedSecretApiKey = encryptedSecretApiKey
    self.fiatOnrampCredentialId = fiatOnrampCredentialId
    self.onrampProvider = onrampProvider
    self.projectId = projectId
    self.publishableApiKey = publishableApiKey
  }
}

// MARK: - TUpdateFiatOnRampCredentialInput

public struct TUpdateFiatOnRampCredentialInput: Codable, Sendable {
  public let body: TUpdateFiatOnRampCredentialBody

  public init(
    body: TUpdateFiatOnRampCredentialBody
  ) {
    self.body = body
  }
}

// MARK: - TUpdateOauth2CredentialResponse

public struct TUpdateOauth2CredentialResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier of the OAuth 2.0 credential that was updated
  public let oauth2CredentialId: String
}

// MARK: - TUpdateOauth2CredentialBody

public struct TUpdateOauth2CredentialBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The Client ID issued by the OAuth 2.0 provider
  public let clientId: String
  /// The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key
  public let encryptedClientSecret: String
  /// The ID of the OAuth 2.0 credential to update
  public let oauth2CredentialId: String
  /// The OAuth 2.0 provider
  public let provider: v1Oauth2Provider

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    clientId: String,
    encryptedClientSecret: String,
    oauth2CredentialId: String,
    provider: v1Oauth2Provider
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.clientId = clientId
    self.encryptedClientSecret = encryptedClientSecret
    self.oauth2CredentialId = oauth2CredentialId
    self.provider = provider
  }
}

// MARK: - TUpdateOauth2CredentialInput

public struct TUpdateOauth2CredentialInput: Codable, Sendable {
  public let body: TUpdateOauth2CredentialBody

  public init(
    body: TUpdateOauth2CredentialBody
  ) {
    self.body = body
  }
}

// MARK: - TUpdatePolicyResponse

public struct TUpdatePolicyResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for a given Policy.
  public let policyId: String
}

// MARK: - TUpdatePolicyBody

public struct TUpdatePolicyBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The condition expression that triggers the Effect (optional).
  public let policyCondition: String?
  /// The consensus expression that triggers the Effect (optional).
  public let policyConsensus: String?
  /// The instruction to DENY or ALLOW an activity (optional).
  public let policyEffect: v1Effect?
  /// Unique identifier for a given Policy.
  public let policyId: String
  /// Human-readable name for a Policy.
  public let policyName: String?
  /// Accompanying notes for a Policy (optional).
  public let policyNotes: String?

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    policyCondition: String? = nil,
    policyConsensus: String? = nil,
    policyEffect: v1Effect? = nil,
    policyId: String,
    policyName: String? = nil,
    policyNotes: String? = nil
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.policyCondition = policyCondition
    self.policyConsensus = policyConsensus
    self.policyEffect = policyEffect
    self.policyId = policyId
    self.policyName = policyName
    self.policyNotes = policyNotes
  }
}

// MARK: - TUpdatePolicyInput

public struct TUpdatePolicyInput: Codable, Sendable {
  public let body: TUpdatePolicyBody

  public init(
    body: TUpdatePolicyBody
  ) {
    self.body = body
  }
}

// MARK: - TUpdatePrivateKeyTagResponse

public struct TUpdatePrivateKeyTagResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for a given Private Key Tag.
  public let privateKeyTagId: String
}

// MARK: - TUpdatePrivateKeyTagBody

public struct TUpdatePrivateKeyTagBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of Private Keys IDs to add this tag to.
  public let addPrivateKeyIds: [String]
  /// The new, human-readable name for the tag with the given ID.
  public let newPrivateKeyTagName: String?
  /// Unique identifier for a given Private Key Tag.
  public let privateKeyTagId: String
  /// A list of Private Key IDs to remove this tag from.
  public let removePrivateKeyIds: [String]

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    addPrivateKeyIds: [String],
    newPrivateKeyTagName: String? = nil,
    privateKeyTagId: String,
    removePrivateKeyIds: [String]
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.addPrivateKeyIds = addPrivateKeyIds
    self.newPrivateKeyTagName = newPrivateKeyTagName
    self.privateKeyTagId = privateKeyTagId
    self.removePrivateKeyIds = removePrivateKeyIds
  }
}

// MARK: - TUpdatePrivateKeyTagInput

public struct TUpdatePrivateKeyTagInput: Codable, Sendable {
  public let body: TUpdatePrivateKeyTagBody

  public init(
    body: TUpdatePrivateKeyTagBody
  ) {
    self.body = body
  }
}

// MARK: - TUpdateRootQuorumResponse

public struct TUpdateRootQuorumResponse: Codable, Sendable {
  public let activity: v1Activity
}

// MARK: - TUpdateRootQuorumBody

public struct TUpdateRootQuorumBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The threshold of unique approvals to reach quorum.
  public let threshold: Int
  /// The unique identifiers of users who comprise the quorum set.
  public let userIds: [String]

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    threshold: Int,
    userIds: [String]
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.threshold = threshold
    self.userIds = userIds
  }
}

// MARK: - TUpdateRootQuorumInput

public struct TUpdateRootQuorumInput: Codable, Sendable {
  public let body: TUpdateRootQuorumBody

  public init(
    body: TUpdateRootQuorumBody
  ) {
    self.body = body
  }
}

// MARK: - TUpdateUserResponse

public struct TUpdateUserResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A User ID.
  public let userId: String
}

// MARK: - TUpdateUserBody

public struct TUpdateUserBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The user's email address.
  public let userEmail: String?
  /// Unique identifier for a given User.
  public let userId: String
  /// Human-readable name for a User.
  public let userName: String?
  /// The user's phone number in E.164 format e.g. +13214567890
  public let userPhoneNumber: String?
  /// An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body.
  public let userTagIds: [String]?

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    userEmail: String? = nil,
    userId: String,
    userName: String? = nil,
    userPhoneNumber: String? = nil,
    userTagIds: [String]? = nil
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.userEmail = userEmail
    self.userId = userId
    self.userName = userName
    self.userPhoneNumber = userPhoneNumber
    self.userTagIds = userTagIds
  }
}

// MARK: - TUpdateUserInput

public struct TUpdateUserInput: Codable, Sendable {
  public let body: TUpdateUserBody

  public init(
    body: TUpdateUserBody
  ) {
    self.body = body
  }
}

// MARK: - TUpdateUserEmailResponse

public struct TUpdateUserEmailResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier of the User whose email was updated.
  public let userId: String
}

// MARK: - TUpdateUserEmailBody

public struct TUpdateUserEmailBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// The user's email address. Setting this to an empty string will remove the user's email.
  public let userEmail: String
  /// Unique identifier for a given User.
  public let userId: String
  /// Signed JWT containing a unique id, expiry, verification type, contact
  public let verificationToken: String?

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    userEmail: String,
    userId: String,
    verificationToken: String? = nil
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.userEmail = userEmail
    self.userId = userId
    self.verificationToken = verificationToken
  }
}

// MARK: - TUpdateUserEmailInput

public struct TUpdateUserEmailInput: Codable, Sendable {
  public let body: TUpdateUserEmailBody

  public init(
    body: TUpdateUserEmailBody
  ) {
    self.body = body
  }
}

// MARK: - TUpdateUserNameResponse

public struct TUpdateUserNameResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier of the User whose name was updated.
  public let userId: String
}

// MARK: - TUpdateUserNameBody

public struct TUpdateUserNameBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Unique identifier for a given User.
  public let userId: String
  /// Human-readable name for a User.
  public let userName: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    userId: String,
    userName: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.userId = userId
    self.userName = userName
  }
}

// MARK: - TUpdateUserNameInput

public struct TUpdateUserNameInput: Codable, Sendable {
  public let body: TUpdateUserNameBody

  public init(
    body: TUpdateUserNameBody
  ) {
    self.body = body
  }
}

// MARK: - TUpdateUserPhoneNumberResponse

public struct TUpdateUserPhoneNumberResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier of the User whose phone number was updated.
  public let userId: String
}

// MARK: - TUpdateUserPhoneNumberBody

public struct TUpdateUserPhoneNumberBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Unique identifier for a given User.
  public let userId: String
  /// The user's phone number in E.164 format e.g. +13214567890. Setting this to an empty string will remove the user's phone number.
  public let userPhoneNumber: String
  /// Signed JWT containing a unique id, expiry, verification type, contact
  public let verificationToken: String?

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    userId: String,
    userPhoneNumber: String,
    verificationToken: String? = nil
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.userId = userId
    self.userPhoneNumber = userPhoneNumber
    self.verificationToken = verificationToken
  }
}

// MARK: - TUpdateUserPhoneNumberInput

public struct TUpdateUserPhoneNumberInput: Codable, Sendable {
  public let body: TUpdateUserPhoneNumberBody

  public init(
    body: TUpdateUserPhoneNumberBody
  ) {
    self.body = body
  }
}

// MARK: - TUpdateUserTagResponse

public struct TUpdateUserTagResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Unique identifier for a given User Tag.
  public let userTagId: String
}

// MARK: - TUpdateUserTagBody

public struct TUpdateUserTagBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// A list of User IDs to add this tag to.
  public let addUserIds: [String]
  /// The new, human-readable name for the tag with the given ID.
  public let newUserTagName: String?
  /// A list of User IDs to remove this tag from.
  public let removeUserIds: [String]
  /// Unique identifier for a given User Tag.
  public let userTagId: String

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    addUserIds: [String],
    newUserTagName: String? = nil,
    removeUserIds: [String],
    userTagId: String
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.addUserIds = addUserIds
    self.newUserTagName = newUserTagName
    self.removeUserIds = removeUserIds
    self.userTagId = userTagId
  }
}

// MARK: - TUpdateUserTagInput

public struct TUpdateUserTagInput: Codable, Sendable {
  public let body: TUpdateUserTagBody

  public init(
    body: TUpdateUserTagBody
  ) {
    self.body = body
  }
}

// MARK: - TUpdateWalletResponse

public struct TUpdateWalletResponse: Codable, Sendable {
  public let activity: v1Activity
  /// A Wallet ID.
  public let walletId: String
}

// MARK: - TUpdateWalletBody

public struct TUpdateWalletBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Unique identifier for a given Wallet.
  public let walletId: String
  /// Human-readable name for a Wallet.
  public let walletName: String?

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    walletId: String,
    walletName: String? = nil
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.walletId = walletId
    self.walletName = walletName
  }
}

// MARK: - TUpdateWalletInput

public struct TUpdateWalletInput: Codable, Sendable {
  public let body: TUpdateWalletBody

  public init(
    body: TUpdateWalletBody
  ) {
    self.body = body
  }
}

// MARK: - TVerifyOtpResponse

public struct TVerifyOtpResponse: Codable, Sendable {
  public let activity: v1Activity
  /// Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests)
  public let verificationToken: String
}

// MARK: - TVerifyOtpBody

public struct TVerifyOtpBody: Codable, Sendable {
  public let timestampMs: String?
  public let organizationId: String?
  /// Expiration window (in seconds) indicating how long the verification token is valid for. If not provided, a default of 1 hour will be used. Maximum value is 86400 seconds (24 hours)
  public let expirationSeconds: String?
  /// OTP sent out to a user's contact (email or SMS)
  public let otpCode: String
  /// ID representing the result of an init OTP activity.
  public let otpId: String
  /// Client-side public key generated by the user, which will be added to the JWT response and verified in subsequent requests via a client proof signature
  public let publicKey: String?

  public init(
    timestampMs: String? = nil,
    organizationId: String? = nil,
    expirationSeconds: String? = nil,
    otpCode: String,
    otpId: String,
    publicKey: String? = nil
  ) {
    self.timestampMs = timestampMs
    self.organizationId = organizationId
    self.expirationSeconds = expirationSeconds
    self.otpCode = otpCode
    self.otpId = otpId
    self.publicKey = publicKey
  }
}

// MARK: - TVerifyOtpInput

public struct TVerifyOtpInput: Codable, Sendable {
  public let body: TVerifyOtpBody

  public init(
    body: TVerifyOtpBody
  ) {
    self.body = body
  }
}

// MARK: - TNOOPCodegenAnchorResponse

public struct TNOOPCodegenAnchorResponse: Codable, Sendable {
  public let activity: v1Activity
}

// MARK: - TNOOPCodegenAnchorBody

public struct TNOOPCodegenAnchorBody: Codable, Sendable {
  public init() {}
}

// MARK: - TTestRateLimitsResponse

public struct TTestRateLimitsResponse: Codable, Sendable {
}

// MARK: - TTestRateLimitsBody

public struct TTestRateLimitsBody: Codable, Sendable {
  public let organizationId: String?
  /// Whether or not to set a limit on this request.
  public let isSetLimit: Bool
  /// Rate limit to set for org, if is_set_limit is set to true.
  public let limit: Int

  public init(
    organizationId: String? = nil,
    isSetLimit: Bool,
    limit: Int
  ) {
    self.organizationId = organizationId
    self.isSetLimit = isSetLimit
    self.limit = limit
  }
}

// MARK: - TTestRateLimitsInput

public struct TTestRateLimitsInput: Codable, Sendable {
  public let body: TTestRateLimitsBody

  public init(
    body: TTestRateLimitsBody
  ) {
    self.body = body
  }
}

// MARK: - ProxyTGetAccountResponse

public struct ProxyTGetAccountResponse: Codable, Sendable {
  public let organizationId: String?
}

// MARK: - ProxyTGetAccountBody

public struct ProxyTGetAccountBody: Codable, Sendable {
  /// Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN' or 'PUBLIC_KEY'
  public let filterType: String
  /// The value of the filter to apply for the specified type. For example, a specific email or name string.
  public let filterValue: String
  /// Signed JWT containing a unique id, expiry, verification type, contact. Used to verify access to PII (email/phone number) when filter_type is 'EMAIL' or 'PHONE_NUMBER'.
  public let verificationToken: String?

  public init(
    filterType: String,
    filterValue: String,
    verificationToken: String? = nil
  ) {
    self.filterType = filterType
    self.filterValue = filterValue
    self.verificationToken = verificationToken
  }
}

// MARK: - ProxyTGetAccountInput

public struct ProxyTGetAccountInput: Codable, Sendable {
  public let body: ProxyTGetAccountBody

  public init(
    body: ProxyTGetAccountBody
  ) {
    self.body = body
  }
}

// MARK: - ProxyTOAuth2AuthenticateResponse

public struct ProxyTOAuth2AuthenticateResponse: Codable, Sendable {
  /// A Turnkey issued OIDC token to be used with the LoginWithOAuth activity
  public let oidcToken: String
}

// MARK: - ProxyTOAuth2AuthenticateBody

public struct ProxyTOAuth2AuthenticateBody: Codable, Sendable {
  /// The auth_code provided by the OAuth 2.0 to the end user to be exchanged for a Bearer token in the OAuth 2.0 flow
  public let authCode: String
  /// The client ID registered with the OAuth 2.0 provider
  public let clientId: String
  /// The code verifier used by OAuth 2.0 PKCE providers
  public let codeVerifier: String
  /// An optional nonce used by the client to prevent replay/substitution of an ID token
  public let nonce: String?
  /// The OAuth 2.0 provider to authenticate with
  public let provider: v1Oauth2Provider
  /// The URI the user is redirected to after they have authenticated with the OAuth 2.0 provider
  public let redirectUri: String

  public init(
    authCode: String,
    clientId: String,
    codeVerifier: String,
    nonce: String? = nil,
    provider: v1Oauth2Provider,
    redirectUri: String
  ) {
    self.authCode = authCode
    self.clientId = clientId
    self.codeVerifier = codeVerifier
    self.nonce = nonce
    self.provider = provider
    self.redirectUri = redirectUri
  }
}

// MARK: - ProxyTOAuth2AuthenticateInput

public struct ProxyTOAuth2AuthenticateInput: Codable, Sendable {
  public let body: ProxyTOAuth2AuthenticateBody

  public init(
    body: ProxyTOAuth2AuthenticateBody
  ) {
    self.body = body
  }
}

// MARK: - ProxyTOAuthLoginResponse

public struct ProxyTOAuthLoginResponse: Codable, Sendable {
  /// Signed JWT containing an expiry, public key, session type, user id, and organization id
  public let session: String
}

// MARK: - ProxyTOAuthLoginBody

public struct ProxyTOAuthLoginBody: Codable, Sendable {
  /// Invalidate all other previously generated Login API keys
  public let invalidateExisting: Bool?
  /// Base64 encoded OIDC token
  public let oidcToken: String
  /// Unique identifier for a given Organization. If provided, this organization id will be used directly. If omitted, uses the OIDC token to look up the associated organization id.
  public let organizationId: String?
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request
  public let publicKey: String

  public init(
    invalidateExisting: Bool? = nil,
    oidcToken: String,
    organizationId: String? = nil,
    publicKey: String
  ) {
    self.invalidateExisting = invalidateExisting
    self.oidcToken = oidcToken
    self.organizationId = organizationId
    self.publicKey = publicKey
  }
}

// MARK: - ProxyTOAuthLoginInput

public struct ProxyTOAuthLoginInput: Codable, Sendable {
  public let body: ProxyTOAuthLoginBody

  public init(
    body: ProxyTOAuthLoginBody
  ) {
    self.body = body
  }
}

// MARK: - ProxyTInitOtpResponse

public struct ProxyTInitOtpResponse: Codable, Sendable {
  /// Unique identifier for an OTP authentication
  public let otpId: String
}

// MARK: - ProxyTInitOtpBody

public struct ProxyTInitOtpBody: Codable, Sendable {
  /// Email or phone number to send the OTP code to
  public let contact: String
  /// Enum to specifiy whether to send OTP via SMS or email
  public let otpType: String

  public init(
    contact: String,
    otpType: String
  ) {
    self.contact = contact
    self.otpType = otpType
  }
}

// MARK: - ProxyTInitOtpInput

public struct ProxyTInitOtpInput: Codable, Sendable {
  public let body: ProxyTInitOtpBody

  public init(
    body: ProxyTInitOtpBody
  ) {
    self.body = body
  }
}

// MARK: - ProxyTOtpLoginResponse

public struct ProxyTOtpLoginResponse: Codable, Sendable {
  /// Signed JWT containing an expiry, public key, session type, user id, and organization id
  public let session: String
}

// MARK: - ProxyTOtpLoginBody

public struct ProxyTOtpLoginBody: Codable, Sendable {
  /// Optional signature proving authorization for this login. The signature is over the verification token ID and the public key. Only required if a public key was provided during the verification step.
  public let clientSignature: v1ClientSignature?
  /// Invalidate all other previously generated Login API keys
  public let invalidateExisting: Bool?
  /// Unique identifier for a given Organization. If provided, this organization id will be used directly. If omitted, uses the verification token to look up the verified sub-organization based on the contact and verification type.
  public let organizationId: String?
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token
  public let publicKey: String
  /// Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests)
  public let verificationToken: String

  public init(
    clientSignature: v1ClientSignature? = nil,
    invalidateExisting: Bool? = nil,
    organizationId: String? = nil,
    publicKey: String,
    verificationToken: String
  ) {
    self.clientSignature = clientSignature
    self.invalidateExisting = invalidateExisting
    self.organizationId = organizationId
    self.publicKey = publicKey
    self.verificationToken = verificationToken
  }
}

// MARK: - ProxyTOtpLoginInput

public struct ProxyTOtpLoginInput: Codable, Sendable {
  public let body: ProxyTOtpLoginBody

  public init(
    body: ProxyTOtpLoginBody
  ) {
    self.body = body
  }
}

// MARK: - ProxyTVerifyOtpResponse

public struct ProxyTVerifyOtpResponse: Codable, Sendable {
  /// Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests)
  public let verificationToken: String
}

// MARK: - ProxyTVerifyOtpBody

public struct ProxyTVerifyOtpBody: Codable, Sendable {
  /// OTP sent out to a user's contact (email or SMS)
  public let otpCode: String
  /// ID representing the result of an init OTP activity.
  public let otpId: String
  /// Client-side public key generated by the user, which will be added to the JWT response and verified in subsequent requests via a client proof signature
  public let publicKey: String?

  public init(
    otpCode: String,
    otpId: String,
    publicKey: String? = nil
  ) {
    self.otpCode = otpCode
    self.otpId = otpId
    self.publicKey = publicKey
  }
}

// MARK: - ProxyTVerifyOtpInput

public struct ProxyTVerifyOtpInput: Codable, Sendable {
  public let body: ProxyTVerifyOtpBody

  public init(
    body: ProxyTVerifyOtpBody
  ) {
    self.body = body
  }
}

// MARK: - ProxyTSignupResponse

public struct ProxyTSignupResponse: Codable, Sendable {
  /// A list of App Proofs generated by enclaves during activity execution, providing verifiable attestations of performed operations.
  public let appProofs: [v1AppProof]?
  public let organizationId: String
  /// Root user ID created for this sub-organization
  public let userId: String
  /// Wallet created for the sub-organization, if provided in the request
  public let wallet: v1WalletResult?
}

// MARK: - ProxyTSignupBody

public struct ProxyTSignupBody: Codable, Sendable {
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  public let apiKeys: [v1ApiKeyParamsV2]
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  public let authenticators: [v1AuthenticatorParamsV2]
  /// Optional signature proving authorization for this signup. The signature is over the verification token ID and the root user parameters for the root user associated with the verification token. Only required if a public key was provided during the verification step.
  public let clientSignature: v1ClientSignature?
  /// A list of Oauth providers. This field, if not needed, should be an empty array in your request body.
  public let oauthProviders: [v1OauthProviderParams]
  public let organizationName: String?
  public let userEmail: String?
  public let userName: String?
  public let userPhoneNumber: String?
  public let userTag: String?
  public let verificationToken: String?
  /// The wallet to create for the sub-organization
  public let wallet: v1WalletParams?

  public init(
    apiKeys: [v1ApiKeyParamsV2],
    authenticators: [v1AuthenticatorParamsV2],
    clientSignature: v1ClientSignature? = nil,
    oauthProviders: [v1OauthProviderParams],
    organizationName: String? = nil,
    userEmail: String? = nil,
    userName: String? = nil,
    userPhoneNumber: String? = nil,
    userTag: String? = nil,
    verificationToken: String? = nil,
    wallet: v1WalletParams? = nil
  ) {
    self.apiKeys = apiKeys
    self.authenticators = authenticators
    self.clientSignature = clientSignature
    self.oauthProviders = oauthProviders
    self.organizationName = organizationName
    self.userEmail = userEmail
    self.userName = userName
    self.userPhoneNumber = userPhoneNumber
    self.userTag = userTag
    self.verificationToken = verificationToken
    self.wallet = wallet
  }
}

// MARK: - ProxyTSignupInput

public struct ProxyTSignupInput: Codable, Sendable {
  public let body: ProxyTSignupBody

  public init(
    body: ProxyTSignupBody
  ) {
    self.body = body
  }
}

// MARK: - ProxyTGetWalletKitConfigResponse

public struct ProxyTGetWalletKitConfigResponse: Codable, Sendable {
  /// List of enabled authentication providers (e.g., 'facebook', 'google', 'apple', 'email', 'sms', 'passkey', 'wallet')
  public let enabledProviders: [String]
  /// Mapping of social login providers to their OAuth client IDs.
  public let oauthClientIds: [String: String]?
  /// OAuth redirect URL to be used for social login flows.
  public let oauthRedirectUrl: String?
  /// The organization ID this configuration applies to
  public let organizationId: String
  public let otpAlphanumeric: Bool?
  public let otpLength: String?
  /// Session expiration duration in seconds
  public let sessionExpirationSeconds: String
}

// MARK: - ProxyTGetWalletKitConfigBody

public struct ProxyTGetWalletKitConfigBody: Codable, Sendable {

  public init() {}
}

// MARK: - ProxyTGetWalletKitConfigInput

public struct ProxyTGetWalletKitConfigInput: Codable, Sendable {
  public let body: ProxyTGetWalletKitConfigBody

  public init(
    body: ProxyTGetWalletKitConfigBody
  ) {
    self.body = body
  }
}
