import HTTPTypes
// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime

#if os(Linux)
  @preconcurrency import struct Foundation.URL
  @preconcurrency import struct Foundation.Data
  @preconcurrency import struct Foundation.Date
#else
  import struct Foundation.URL
  import struct Foundation.Data
  import struct Foundation.Date
#endif
/// Authentication Proxy Service API
public struct Client: APIProtocol {
  /// The underlying HTTP client.
  private let client: UniversalClient
  /// Creates a new client.
  /// - Parameters:
  ///   - serverURL: The server URL that the client connects to. Any server
  ///   URLs defined in the OpenAPI document are available as static methods
  ///   on the ``Servers`` type.
  ///   - configuration: A set of configuration values for the client.
  ///   - transport: A transport that performs HTTP operations.
  ///   - middlewares: A list of middlewares to call before the transport.
  public init(
    serverURL: Foundation.URL,
    configuration: Configuration = .init(),
    transport: any ClientTransport,
    middlewares: [any ClientMiddleware] = []
  ) {
    self.client = .init(
      serverURL: serverURL,
      configuration: configuration,
      transport: transport,
      middlewares: middlewares
    )
  }
  private var converter: Converter {
    client.converter
  }
  /// Get Account
  ///
  /// Return organization id associated with a given phone number, email, public key, credential ID or OIDC token.
  ///
  /// - Remark: HTTP `POST /v1/account`.
  /// - Remark: Generated from `#/paths//v1/account/post(GetAccount)`.
  public func GetAccount(_ input: Operations.GetAccount.Input) async throws
    -> Operations.GetAccount.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.GetAccount.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/v1/account",
          parameters: []
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case .json(let value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.GetAccount.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.GetAccountResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        default:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.GetAccount.Output.Default.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.RpcStatus.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .`default`(
            statusCode: response.status.code,
            .init(body: body)
          )
        }
      }
    )
  }
  /// OAuth 2.0 Authenticate
  ///
  /// Authenticate with an OAuth 2.0 provider and receive an OIDC token issued by Turnkey in response.
  ///
  /// - Remark: HTTP `POST /v1/oauth2_authenticate`.
  /// - Remark: Generated from `#/paths//v1/oauth2_authenticate/post(OAuth2Authenticate)`.
  public func OAuth2Authenticate(_ input: Operations.OAuth2Authenticate.Input) async throws
    -> Operations.OAuth2Authenticate.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.OAuth2Authenticate.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/v1/oauth2_authenticate",
          parameters: []
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case .json(let value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.OAuth2Authenticate.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.OAuth2AuthenticateResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        default:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.OAuth2Authenticate.Output.Default.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.RpcStatus.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .`default`(
            statusCode: response.status.code,
            .init(body: body)
          )
        }
      }
    )
  }
  /// OAuth Login
  ///
  /// Login using an OIDC token and public key.
  ///
  /// - Remark: HTTP `POST /v1/oauth_login`.
  /// - Remark: Generated from `#/paths//v1/oauth_login/post(OAuthLogin)`.
  public func OAuthLogin(_ input: Operations.OAuthLogin.Input) async throws
    -> Operations.OAuthLogin.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.OAuthLogin.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/v1/oauth_login",
          parameters: []
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case .json(let value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.OAuthLogin.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.OAuthLoginResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        default:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.OAuthLogin.Output.Default.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.RpcStatus.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .`default`(
            statusCode: response.status.code,
            .init(body: body)
          )
        }
      }
    )
  }
  /// Init OTP
  ///
  /// Initialize an OTP (email or SMS) for a user.
  ///
  /// - Remark: HTTP `POST /v1/otp_init`.
  /// - Remark: Generated from `#/paths//v1/otp_init/post(InitOtp)`.
  public func InitOtp(_ input: Operations.InitOtp.Input) async throws -> Operations.InitOtp.Output {
    try await client.send(
      input: input,
      forOperation: Operations.InitOtp.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/v1/otp_init",
          parameters: []
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case .json(let value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.InitOtp.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.InitOtpResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        default:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.InitOtp.Output.Default.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.RpcStatus.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .`default`(
            statusCode: response.status.code,
            .init(body: body)
          )
        }
      }
    )
  }
  /// OTP Login
  ///
  /// Login using a verification token and public key.
  ///
  /// - Remark: HTTP `POST /v1/otp_login`.
  /// - Remark: Generated from `#/paths//v1/otp_login/post(OtpLogin)`.
  public func OtpLogin(_ input: Operations.OtpLogin.Input) async throws
    -> Operations.OtpLogin.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.OtpLogin.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/v1/otp_login",
          parameters: []
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case .json(let value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.OtpLogin.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.OtpLoginResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        default:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.OtpLogin.Output.Default.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.RpcStatus.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .`default`(
            statusCode: response.status.code,
            .init(body: body)
          )
        }
      }
    )
  }
  /// Verify OTP
  ///
  /// Verify the OTP code previously sent to the user's contact and return a verification token.
  ///
  /// - Remark: HTTP `POST /v1/otp_verify`.
  /// - Remark: Generated from `#/paths//v1/otp_verify/post(VerifyOtp)`.
  public func VerifyOtp(_ input: Operations.VerifyOtp.Input) async throws
    -> Operations.VerifyOtp.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.VerifyOtp.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/v1/otp_verify",
          parameters: []
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case .json(let value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.VerifyOtp.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.VerifyOtpResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        default:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.VerifyOtp.Output.Default.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.RpcStatus.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .`default`(
            statusCode: response.status.code,
            .init(body: body)
          )
        }
      }
    )
  }
  /// Signup
  ///
  /// Onboard a new user.
  ///
  /// - Remark: HTTP `POST /v1/signup`.
  /// - Remark: Generated from `#/paths//v1/signup/post(Signup)`.
  public func Signup(_ input: Operations.Signup.Input) async throws -> Operations.Signup.Output {
    try await client.send(
      input: input,
      forOperation: Operations.Signup.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/v1/signup",
          parameters: []
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case .json(let value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.Signup.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.SignupResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        default:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.Signup.Output.Default.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.RpcStatus.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .`default`(
            statusCode: response.status.code,
            .init(body: body)
          )
        }
      }
    )
  }
  /// Get WalletKit Config
  ///
  /// Get wallet kit settings and feature toggles for the calling organization.
  ///
  /// - Remark: HTTP `POST /v1/wallet_kit_config`.
  /// - Remark: Generated from `#/paths//v1/wallet_kit_config/post(GetWalletKitConfig)`.
  public func GetWalletKitConfig(_ input: Operations.GetWalletKitConfig.Input) async throws
    -> Operations.GetWalletKitConfig.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.GetWalletKitConfig.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/v1/wallet_kit_config",
          parameters: []
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case .json(let value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.GetWalletKitConfig.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.GetWalletKitConfigResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        default:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.GetWalletKitConfig.Output.Default.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.RpcStatus.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .`default`(
            statusCode: response.status.code,
            .init(body: body)
          )
        }
      }
    )
  }
}
